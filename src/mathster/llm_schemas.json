{
  "metadata": {
    "generated_at": "2025-10-26T00:53:13.705417",
    "version": "2.0.0",
    "purpose": "LLM reference for mathematical object creation via agentic pipeline",
    "total_schemas": 76,
    "source_modules": [
      "core",
      "sympy",
      "registry",
      "relationships"
    ]
  },
  "workflow_guide": {
    "overview": "Fragile proof pipeline: Create mathematical objects \u2192 Define theorems \u2192 Write proofs \u2192 Validate \u2192 Submit for dual review (Gemini 2.5 Pro + Codex) \u2192 Register",
    "dual_review_protocol": "CLAUDE.md \u00a7 Collaborative Review Workflow (Step 2: Dual Independent Review via MCP)",
    "steps": [
      "1. Create MathematicalObjects with attributes using core.pipeline_types",
      "2. Define TheoremBox specifying input objects, required attributes, and established outputs",
      "3. Write ProofBox using compositional ProofSteps (direct_derivation, sub_proof, lemma_application)",
      "4. Validate proof against theorem using validate_proof_for_theorem()",
      "5. Submit to Gemini 2.5 Pro via mcp__gemini-cli__ask-gemini (model: gemini-2.5-pro)",
      "6. Submit to Codex via mcp__codex__codex for independent review",
      "7. Compare reviews: consensus issues (high confidence), discrepancies (verify manually), unique issues (medium confidence)",
      "8. Implement fixes after critical evaluation and cross-checking against docs/glossary.md",
      "9. Register in MathematicalRegistry for persistence and querying",
      "10. Build RelationshipGraph for analysis and visualization"
    ],
    "best_practices": [
      "Use attribute-level granularity: ProofInputs specify exact attributes needed, not entire objects",
      "Always validate dataflow before submission: proof.validate_dataflow() must return []",
      "Cross-reference to docs/glossary.md (683 entries) for notation consistency",
      "Use dual review (Gemini 2.5 Pro + Codex) with IDENTICAL prompts for rigor checking",
      "Maintain referential integrity: all object/theorem/proof IDs must exist in registry",
      "Follow ID conventions: obj-*, thm-*, proof-*, rel-*-*-* (kebab-case)",
      "When reviewers contradict, manually verify against framework docs (potential hallucination)",
      "Never accept claims that cannot be verified in docs/glossary.md or source documents"
    ]
  },
  "schemas_by_dependency": {
    "level_0_primitives": [
      {
        "name": "Axiom",
        "module": "mathster.core.pipeline_types",
        "docstring": "Immutable foundational truth never modified by theorems.\n\nAxioms can be used by any theorem but are never proved.\n\nMaps to Lean:\n    structure Axiom where\n      label : String\n      statement : String\n      mathematical_expression : String\n      foundational_framework : String",
        "json_schema": {
          "description": "Immutable foundational truth never modified by theorems.\n\nAxioms can be used by any theorem but are never proved.\n\nMaps to Lean:\n    structure Axiom where\n      label : String\n      statement : String\n      mathematical_expression : String\n      foundational_framework : String",
          "attributes": {
            "label": {
              "pattern": "^axiom-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "statement": {
              "minLength": 1,
              "title": "Statement",
              "type": "string"
            },
            "mathematical_expression": {
              "minLength": 1,
              "title": "Mathematical Expression",
              "type": "string"
            },
            "foundational_framework": {
              "minLength": 1,
              "title": "Foundational Framework",
              "type": "string"
            }
          },
          "required": [
            "label",
            "statement",
            "mathematical_expression",
            "foundational_framework"
          ],
          "title": "Axiom",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "statement": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "mathematical_expression": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "foundational_framework": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [
          "def-axiom-non-degenerate-noise",
          "def-axiom-guaranteed-revival",
          "def-axiom-bounded-deviation-variance",
          "def-axiom-margin-stability",
          "def-axiom-projection-compatibility",
          "def-axiom-sufficient-amplification",
          "def-axiom-boundary-regularity",
          "def-swarm-aggregation-operator-axiomatic",
          "def-axiom-geometric-consistency",
          "lem-validation-uniform-ball",
          "def-axiom-environmental-richness",
          "def-axiom-boundary-smoothness",
          "def-axiom-bounded-relative-collapse",
          "def-axiom-bounded-algorithmic-diameter",
          "def-axiom-range-respecting-mean",
          "def-assumption-instep-independence",
          "lem-empirical-aggregator-attributes",
          "def-axiom-bounded-variance-production",
          "def-axiom-reward-regularity"
        ],
        "example_instance": null
      },
      {
        "name": "CombinedTagQuery",
        "module": "mathster.registry.reference_system",
        "docstring": "Combined tag query with multiple conditions.\n\nExample:\n    must_have=[\"euclidean-gas\", \"discrete\"]  # AND\n    any_of=[\"particle\", \"swarm\"]             # OR\n    must_not_have=[\"deprecated\"]             # NOT\n\nMaps to Lean:\n    structure CombinedTagQuery where\n      must_have : List String\n      any_of : List String\n      must_not_have : List String",
        "json_schema": {
          "description": "Combined tag query with multiple conditions.\n\nExample:\n    must_have=[\"euclidean-gas\", \"discrete\"]  # AND\n    any_of=[\"particle\", \"swarm\"]             # OR\n    must_not_have=[\"deprecated\"]             # NOT\n\nMaps to Lean:\n    structure CombinedTagQuery where\n      must_have : List String\n      any_of : List String\n      must_not_have : List String",
          "attributes": {
            "must_have": {
              "description": "Tags that MUST be present (AND)",
              "items": {
                "type": "string"
              },
              "title": "Must Have",
              "type": "array"
            },
            "any_of": {
              "description": "At least ONE must be present (OR)",
              "items": {
                "type": "string"
              },
              "title": "Any Of",
              "type": "array"
            },
            "must_not_have": {
              "description": "Tags that MUST NOT be present (NOT)",
              "items": {
                "type": "string"
              },
              "title": "Must Not Have",
              "type": "array"
            }
          },
          "title": "CombinedTagQuery",
          "type": "object"
        },
        "fields": {
          "must_have": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Tags that MUST be present (AND)",
            "default": "PydanticUndefined"
          },
          "any_of": {
            "type": "typing.List[str]",
            "required": false,
            "description": "At least ONE must be present (OR)",
            "default": "PydanticUndefined"
          },
          "must_not_have": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Tags that MUST NOT be present (NOT)",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "must_have": [],
          "any_of": [],
          "must_not_have": []
        }
      },
      {
        "name": "DataFlowEdge",
        "module": "mathster.core.pipeline_types",
        "docstring": "Edge in data flow graph.",
        "json_schema": {
          "description": "Edge in data flow graph.",
          "attributes": {
            "from": {
              "title": "From",
              "type": "string"
            },
            "to": {
              "title": "To",
              "type": "string"
            },
            "flow_type": {
              "enum": [
                "input",
                "output",
                "property_addition"
              ],
              "title": "Flow Type",
              "type": "string"
            },
            "attributes_added": {
              "items": {
                "type": "string"
              },
              "title": "Properties Added",
              "type": "array"
            }
          },
          "required": [
            "from",
            "to",
            "flow_type"
          ],
          "title": "DataFlowEdge",
          "type": "object"
        },
        "fields": {
          "from_node": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "to_node": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "flow_type": {
            "type": "typing.Literal['input', 'output', 'property_addition']",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "attributes_added": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "DataFlowNode",
        "module": "mathster.core.pipeline_types",
        "docstring": "Node in data flow graph.",
        "json_schema": {
          "description": "Node in data flow graph.",
          "attributes": {
            "id": {
              "title": "Id",
              "type": "string"
            },
            "type": {
              "enum": [
                "object",
                "theorem"
              ],
              "title": "Type",
              "type": "string"
            },
            "current_attributes": {
              "items": {
                "type": "string"
              },
              "title": "Current Properties",
              "type": "array"
            }
          },
          "required": [
            "id",
            "type"
          ],
          "title": "DataFlowNode",
          "type": "object"
        },
        "fields": {
          "id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "type": {
            "type": "typing.Literal['object', 'theorem']",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "current_attributes": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "DependencyEdge",
        "module": "mathster.core.pipeline_types",
        "docstring": "Edge in dependency graph.",
        "json_schema": {
          "description": "Edge in dependency graph.",
          "attributes": {
            "from": {
              "title": "From",
              "type": "string"
            },
            "to": {
              "title": "To",
              "type": "string"
            },
            "dependency_type": {
              "enum": [
                "uses",
                "requires",
                "extends"
              ],
              "title": "Dependency Type",
              "type": "string"
            }
          },
          "required": [
            "from",
            "to",
            "dependency_type"
          ],
          "title": "DependencyEdge",
          "type": "object"
        },
        "fields": {
          "from_node": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "to_node": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "dependency_type": {
            "type": "typing.Literal['uses', 'requires', 'extends']",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "DependencyNode",
        "module": "mathster.core.pipeline_types",
        "docstring": "Node in dependency graph.",
        "json_schema": {
          "description": "Node in dependency graph.",
          "attributes": {
            "id": {
              "title": "Id",
              "type": "string"
            },
            "type": {
              "enum": [
                "theorem",
                "lemma",
                "proposition",
                "axiom"
              ],
              "title": "Type",
              "type": "string"
            }
          },
          "required": [
            "id",
            "type"
          ],
          "title": "DependencyNode",
          "type": "object"
        },
        "fields": {
          "id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "type": {
            "type": "typing.Literal['theorem', 'lemma', 'proposition', 'axiom']",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "EquivalenceClass",
        "module": "mathster.relationships.graphs",
        "docstring": "Set of mutually equivalent objects.\n\nMaps to Lean:\n    structure EquivalenceClass where\n      members : List String\n      representative : String",
        "json_schema": {
          "description": "Set of mutually equivalent objects.\n\nMaps to Lean:\n    structure EquivalenceClass where\n      members : List String\n      representative : String",
          "attributes": {
            "members": {
              "description": "Object IDs in equivalence class",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "title": "Members",
              "type": "array"
            },
            "representative": {
              "description": "Representative element",
              "title": "Representative",
              "type": "string"
            }
          },
          "required": [
            "members",
            "representative"
          ],
          "title": "EquivalenceClass",
          "type": "object"
        },
        "fields": {
          "members": {
            "type": "typing.List[str]",
            "required": true,
            "description": "Object IDs in equivalence class",
            "default": "PydanticUndefined"
          },
          "representative": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Representative element",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "Err",
        "module": "mathster.core.pipeline_types",
        "docstring": "Error result containing error message.",
        "json_schema": {
          "description": "Error result containing error message.",
          "attributes": {
            "error": {
              "title": "Error",
              "type": "string"
            }
          },
          "required": [
            "error"
          ],
          "title": "Err",
          "type": "object"
        },
        "fields": {
          "error": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [
          "thm-total-error-bound",
          "thm-langevin-baoab-discretization-error",
          "prop-mixing-rate-relationship",
          "thm-full-system-discretization-error",
          "lem-lipschitz-observable-error",
          "prop-finite-second-moment-meanfield",
          "prop-fourth-moment-baoab",
          "thm-mean-square-standardization-error",
          "thm-quantitative-propagation-chaos",
          "lem-baoab-invariant-measure-error",
          "lem-lie-splitting-weak-error",
          "lem-wasserstein-entropy",
          "def-components-mean-square-standardization-error",
          "prop-empirical-wasserstein-concentration",
          "thm-quantitative-error-propagation",
          "lem-baoab-weak-error",
          "prop-interaction-complexity-bound",
          "lem-quantitative-kl-bound",
          "lem-uniform-geometric-ergodicity"
        ],
        "example_instance": {
          "error": "example"
        }
      },
      {
        "name": "GraphNode",
        "module": "mathster.relationships.graphs",
        "docstring": "Node in relationship graph.\n\nMaps to Lean:\n    structure GraphNode where\n      id : String\n      node_type : String\n      tags : List String",
        "json_schema": {
          "description": "Node in relationship graph.\n\nMaps to Lean:\n    structure GraphNode where\n      id : String\n      node_type : String\n      tags : List String",
          "attributes": {
            "id": {
              "description": "Object ID",
              "minLength": 1,
              "title": "Id",
              "type": "string"
            },
            "node_type": {
              "description": "Object type (e.g., 'MathematicalObject')",
              "title": "Node Type",
              "type": "string"
            },
            "tags": {
              "description": "Object tags",
              "items": {
                "type": "string"
              },
              "title": "Tags",
              "type": "array"
            }
          },
          "required": [
            "id",
            "node_type"
          ],
          "title": "GraphNode",
          "type": "object"
        },
        "fields": {
          "id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Object ID",
            "default": "PydanticUndefined"
          },
          "node_type": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Object type (e.g., 'MathematicalObject')",
            "default": "PydanticUndefined"
          },
          "tags": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Object tags",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "id": "example",
          "node_type": "example",
          "tags": []
        }
      },
      {
        "name": "Ok",
        "module": "mathster.core.pipeline_types",
        "docstring": "Success result containing a value.",
        "json_schema": {
          "description": "Success result containing a value.",
          "attributes": {
            "value": {
              "title": "Value"
            }
          },
          "required": [
            "value"
          ],
          "title": "Ok",
          "type": "object"
        },
        "fields": {
          "value": {
            "type": "~T",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "value": null
        }
      },
      {
        "name": "Parameter",
        "module": "mathster.core.pipeline_types",
        "docstring": "Configuration value or constraint that controls theorem applicability.\n\nNot a mathematical object (doesn't accumulate attributes).\n\nMaps to Lean:\n    structure Parameter where\n      label : String\n      name : String\n      symbol : String\n      parameter_type : ParameterType\n      constraints : Option String\n      default_value : Option String",
        "json_schema": {
          "$defs": {
            "ParameterType": {
              "description": "Parameter value types.",
              "enum": [
                "real",
                "integer",
                "natural",
                "rational",
                "complex",
                "boolean",
                "symbolic"
              ],
              "title": "ParameterType",
              "type": "string"
            }
          },
          "description": "Configuration value or constraint that controls theorem applicability.\n\nNot a mathematical object (doesn't accumulate attributes).\n\nMaps to Lean:\n    structure Parameter where\n      label : String\n      name : String\n      symbol : String\n      parameter_type : ParameterType\n      constraints : Option String\n      default_value : Option String",
          "attributes": {
            "label": {
              "pattern": "^param-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "name": {
              "minLength": 1,
              "title": "Name",
              "type": "string"
            },
            "symbol": {
              "minLength": 1,
              "title": "Symbol",
              "type": "string"
            },
            "parameter_type": {
              "$ref": "#/$defs/ParameterType"
            },
            "constraints": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Constraints"
            },
            "default_value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Default Value"
            }
          },
          "required": [
            "label",
            "name",
            "symbol",
            "parameter_type"
          ],
          "title": "Parameter",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "name": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "symbol": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "parameter_type": {
            "type": "<enum 'ParameterType'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "constraints": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "No description",
            "default": null
          },
          "default_value": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "No description",
            "default": null
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [
          "def-reference-measures",
          "def-ambient-euclidean"
        ],
        "example_instance": null
      },
      {
        "name": "QueryResult",
        "module": "mathster.registry.reference_system",
        "docstring": "Result of a query operation.\n\nContains matched objects and metadata about the query.\n\nMaps to Lean:\n    structure QueryResult (T : Type) where\n      matches : List T\n      total_count : Nat\n      query_time_ms : Option Float",
        "json_schema": {
          "description": "Result of a query operation.\n\nContains matched objects and metadata about the query.\n\nMaps to Lean:\n    structure QueryResult (T : Type) where\n      matches : List T\n      total_count : Nat\n      query_time_ms : Option Float",
          "attributes": {
            "matches": {
              "description": "Objects matching the query",
              "items": {},
              "title": "Matches",
              "type": "array"
            },
            "total_count": {
              "description": "Total number of matches",
              "minimum": 0,
              "title": "Total Count",
              "type": "integer"
            },
            "query_time_ms": {
              "anyOf": [
                {
                  "minimum": 0,
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Query execution time in milliseconds",
              "title": "Query Time Ms"
            }
          },
          "required": [
            "matches",
            "total_count"
          ],
          "title": "QueryResult",
          "type": "object"
        },
        "fields": {
          "matches": {
            "type": "typing.List[~T]",
            "required": true,
            "description": "Objects matching the query",
            "default": "PydanticUndefined"
          },
          "total_count": {
            "type": "<class 'int'>",
            "required": true,
            "description": "Total number of matches",
            "default": "PydanticUndefined"
          },
          "query_time_ms": {
            "type": "typing.Optional[float]",
            "required": false,
            "description": "Query execution time in milliseconds",
            "default": null
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "matches": [],
          "total_count": 0,
          "query_time_ms": null
        }
      },
      {
        "name": "RegistryIndex",
        "module": "mathster.registry.registry",
        "docstring": "Index structure for fast lookups.\n\nMaintains:\n- ID \u2192 Object mapping (primary index)\n- Tag \u2192 IDs mapping (for tag queries)\n- Type \u2192 IDs mapping (for type queries)\n\nMaps to Lean:\n    structure RegistryIndex where\n      id_to_object : HashMap String Any\n      tag_to_ids : HashMap String (HashSet String)\n      type_to_ids : HashMap String (HashSet String)",
        "json_schema": {
          "description": "Index structure for fast lookups.\n\nMaintains:\n- ID \u2192 Object mapping (primary index)\n- Tag \u2192 IDs mapping (for tag queries)\n- Type \u2192 IDs mapping (for type queries)\n\nMaps to Lean:\n    structure RegistryIndex where\n      id_to_object : HashMap String Any\n      tag_to_ids : HashMap String (HashSet String)\n      type_to_ids : HashMap String (HashSet String)",
          "attributes": {
            "id_to_object": {
              "additionalProperties": true,
              "default": {},
              "title": "Id To Object",
              "type": "object"
            },
            "tag_to_ids": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "default": {},
              "title": "Tag To Ids",
              "type": "object"
            },
            "type_to_ids": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "default": {},
              "title": "Type To Ids",
              "type": "object"
            }
          },
          "title": "RegistryIndex",
          "type": "object"
        },
        "fields": {
          "id_to_object": {
            "type": "typing.Dict[str, typing.Any]",
            "required": false,
            "description": "No description",
            "default": "{}"
          },
          "tag_to_ids": {
            "type": "typing.Dict[str, typing.Set[str]]",
            "required": false,
            "description": "No description",
            "default": "{}"
          },
          "type_to_ids": {
            "type": "typing.Dict[str, typing.Set[str]]",
            "required": false,
            "description": "No description",
            "default": "{}"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "id_to_object": {},
          "tag_to_ids": {},
          "type_to_ids": {}
        }
      },
      {
        "name": "ResolutionContext",
        "module": "mathster.registry.reference_system",
        "docstring": "Context for resolving references.\n\nTracks:\n- Which IDs have been resolved\n- Which IDs failed to resolve\n- Circular dependency detection\n\nMaps to Lean:\n    structure ResolutionContext where\n      resolved : HashSet String\n      failed : HashSet String\n      resolution_stack : List String",
        "json_schema": {
          "description": "Context for resolving references.\n\nTracks:\n- Which IDs have been resolved\n- Which IDs failed to resolve\n- Circular dependency detection\n\nMaps to Lean:\n    structure ResolutionContext where\n      resolved : HashSet String\n      failed : HashSet String\n      resolution_stack : List String",
          "attributes": {
            "resolved": {
              "description": "Successfully resolved IDs",
              "items": {
                "type": "string"
              },
              "title": "Resolved",
              "type": "array",
              "uniqueItems": true
            },
            "failed": {
              "description": "Failed to resolve IDs",
              "items": {
                "type": "string"
              },
              "title": "Failed",
              "type": "array",
              "uniqueItems": true
            },
            "resolution_stack": {
              "description": "Current resolution stack (for cycle detection)",
              "items": {
                "type": "string"
              },
              "title": "Resolution Stack",
              "type": "array"
            }
          },
          "title": "ResolutionContext",
          "type": "object"
        },
        "fields": {
          "resolved": {
            "type": "typing.Set[str]",
            "required": false,
            "description": "Successfully resolved IDs",
            "default": "PydanticUndefined"
          },
          "failed": {
            "type": "typing.Set[str]",
            "required": false,
            "description": "Failed to resolve IDs",
            "default": "PydanticUndefined"
          },
          "resolution_stack": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Current resolution stack (for cycle detection)",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "resolved": [],
          "failed": [],
          "resolution_stack": []
        }
      },
      {
        "name": "ResolvedReference",
        "module": "mathster.registry.reference_system",
        "docstring": "Reference containing the full resolved object.\n\nUsed for computation after loading from storage.\n\nMaps to Lean:\n    structure ResolvedReference (T : Type) where\n      id : String\n      value : T",
        "json_schema": {
          "description": "Reference containing the full resolved object.\n\nUsed for computation after loading from storage.\n\nMaps to Lean:\n    structure ResolvedReference (T : Type) where\n      id : String\n      value : T",
          "attributes": {
            "id": {
              "description": "Object ID",
              "minLength": 1,
              "title": "Id",
              "type": "string"
            },
            "value": {
              "description": "The resolved object",
              "title": "Value"
            }
          },
          "required": [
            "id",
            "value"
          ],
          "title": "ResolvedReference",
          "type": "object"
        },
        "fields": {
          "id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Object ID",
            "default": "PydanticUndefined"
          },
          "value": {
            "type": "~T",
            "required": true,
            "description": "The resolved object",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "id": "example",
          "value": null
        }
      },
      {
        "name": "StorageConfig",
        "module": "mathster.registry.storage",
        "docstring": "Configuration for storage directory structure.\n\nMaps to Lean:\n    structure StorageConfig where\n      base_dir : String\n      use_references : Bool\n      pretty_print : Bool",
        "json_schema": {
          "description": "Configuration for storage directory structure.\n\nMaps to Lean:\n    structure StorageConfig where\n      base_dir : String\n      use_references : Bool\n      pretty_print : Bool",
          "attributes": {
            "base_dir": {
              "format": "path",
              "title": "Base Dir",
              "type": "string"
            },
            "use_references": {
              "default": false,
              "title": "Use References",
              "type": "boolean"
            },
            "pretty_print": {
              "default": true,
              "title": "Pretty Print",
              "type": "boolean"
            },
            "indent": {
              "default": 2,
              "title": "Indent",
              "type": "integer"
            }
          },
          "required": [
            "base_dir"
          ],
          "title": "StorageConfig",
          "type": "object"
        },
        "fields": {
          "base_dir": {
            "type": "<class 'pathlib.Path'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "use_references": {
            "type": "<class 'bool'>",
            "required": false,
            "description": "No description",
            "default": "False"
          },
          "pretty_print": {
            "type": "<class 'bool'>",
            "required": false,
            "description": "No description",
            "default": "True"
          },
          "indent": {
            "type": "<class 'int'>",
            "required": false,
            "description": "No description",
            "default": "2"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "TagQuery",
        "module": "mathster.registry.reference_system",
        "docstring": "Query specification for filtering objects by tags.\n\nSupports:\n- ANY: Match objects with ANY of the specified tags (OR)\n- ALL: Match objects with ALL of the specified tags (AND)\n- NONE: Match objects with NONE of the specified tags (NOT)\n\nMaps to Lean:\n    inductive TagQueryMode where\n      | any : TagQueryMode\n      | all : TagQueryMode\n      | none : TagQueryMode\n\n    structure TagQuery where\n      tags : List String\n      mode : TagQueryMode",
        "json_schema": {
          "description": "Query specification for filtering objects by tags.\n\nSupports:\n- ANY: Match objects with ANY of the specified tags (OR)\n- ALL: Match objects with ALL of the specified tags (AND)\n- NONE: Match objects with NONE of the specified tags (NOT)\n\nMaps to Lean:\n    inductive TagQueryMode where\n      | any : TagQueryMode\n      | all : TagQueryMode\n      | none : TagQueryMode\n\n    structure TagQuery where\n      tags : List String\n      mode : TagQueryMode",
          "attributes": {
            "tags": {
              "description": "Tags to query",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "title": "Tags",
              "type": "array"
            },
            "mode": {
              "default": "any",
              "description": "Query mode: any/all/none",
              "enum": [
                "any",
                "all",
                "none"
              ],
              "title": "Mode",
              "type": "string"
            }
          },
          "required": [
            "tags"
          ],
          "title": "TagQuery",
          "type": "object"
        },
        "fields": {
          "tags": {
            "type": "typing.List[str]",
            "required": true,
            "description": "Tags to query",
            "default": "PydanticUndefined"
          },
          "mode": {
            "type": "typing.Literal['any', 'all', 'none']",
            "required": false,
            "description": "Query mode: any/all/none",
            "default": "any"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "TheoremNode",
        "module": "mathster.relationships.graphs",
        "docstring": "Theorem node in framework flow graph.\n\nMaps to Lean:\n    structure TheoremNode where\n      theorem_id : String\n      input_objects : List String\n      output_objects : List String\n      relations_established : List String",
        "json_schema": {
          "description": "Theorem node in framework flow graph.\n\nMaps to Lean:\n    structure TheoremNode where\n      theorem_id : String\n      input_objects : List String\n      output_objects : List String\n      relations_established : List String",
          "attributes": {
            "theorem_id": {
              "description": "Theorem ID",
              "title": "Theorem Id",
              "type": "string"
            },
            "input_objects": {
              "description": "Input object IDs",
              "items": {
                "type": "string"
              },
              "title": "Input Objects",
              "type": "array"
            },
            "output_objects": {
              "description": "Output/derived object IDs",
              "items": {
                "type": "string"
              },
              "title": "Output Objects",
              "type": "array"
            },
            "relations_established": {
              "description": "Relationship IDs established",
              "items": {
                "type": "string"
              },
              "title": "Relations Established",
              "type": "array"
            }
          },
          "required": [
            "theorem_id"
          ],
          "title": "TheoremNode",
          "type": "object"
        },
        "fields": {
          "theorem_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Theorem ID",
            "default": "PydanticUndefined"
          },
          "input_objects": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Input object IDs",
            "default": "PydanticUndefined"
          },
          "output_objects": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Output/derived object IDs",
            "default": "PydanticUndefined"
          },
          "relations_established": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Relationship IDs established",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "theorem_id": "example",
          "input_objects": [],
          "output_objects": [],
          "relations_established": []
        }
      },
      {
        "name": "UnresolvedReference",
        "module": "mathster.registry.reference_system",
        "docstring": "Reference containing only an ID (not yet resolved).\n\nUsed for storage to avoid duplicating full objects in JSON.\n\nMaps to Lean:\n    structure UnresolvedReference (T : Type) where\n      id : String",
        "json_schema": {
          "description": "Reference containing only an ID (not yet resolved).\n\nUsed for storage to avoid duplicating full objects in JSON.\n\nMaps to Lean:\n    structure UnresolvedReference (T : Type) where\n      id : String",
          "attributes": {
            "id": {
              "description": "Object ID",
              "minLength": 1,
              "title": "Id",
              "type": "string"
            },
            "type_hint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Type hint for validation (e.g., 'MathematicalObject')",
              "title": "Type Hint"
            }
          },
          "required": [
            "id"
          ],
          "title": "UnresolvedReference",
          "type": "object"
        },
        "fields": {
          "id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Object ID",
            "default": "PydanticUndefined"
          },
          "type_hint": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "Type hint for validation (e.g., 'MathematicalObject')",
            "default": null
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "id": "example",
          "type_hint": null
        }
      }
    ],
    "level_1_basic": [
      {
        "name": "DirectDerivationWithSymPy",
        "module": "mathster.sympy.proof_integration",
        "docstring": "DirectDerivation extended with SymPy validation.\n\nThis is a non-invasive extension: if sympy_step is None,\nit behaves identically to DirectDerivation.\n\nMaps to Lean:\n    structure DirectDerivationWithSymPy extends DirectDerivation where\n      sympy_step : Option SymPyProofStep",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "DualExpr": {
              "additionalProperties": false,
              "description": "Dual representation: LaTeX (authoritative for display) + SymPy (authoritative for validation).\n\nMaps to Lean:\n    structure DualExpr where\n      latex : String\n      sympy : Option SymExpr\n      parse_status : ParseStatus\n\nParse Status:\n- 'ok': SymPy successfully represents this expression\n- 'unavailable': SymPy library not available\n- 'opaque': Expression uses domain-specific operators beyond SymPy\n- 'failed': LaTeX \u2192 SymPy parsing failed (with error message)",
              "attributes": {
                "latex": {
                  "description": "LaTeX representation (authoritative for display)",
                  "minLength": 1,
                  "title": "Latex",
                  "type": "string"
                },
                "sympy": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/SymExpr"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SymPy representation (authoritative for validation)"
                },
                "parse_status": {
                  "default": "ok",
                  "description": "Status of SymPy representation",
                  "enum": [
                    "ok",
                    "unavailable",
                    "opaque",
                    "failed"
                  ],
                  "title": "Parse Status",
                  "type": "string"
                },
                "parse_error": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Error message if parse_status='failed'",
                  "title": "Parse Error"
                }
              },
              "required": [
                "latex"
              ],
              "title": "DualExpr",
              "type": "object"
            },
            "DualStatement": {
              "additionalProperties": false,
              "description": "Mathematical statement with dual representation.\n\nExamples:\n- Equality: lhs = rhs\n- Inequality: lhs < rhs, lhs \u2264 rhs\n- Logical: A \u27f9 B, A \u27fa B\n\nMaps to Lean:\n    structure DualStatement where\n      lhs : DualExpr\n      relation : RelationSymbol\n      rhs : DualExpr\n      assumptions : AssumptionSet\n      context : Option String",
              "attributes": {
                "lhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Left-hand side expression"
                },
                "relation": {
                  "description": "Relation symbol",
                  "enum": [
                    "=",
                    "<",
                    "<=",
                    ">",
                    ">=",
                    "!=",
                    "\u27f9",
                    "\u27fa",
                    "\u2208",
                    "\u2286"
                  ],
                  "title": "Relation",
                  "type": "string"
                },
                "rhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Right-hand side expression"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Required assumptions for this statement"
                },
                "context": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional context (e.g., 'for all x > 0')",
                  "title": "Context"
                }
              },
              "required": [
                "lhs",
                "relation",
                "rhs"
              ],
              "title": "DualStatement",
              "type": "object"
            },
            "SymExpr": {
              "additionalProperties": false,
              "description": "Base class for all SymPy expressions.\n\nUses discriminated union pattern with 'type' field for JSON serialization\nand type safety.\n\nAll subclasses must:\n1. Set type: Literal['SpecificType'] as class attribute\n2. Implement to_sympy() -> sympy.Basic\n3. Be frozen (immutable)\n\nMaps to Lean:\n    inductive SymExpr where\n      | Symbol : String \u2192 AssumptionSet \u2192 SymExpr\n      | Integer : Int \u2192 SymExpr\n      | Add : List SymExpr \u2192 SymExpr\n      ...",
              "attributes": {
                "type": {
                  "description": "Discriminant for union type",
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "title": "SymExpr",
              "type": "object"
            },
            "SymPyProofStep": {
              "description": "SymPy-validated proof step with transformations.\n\nThis stores the SymPy validation of a proof step:\n- Assumptions used\n- Transformations applied\n- Validation result\n\nMaps to Lean:\n    structure SymPyProofStep where\n      input_statements : List DualStatement\n      output_statements : List DualStatement\n      transformations : List Transformation\n      validation_result : ValidationResult",
              "attributes": {
                "input_statements": {
                  "description": "Input attribute statements (from PropertyReferenceWithSymPy)",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Input Statements",
                  "type": "array"
                },
                "output_statements": {
                  "description": "Output attribute statements (to be established)",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Output Statements",
                  "type": "array"
                },
                "transformations": {
                  "description": "SymPy transformations applied in this step",
                  "items": {
                    "$ref": "#/$defs/Transformation"
                  },
                  "title": "Transformations",
                  "type": "array"
                },
                "validation_result": {
                  "$ref": "#/$defs/ValidationResult",
                  "description": "Result of SymPy validation for this step"
                }
              },
              "required": [
                "validation_result"
              ],
              "title": "SymPyProofStep",
              "type": "object"
            },
            "Transformation": {
              "description": "A SymPy transformation applied to an expression.\n\nMaps to Lean:\n    structure Transformation where\n      transformation_type : TransformationType\n      input : DualExpr\n      output : DualExpr\n      parameters : HashMap String String",
              "attributes": {
                "transformation_type": {
                  "$ref": "#/$defs/TransformationType",
                  "description": "Type of transformation"
                },
                "input_expr": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Input expression"
                },
                "output_expr": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Output expression"
                },
                "parameters": {
                  "additionalProperties": true,
                  "description": "Transformation parameters",
                  "title": "Parameters",
                  "type": "object"
                }
              },
              "required": [
                "transformation_type",
                "input_expr",
                "output_expr"
              ],
              "title": "Transformation",
              "type": "object"
            },
            "TransformationType": {
              "description": "Types of SymPy transformations.",
              "enum": [
                "simplify",
                "expand",
                "factor",
                "cancel",
                "collect",
                "differentiate",
                "integrate",
                "limit",
                "solve",
                "substitute",
                "rewrite",
                "trigsimp"
              ],
              "title": "TransformationType",
              "type": "string"
            },
            "ValidationIssue": {
              "description": "Describes a validation issue.\n\nMaps to Lean:\n    structure ValidationIssue where\n      severity : Severity\n      message : String\n      location : Option String\n      suggestion : Option String",
              "attributes": {
                "severity": {
                  "description": "Issue severity",
                  "enum": [
                    "error",
                    "warning",
                    "info"
                  ],
                  "title": "Severity",
                  "type": "string"
                },
                "message": {
                  "description": "Description of the issue",
                  "minLength": 1,
                  "title": "Message",
                  "type": "string"
                },
                "location": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Where the issue occurred (e.g., 'step 3', 'lhs')",
                  "title": "Location"
                },
                "suggestion": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Suggested fix",
                  "title": "Suggestion"
                }
              },
              "required": [
                "severity",
                "message"
              ],
              "title": "ValidationIssue",
              "type": "object"
            },
            "ValidationResult": {
              "description": "Result of validation attempt.\n\nMaps to Lean:\n    structure ValidationResult where\n      status : ValidationStatus\n      is_valid : Bool\n      can_validate : Bool\n      issues : List ValidationIssue\n      details : HashMap String String",
              "attributes": {
                "status": {
                  "$ref": "#/$defs/ValidationStatus",
                  "description": "Validation status"
                },
                "is_valid": {
                  "description": "True if validation passed (or uncertain)",
                  "title": "Is Valid",
                  "type": "boolean"
                },
                "can_validate": {
                  "description": "True if SymPy can attempt validation",
                  "title": "Can Validate",
                  "type": "boolean"
                },
                "issues": {
                  "description": "Validation issues",
                  "items": {
                    "$ref": "#/$defs/ValidationIssue"
                  },
                  "title": "Issues",
                  "type": "array"
                },
                "details": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "description": "Additional details",
                  "title": "Details",
                  "type": "object"
                }
              },
              "required": [
                "status",
                "is_valid",
                "can_validate"
              ],
              "title": "ValidationResult",
              "type": "object"
            },
            "ValidationStatus": {
              "description": "Status of validation attempt.",
              "enum": [
                "valid",
                "invalid",
                "uncertain",
                "unavailable",
                "opaque"
              ],
              "title": "ValidationStatus",
              "type": "string"
            }
          },
          "description": "DirectDerivation extended with SymPy validation.\n\nThis is a non-invasive extension: if sympy_step is None,\nit behaves identically to DirectDerivation.\n\nMaps to Lean:\n    structure DirectDerivationWithSymPy extends DirectDerivation where\n      sympy_step : Option SymPyProofStep",
          "attributes": {
            "mathematical_content": {
              "description": "Full mathematical derivation (LaTeX/markdown)",
              "title": "Mathematical Content",
              "type": "string"
            },
            "techniques": {
              "description": "Mathematical techniques used (e.g., 'cauchy-schwarz', 'integration-by-parts')",
              "items": {
                "type": "string"
              },
              "title": "Techniques",
              "type": "array"
            },
            "verification_status": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "LLM verification status",
              "title": "Verification Status"
            },
            "sympy_step": {
              "anyOf": [
                {
                  "$ref": "#/$defs/SymPyProofStep"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "SymPy validation of this derivation"
            }
          },
          "required": [
            "mathematical_content"
          ],
          "title": "DirectDerivationWithSymPy",
          "type": "object"
        },
        "fields": {
          "mathematical_content": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Full mathematical derivation (LaTeX/markdown)",
            "default": "PydanticUndefined"
          },
          "techniques": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Mathematical techniques used (e.g., 'cauchy-schwarz', 'integration-by-parts')",
            "default": "PydanticUndefined"
          },
          "verification_status": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "LLM verification status",
            "default": null
          },
          "sympy_step": {
            "type": "typing.Optional[mathster.sympy.proof_integration.SymPyProofStep]",
            "required": false,
            "description": "SymPy validation of this derivation",
            "default": null
          }
        },
        "dependencies": [
          "SymPyProofStep"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "mathematical_content": "example",
          "techniques": [],
          "verification_status": null,
          "sympy_step": null
        }
      },
      {
        "name": "LineagePath",
        "module": "mathster.relationships.graphs",
        "docstring": "Path through relationship graph showing object lineage.\n\nMaps to Lean:\n    structure LineagePath where\n      nodes : List String\n      edges : List GraphEdge\n      length : Nat",
        "json_schema": {
          "$defs": {
            "GraphEdge": {
              "description": "Edge in relationship graph.\n\nMaps to Lean:\n    structure GraphEdge where\n      source : String\n      target : String\n      relationship_id : String\n      relationship_type : RelationType\n      bidirectional : Bool",
              "attributes": {
                "source": {
                  "description": "Source object ID",
                  "title": "Source",
                  "type": "string"
                },
                "target": {
                  "description": "Target object ID",
                  "title": "Target",
                  "type": "string"
                },
                "relationship_id": {
                  "description": "Relationship ID",
                  "title": "Relationship Id",
                  "type": "string"
                },
                "relationship_type": {
                  "$ref": "#/$defs/RelationType",
                  "description": "Type of relationship"
                },
                "bidirectional": {
                  "description": "Whether edge is bidirectional",
                  "title": "Bidirectional",
                  "type": "boolean"
                }
              },
              "required": [
                "source",
                "target",
                "relationship_id",
                "relationship_type",
                "bidirectional"
              ],
              "title": "GraphEdge",
              "type": "object"
            },
            "RelationType": {
              "description": "Types of relationships between mathematical objects.\n\nMaps to Lean:\n    inductive RelationType where\n      | equivalence : RelationType\n      | embedding : RelationType\n      ...",
              "enum": [
                "equivalence",
                "embedding",
                "approximation",
                "reduction",
                "extension",
                "generalization",
                "specialization",
                "other"
              ],
              "title": "RelationType",
              "type": "string"
            }
          },
          "description": "Path through relationship graph showing object lineage.\n\nMaps to Lean:\n    structure LineagePath where\n      nodes : List String\n      edges : List GraphEdge\n      length : Nat",
          "attributes": {
            "nodes": {
              "description": "Node IDs in path",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "title": "Nodes",
              "type": "array"
            },
            "edges": {
              "description": "Edges in path",
              "items": {
                "$ref": "#/$defs/GraphEdge"
              },
              "title": "Edges",
              "type": "array"
            }
          },
          "required": [
            "nodes"
          ],
          "title": "LineagePath",
          "type": "object"
        },
        "fields": {
          "nodes": {
            "type": "typing.List[str]",
            "required": true,
            "description": "Node IDs in path",
            "default": "PydanticUndefined"
          },
          "edges": {
            "type": "typing.List[mathster.relationships.graphs.GraphEdge]",
            "required": false,
            "description": "Edges in path",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "GraphEdge"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "PipelineState",
        "module": "mathster.core.pipeline_types",
        "docstring": "State of the pipeline during or after execution.\n\nTracks:\n- Current state of all objects\n- Execution order\n- Blocked theorems (missing attributes)\n- Full execution trace\n\nMaps to Lean:\n    structure PipelineState where\n      objects : HashMap String MathematicalObject\n      executed_theorems : List String\n      blocked_theorems : List (String \u00d7 List String)\n      execution_trace : List ExecutionStep",
        "json_schema": {
          "$defs": {
            "MathematicalObject": {
              "description": "Mathematical object created by Definition directives.\n\nObjects accumulate attributes as they flow through theorems.\nOnly definitions create objects; theorems only add attributes.\n\nNote: current_properties is mutable (tracked externally in pipeline state).\nThis model is immutable (frozen), but we track mutations via model_copy.\n\nMaps to Lean:\n    structure MathematicalObject where\n      label : String\n      name : String\n      mathematical_expression : String\n      object_type : ObjectType",
              "attributes": {
                "label": {
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Label",
                  "type": "string"
                },
                "name": {
                  "minLength": 1,
                  "title": "Name",
                  "type": "string"
                },
                "mathematical_expression": {
                  "minLength": 1,
                  "title": "Mathematical Expression",
                  "type": "string"
                },
                "object_type": {
                  "$ref": "#/$defs/ObjectType"
                },
                "current_attributes": {
                  "items": {
                    "$ref": "#/$defs/Property"
                  },
                  "title": "Current Properties",
                  "type": "array"
                },
                "property_history": {
                  "items": {
                    "$ref": "#/$defs/PropertyEvent"
                  },
                  "title": "Property History",
                  "type": "array"
                },
                "tags": {
                  "description": "Category tags for filtering/searching (e.g., 'discrete', 'euclidean-gas', 'particle')",
                  "items": {
                    "type": "string"
                  },
                  "title": "Tags",
                  "type": "array"
                }
              },
              "required": [
                "label",
                "name",
                "mathematical_expression",
                "object_type"
              ],
              "title": "MathematicalObject",
              "type": "object"
            },
            "ObjectType": {
              "description": "Mathematical object categories.",
              "enum": [
                "set",
                "function",
                "measure",
                "space",
                "operator",
                "distribution",
                "field",
                "structure"
              ],
              "title": "ObjectType",
              "type": "string"
            },
            "Attribute": {
              "description": "Property assigned to a mathematical object by a theorem.\n\nConditionality is COMPUTED dynamically (not stored here).\nCheck theorem.properties_required vs object.current_properties.\n\nMaps to Lean:\n    structure Property where\n      label : String\n      expression : String\n      object_label : String\n      established_by : String\n      ...\n\n      def is_unconditional (p : Property) (conds : List String) : Bool :=\n        conds.isEmpty",
              "attributes": {
                "label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "LaTeX mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "object_label": {
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Object Label",
                  "type": "string"
                },
                "established_by": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step",
                  "title": "Timestamp"
                },
                "can_be_refined": {
                  "default": true,
                  "description": "Whether attribute can be strengthened",
                  "title": "Can Be Refined",
                  "type": "boolean"
                },
                "refinements": {
                  "items": {
                    "$ref": "#/$defs/PropertyRefinement"
                  },
                  "title": "Refinements",
                  "type": "array"
                }
              },
              "required": [
                "label",
                "expression",
                "object_label",
                "established_by"
              ],
              "title": "Attribute",
              "type": "object"
            },
            "AttributeEvent": {
              "description": "Event in attribute history timeline.",
              "attributes": {
                "timestamp": {
                  "minimum": 0,
                  "title": "Timestamp",
                  "type": "integer"
                },
                "property_label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Property Label",
                  "type": "string"
                },
                "added_by_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Added By Theorem",
                  "type": "string"
                },
                "event_type": {
                  "$ref": "#/$defs/PropertyEventType"
                }
              },
              "required": [
                "timestamp",
                "property_label",
                "added_by_theorem",
                "event_type"
              ],
              "title": "AttributeEvent",
              "type": "object"
            },
            "AttributeEventType": {
              "description": "Property timeline event types.",
              "enum": [
                "added",
                "refined",
                "conditional_upgrade"
              ],
              "title": "AttributeEventType",
              "type": "string"
            },
            "AttributeRefinement": {
              "description": "Tracks when a attribute is strengthened or generalized.\n\nExample: prop-continuous \u2192 prop-smooth (strengthening)\n\nMaps to Lean:\n    structure PropertyRefinement where\n      original_property : String\n      refined_property : String\n      ...",
              "attributes": {
                "original_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Original Property",
                  "type": "string"
                },
                "refined_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Refined Property",
                  "type": "string"
                },
                "refinement_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Refinement Theorem",
                  "type": "string"
                },
                "refinement_type": {
                  "$ref": "#/$defs/RefinementType"
                }
              },
              "required": [
                "original_property",
                "refined_property",
                "refinement_theorem",
                "refinement_type"
              ],
              "title": "AttributeRefinement",
              "type": "object"
            },
            "RefinementType": {
              "description": "Property refinement types.",
              "enum": [
                "strengthening",
                "generalization",
                "quantification"
              ],
              "title": "RefinementType",
              "type": "string"
            }
          },
          "description": "State of the pipeline during or after execution.\n\nTracks:\n- Current state of all objects\n- Execution order\n- Blocked theorems (missing attributes)\n- Full execution trace\n\nMaps to Lean:\n    structure PipelineState where\n      objects : HashMap String MathematicalObject\n      executed_theorems : List String\n      blocked_theorems : List (String \u00d7 List String)\n      execution_trace : List ExecutionStep",
          "attributes": {
            "objects": {
              "additionalProperties": {
                "$ref": "#/$defs/MathematicalObject"
              },
              "title": "Objects",
              "type": "object"
            },
            "executed_theorems": {
              "items": {
                "type": "string"
              },
              "title": "Executed Theorems",
              "type": "array"
            },
            "blocked_theorems": {
              "items": {
                "maxItems": 2,
                "minItems": 2,
                "prefixItems": [
                  {
                    "type": "string"
                  },
                  {
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  }
                ],
                "type": "array"
              },
              "title": "Blocked Theorems",
              "type": "array"
            },
            "execution_trace": {
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "title": "Execution Trace",
              "type": "array"
            }
          },
          "title": "PipelineState",
          "type": "object"
        },
        "fields": {
          "objects": {
            "type": "typing.Dict[str, mathster.core.pipeline_types.MathematicalObject]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "executed_theorems": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "blocked_theorems": {
            "type": "typing.List[typing.Tuple[str, typing.List[str]]]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "execution_trace": {
            "type": "typing.List[typing.Dict[str, object]]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "MathematicalObject"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "objects": {},
          "executed_theorems": [],
          "blocked_theorems": [],
          "execution_trace": []
        }
      },
      {
        "name": "ProofExpansionRequest",
        "module": "mathster.core.proof_system",
        "docstring": "Request to expand a sketched step.\n\nThis is what gets sent to the LLM for expansion.",
        "json_schema": {
          "$defs": {
            "AssumptionReference": {
              "description": "Reference to an assumption (attribute that may not be proven yet).\n\nAssumptions are attributes that we require but may not have proven.\nThey make the proof conditional.\n\nMaps to Lean:\n    structure AssumptionReference where\n      object_id : String\n      assumption_id : String\n      assumption_statement : String\n      justification : Option String",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "assumption_id": {
                  "description": "Assumption ID",
                  "title": "Assumption Id",
                  "type": "string"
                },
                "assumption_statement": {
                  "description": "Mathematical statement of assumption",
                  "title": "Assumption Statement",
                  "type": "string"
                },
                "justification": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Why this assumption is reasonable",
                  "title": "Justification"
                }
              },
              "required": [
                "object_id",
                "assumption_id",
                "assumption_statement"
              ],
              "title": "AssumptionReference",
              "type": "object"
            },
            "ProofInput": {
              "description": "Input specification for a proof: object + specific attributes needed.\n\nThis is like a function signature: we specify exactly what attributes\nof what objects we need as input.\n\nMaps to Lean:\n    structure ProofInput where\n      object_id : String\n      required_properties : List PropertyReference\n      required_assumptions : List AssumptionReference",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "required_properties": {
                  "description": "Proven attributes required",
                  "items": {
                    "$ref": "#/$defs/PropertyReference"
                  },
                  "title": "Required Properties",
                  "type": "array"
                },
                "required_assumptions": {
                  "description": "Assumptions required (make proof conditional)",
                  "items": {
                    "$ref": "#/$defs/AssumptionReference"
                  },
                  "title": "Required Assumptions",
                  "type": "array"
                }
              },
              "required": [
                "object_id"
              ],
              "title": "ProofInput",
              "type": "object"
            },
            "ProofOutput": {
              "description": "Output specification for a proof: object + attributes established.\n\nAfter the proof, these attributes are now available for the output object.\n\nMaps to Lean:\n    structure ProofOutput where\n      object_id : String\n      properties_established : List PropertyReference",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "properties_established": {
                  "description": "Properties proven to hold",
                  "items": {
                    "$ref": "#/$defs/PropertyReference"
                  },
                  "minItems": 1,
                  "title": "Properties Established",
                  "type": "array"
                }
              },
              "required": [
                "object_id",
                "properties_established"
              ],
              "title": "ProofOutput",
              "type": "object"
            },
            "AttributeReference": {
              "description": "Reference to a specific attribute of an object.\n\nThis is the fundamental unit of proof dataflow: we don't say\n\"I need object X\", we say \"I need attribute P of object X\".\n\nMaps to Lean:\n    structure PropertyReference where\n      object_id : String\n      property_id : String\n      property_statement : String",
              "attributes": {
                "object_id": {
                  "description": "Object ID (e.g., 'obj-discrete-system')",
                  "minLength": 1,
                  "title": "Object Id",
                  "type": "string"
                },
                "property_id": {
                  "description": "Property ID (e.g., 'prop-lipschitz-continuity')",
                  "minLength": 1,
                  "title": "Property Id",
                  "type": "string"
                },
                "property_statement": {
                  "description": "Mathematical statement of the attribute",
                  "title": "Property Statement",
                  "type": "string"
                }
              },
              "required": [
                "object_id",
                "property_id",
                "property_statement"
              ],
              "title": "AttributeReference",
              "type": "object"
            }
          },
          "description": "Request to expand a sketched step.\n\nThis is what gets sent to the LLM for expansion.",
          "attributes": {
            "proof_id": {
              "description": "Parent proof ID",
              "title": "Proof Id",
              "type": "string"
            },
            "step_id": {
              "description": "Step to expand",
              "title": "Step Id",
              "type": "string"
            },
            "step_description": {
              "description": "What the step should accomplish",
              "title": "Step Description",
              "type": "string"
            },
            "inputs": {
              "description": "Available inputs",
              "items": {
                "$ref": "#/$defs/ProofInput"
              },
              "title": "Inputs",
              "type": "array"
            },
            "outputs": {
              "description": "Required outputs",
              "items": {
                "$ref": "#/$defs/ProofOutput"
              },
              "title": "Outputs",
              "type": "array"
            },
            "context": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Additional context from proof strategy",
              "title": "Context"
            }
          },
          "required": [
            "proof_id",
            "step_id",
            "step_description",
            "inputs",
            "outputs"
          ],
          "title": "ProofExpansionRequest",
          "type": "object"
        },
        "fields": {
          "proof_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Parent proof ID",
            "default": "PydanticUndefined"
          },
          "step_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Step to expand",
            "default": "PydanticUndefined"
          },
          "step_description": {
            "type": "<class 'str'>",
            "required": true,
            "description": "What the step should accomplish",
            "default": "PydanticUndefined"
          },
          "inputs": {
            "type": "typing.List[mathster.core.proof_system.ProofInput]",
            "required": true,
            "description": "Available inputs",
            "default": "PydanticUndefined"
          },
          "outputs": {
            "type": "typing.List[mathster.core.proof_system.ProofOutput]",
            "required": true,
            "description": "Required outputs",
            "default": "PydanticUndefined"
          },
          "context": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "Additional context from proof strategy",
            "default": null
          }
        },
        "dependencies": [
          "ProofInput",
          "ProofOutput"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "proof_id": "example",
          "step_id": "example",
          "step_description": "example",
          "inputs": [],
          "outputs": [],
          "context": null
        }
      },
      {
        "name": "ProofValidationResult",
        "module": "mathster.core.proof_integration",
        "docstring": "Result of validating proof against theorem.\n\nMaps to Lean:\n    structure ProofValidationResult where\n      is_valid : Bool\n      mismatches : List ProofTheoremMismatch\n      warnings : List String",
        "json_schema": {
          "$defs": {
            "ProofTheoremMismatch": {
              "description": "Describes a mismatch between proof and theorem.\n\nMaps to Lean:\n    structure ProofTheoremMismatch where\n      mismatch_type : String\n      description : String\n      expected : String\n      actual : String",
              "attributes": {
                "mismatch_type": {
                  "description": "Type of mismatch (input/output/attribute)",
                  "title": "Mismatch Type",
                  "type": "string"
                },
                "description": {
                  "description": "Human-readable description",
                  "title": "Description",
                  "type": "string"
                },
                "expected": {
                  "description": "What the theorem expects",
                  "title": "Expected",
                  "type": "string"
                },
                "actual": {
                  "description": "What the proof provides",
                  "title": "Actual",
                  "type": "string"
                }
              },
              "required": [
                "mismatch_type",
                "description",
                "expected",
                "actual"
              ],
              "title": "ProofTheoremMismatch",
              "type": "object"
            }
          },
          "description": "Result of validating proof against theorem.\n\nMaps to Lean:\n    structure ProofValidationResult where\n      is_valid : Bool\n      mismatches : List ProofTheoremMismatch\n      warnings : List String",
          "attributes": {
            "is_valid": {
              "description": "Whether proof matches theorem",
              "title": "Is Valid",
              "type": "boolean"
            },
            "mismatches": {
              "description": "Validation errors",
              "items": {
                "$ref": "#/$defs/ProofTheoremMismatch"
              },
              "title": "Mismatches",
              "type": "array"
            },
            "warnings": {
              "description": "Non-blocking warnings",
              "items": {
                "type": "string"
              },
              "title": "Warnings",
              "type": "array"
            }
          },
          "required": [
            "is_valid"
          ],
          "title": "ProofValidationResult",
          "type": "object"
        },
        "fields": {
          "is_valid": {
            "type": "<class 'bool'>",
            "required": true,
            "description": "Whether proof matches theorem",
            "default": "PydanticUndefined"
          },
          "mismatches": {
            "type": "typing.List[mathster.core.proof_integration.ProofTheoremMismatch]",
            "required": false,
            "description": "Validation errors",
            "default": "PydanticUndefined"
          },
          "warnings": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Non-blocking warnings",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "ProofTheoremMismatch"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "is_valid": false,
          "mismatches": [],
          "warnings": []
        }
      },
      {
        "name": "PropertyReferenceWithSymPy",
        "module": "mathster.sympy.proof_integration",
        "docstring": "PropertyReference extended with SymPy dual representation.\n\nThis is a non-invasive extension: if dual_statement is None,\nit behaves identically to PropertyReference.\n\nMaps to Lean:\n    structure PropertyReferenceWithSymPy extends PropertyReference where\n      dual_statement : Option DualStatement",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "DualExpr": {
              "additionalProperties": false,
              "description": "Dual representation: LaTeX (authoritative for display) + SymPy (authoritative for validation).\n\nMaps to Lean:\n    structure DualExpr where\n      latex : String\n      sympy : Option SymExpr\n      parse_status : ParseStatus\n\nParse Status:\n- 'ok': SymPy successfully represents this expression\n- 'unavailable': SymPy library not available\n- 'opaque': Expression uses domain-specific operators beyond SymPy\n- 'failed': LaTeX \u2192 SymPy parsing failed (with error message)",
              "attributes": {
                "latex": {
                  "description": "LaTeX representation (authoritative for display)",
                  "minLength": 1,
                  "title": "Latex",
                  "type": "string"
                },
                "sympy": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/SymExpr"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SymPy representation (authoritative for validation)"
                },
                "parse_status": {
                  "default": "ok",
                  "description": "Status of SymPy representation",
                  "enum": [
                    "ok",
                    "unavailable",
                    "opaque",
                    "failed"
                  ],
                  "title": "Parse Status",
                  "type": "string"
                },
                "parse_error": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Error message if parse_status='failed'",
                  "title": "Parse Error"
                }
              },
              "required": [
                "latex"
              ],
              "title": "DualExpr",
              "type": "object"
            },
            "DualStatement": {
              "additionalProperties": false,
              "description": "Mathematical statement with dual representation.\n\nExamples:\n- Equality: lhs = rhs\n- Inequality: lhs < rhs, lhs \u2264 rhs\n- Logical: A \u27f9 B, A \u27fa B\n\nMaps to Lean:\n    structure DualStatement where\n      lhs : DualExpr\n      relation : RelationSymbol\n      rhs : DualExpr\n      assumptions : AssumptionSet\n      context : Option String",
              "attributes": {
                "lhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Left-hand side expression"
                },
                "relation": {
                  "description": "Relation symbol",
                  "enum": [
                    "=",
                    "<",
                    "<=",
                    ">",
                    ">=",
                    "!=",
                    "\u27f9",
                    "\u27fa",
                    "\u2208",
                    "\u2286"
                  ],
                  "title": "Relation",
                  "type": "string"
                },
                "rhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Right-hand side expression"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Required assumptions for this statement"
                },
                "context": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional context (e.g., 'for all x > 0')",
                  "title": "Context"
                }
              },
              "required": [
                "lhs",
                "relation",
                "rhs"
              ],
              "title": "DualStatement",
              "type": "object"
            },
            "SymExpr": {
              "additionalProperties": false,
              "description": "Base class for all SymPy expressions.\n\nUses discriminated union pattern with 'type' field for JSON serialization\nand type safety.\n\nAll subclasses must:\n1. Set type: Literal['SpecificType'] as class attribute\n2. Implement to_sympy() -> sympy.Basic\n3. Be frozen (immutable)\n\nMaps to Lean:\n    inductive SymExpr where\n      | Symbol : String \u2192 AssumptionSet \u2192 SymExpr\n      | Integer : Int \u2192 SymExpr\n      | Add : List SymExpr \u2192 SymExpr\n      ...",
              "attributes": {
                "type": {
                  "description": "Discriminant for union type",
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "title": "SymExpr",
              "type": "object"
            }
          },
          "description": "PropertyReference extended with SymPy dual representation.\n\nThis is a non-invasive extension: if dual_statement is None,\nit behaves identically to PropertyReference.\n\nMaps to Lean:\n    structure PropertyReferenceWithSymPy extends PropertyReference where\n      dual_statement : Option DualStatement",
          "attributes": {
            "object_id": {
              "description": "Object ID (e.g., 'obj-discrete-system')",
              "minLength": 1,
              "title": "Object Id",
              "type": "string"
            },
            "property_id": {
              "description": "Property ID (e.g., 'prop-lipschitz-continuity')",
              "minLength": 1,
              "title": "Property Id",
              "type": "string"
            },
            "property_statement": {
              "description": "Mathematical statement of the attribute",
              "title": "Property Statement",
              "type": "string"
            },
            "dual_statement": {
              "anyOf": [
                {
                  "$ref": "#/$defs/DualStatement"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Dual representation (LaTeX + SymPy) of the attribute statement"
            }
          },
          "required": [
            "object_id",
            "property_id",
            "property_statement"
          ],
          "title": "PropertyReferenceWithSymPy",
          "type": "object"
        },
        "fields": {
          "object_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Object ID (e.g., 'obj-discrete-system')",
            "default": "PydanticUndefined"
          },
          "property_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Property ID (e.g., 'prop-lipschitz-continuity')",
            "default": "PydanticUndefined"
          },
          "property_statement": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Mathematical statement of the attribute",
            "default": "PydanticUndefined"
          },
          "dual_statement": {
            "type": "typing.Optional[mathster.sympy.dual_representation.DualStatement]",
            "required": false,
            "description": "Dual representation (LaTeX + SymPy) of the attribute statement",
            "default": null
          }
        },
        "dependencies": [
          "DualStatement"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "object_id": "example",
          "property_id": "example",
          "property_statement": "example",
          "dual_statement": null
        }
      },
      {
        "name": "SymPyValidator",
        "module": "mathster.sympy.validation",
        "docstring": "Core validation engine using SymPy.\n\nMaps to Lean:\n    structure SymPyValidator where\n      context : SymPyContext\n      plugin_registry : PluginRegistry\n      strict_mode : Bool",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "DualExpr": {
              "additionalProperties": false,
              "description": "Dual representation: LaTeX (authoritative for display) + SymPy (authoritative for validation).\n\nMaps to Lean:\n    structure DualExpr where\n      latex : String\n      sympy : Option SymExpr\n      parse_status : ParseStatus\n\nParse Status:\n- 'ok': SymPy successfully represents this expression\n- 'unavailable': SymPy library not available\n- 'opaque': Expression uses domain-specific operators beyond SymPy\n- 'failed': LaTeX \u2192 SymPy parsing failed (with error message)",
              "attributes": {
                "latex": {
                  "description": "LaTeX representation (authoritative for display)",
                  "minLength": 1,
                  "title": "Latex",
                  "type": "string"
                },
                "sympy": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/SymExpr"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SymPy representation (authoritative for validation)"
                },
                "parse_status": {
                  "default": "ok",
                  "description": "Status of SymPy representation",
                  "enum": [
                    "ok",
                    "unavailable",
                    "opaque",
                    "failed"
                  ],
                  "title": "Parse Status",
                  "type": "string"
                },
                "parse_error": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Error message if parse_status='failed'",
                  "title": "Parse Error"
                }
              },
              "required": [
                "latex"
              ],
              "title": "DualExpr",
              "type": "object"
            },
            "DualStatement": {
              "additionalProperties": false,
              "description": "Mathematical statement with dual representation.\n\nExamples:\n- Equality: lhs = rhs\n- Inequality: lhs < rhs, lhs \u2264 rhs\n- Logical: A \u27f9 B, A \u27fa B\n\nMaps to Lean:\n    structure DualStatement where\n      lhs : DualExpr\n      relation : RelationSymbol\n      rhs : DualExpr\n      assumptions : AssumptionSet\n      context : Option String",
              "attributes": {
                "lhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Left-hand side expression"
                },
                "relation": {
                  "description": "Relation symbol",
                  "enum": [
                    "=",
                    "<",
                    "<=",
                    ">",
                    ">=",
                    "!=",
                    "\u27f9",
                    "\u27fa",
                    "\u2208",
                    "\u2286"
                  ],
                  "title": "Relation",
                  "type": "string"
                },
                "rhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Right-hand side expression"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Required assumptions for this statement"
                },
                "context": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional context (e.g., 'for all x > 0')",
                  "title": "Context"
                }
              },
              "required": [
                "lhs",
                "relation",
                "rhs"
              ],
              "title": "DualStatement",
              "type": "object"
            },
            "PluginRegistry": {
              "description": "Registry of validation plugins.",
              "attributes": {
                "plugins": {
                  "description": "Registered plugins (must match ValidationPlugin protocol)",
                  "items": {},
                  "title": "Plugins",
                  "type": "array"
                }
              },
              "title": "PluginRegistry",
              "type": "object"
            },
            "SymExpr": {
              "additionalProperties": false,
              "description": "Base class for all SymPy expressions.\n\nUses discriminated union pattern with 'type' field for JSON serialization\nand type safety.\n\nAll subclasses must:\n1. Set type: Literal['SpecificType'] as class attribute\n2. Implement to_sympy() -> sympy.Basic\n3. Be frozen (immutable)\n\nMaps to Lean:\n    inductive SymExpr where\n      | Symbol : String \u2192 AssumptionSet \u2192 SymExpr\n      | Integer : Int \u2192 SymExpr\n      | Add : List SymExpr \u2192 SymExpr\n      ...",
              "attributes": {
                "type": {
                  "description": "Discriminant for union type",
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "title": "SymExpr",
              "type": "object"
            },
            "SymPyContext": {
              "description": "Symbol table and assumption management for SymPy validation.\n\nThe context tracks:\n1. Symbol declarations (variables with their attributes)\n2. Global assumptions (facts that hold throughout a proof)\n3. Local assumptions (facts that hold in current scope)\n4. Parse cache (memoize LaTeX \u2192 SymPy conversions)\n\nMaps to Lean:\n    structure SymPyContext where\n      symbols : HashMap String SymbolDeclaration\n      global_assumptions : List DualStatement\n      local_assumptions : List DualStatement",
              "attributes": {
                "symbols": {
                  "additionalProperties": {
                    "$ref": "#/$defs/SymbolDeclaration"
                  },
                  "description": "Symbol table (name \u2192 declaration)",
                  "title": "Symbols",
                  "type": "object"
                },
                "global_assumptions": {
                  "description": "Global assumptions for entire proof",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Global Assumptions",
                  "type": "array"
                },
                "local_assumptions": {
                  "description": "Local assumptions for current scope",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Local Assumptions",
                  "type": "array"
                }
              },
              "title": "SymPyContext",
              "type": "object"
            },
            "SymbolDeclaration": {
              "description": "Declaration of a symbolic variable with its attributes.\n\nMaps to Lean:\n    structure SymbolDeclaration where\n      name : String\n      latex_name : String\n      assumptions : AssumptionSet\n      description : Option String",
              "attributes": {
                "name": {
                  "description": "SymPy variable name",
                  "minLength": 1,
                  "title": "Name",
                  "type": "string"
                },
                "latex_name": {
                  "description": "LaTeX representation",
                  "minLength": 1,
                  "title": "Latex Name",
                  "type": "string"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Assumptions about this symbol"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Human-readable description",
                  "title": "Description"
                }
              },
              "required": [
                "name",
                "latex_name"
              ],
              "title": "SymbolDeclaration",
              "type": "object"
            }
          },
          "description": "Core validation engine using SymPy.\n\nMaps to Lean:\n    structure SymPyValidator where\n      context : SymPyContext\n      plugin_registry : PluginRegistry\n      strict_mode : Bool",
          "attributes": {
            "context": {
              "$ref": "#/$defs/SymPyContext",
              "description": "Symbol table and assumptions"
            },
            "plugin_registry": {
              "$ref": "#/$defs/PluginRegistry",
              "description": "Domain-specific plugins"
            },
            "strict_mode": {
              "default": false,
              "description": "If True, require SymPy validation (no LLM fallback for uncertain cases)",
              "title": "Strict Mode",
              "type": "boolean"
            }
          },
          "title": "SymPyValidator",
          "type": "object"
        },
        "fields": {
          "context": {
            "type": "<class 'mathster.sympy.dual_representation.SymPyContext'>",
            "required": false,
            "description": "Symbol table and assumptions",
            "default": "PydanticUndefined"
          },
          "plugin_registry": {
            "type": "<class 'mathster.sympy.validation.PluginRegistry'>",
            "required": false,
            "description": "Domain-specific plugins",
            "default": "PydanticUndefined"
          },
          "strict_mode": {
            "type": "<class 'bool'>",
            "required": false,
            "description": "If True, require SymPy validation (no LLM fallback for uncertain cases)",
            "default": "False"
          }
        },
        "dependencies": [
          "PluginRegistry",
          "SymPyContext"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "context": {
            "symbols": {},
            "global_assumptions": [],
            "local_assumptions": []
          },
          "plugin_registry": {
            "plugins": []
          },
          "strict_mode": false
        }
      },
      {
        "name": "TheoremBox",
        "module": "mathster.core.pipeline_types",
        "docstring": "Theorem as processing box with well-defined I/O.\n\nInputs: objects, axioms, parameters\nProperties Required: API signature (attributes objects must have)\nInternal Processing: DAG of lemmas\nOutputs: attributes, relations, existence statements, etc.\n\nConditionality is COMPUTED by checking properties_required\nagainst each object's current_properties.\n\nMaps to Lean:\n    structure TheoremBox where\n      label : String\n      name : String\n      input_objects : List String\n      input_axioms : List String\n      input_parameters : List String\n      properties_required : HashMap String (List String)\n      ...\n\n      def compute_conditionality\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : List String := ...\n\n      def is_conditional\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : Bool :=\n        !(thm.compute_conditionality objects).isEmpty",
        "json_schema": {
          "$defs": {
            "Attribute": {
              "description": "Property assigned to a mathematical object by a theorem.\n\nConditionality is COMPUTED dynamically (not stored here).\nCheck theorem.properties_required vs object.current_properties.\n\nMaps to Lean:\n    structure Property where\n      label : String\n      expression : String\n      object_label : String\n      established_by : String\n      ...\n\n      def is_unconditional (p : Property) (conds : List String) : Bool :=\n        conds.isEmpty",
              "attributes": {
                "label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "LaTeX mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "object_label": {
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Object Label",
                  "type": "string"
                },
                "established_by": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step",
                  "title": "Timestamp"
                },
                "can_be_refined": {
                  "default": true,
                  "description": "Whether attribute can be strengthened",
                  "title": "Can Be Refined",
                  "type": "boolean"
                },
                "refinements": {
                  "items": {
                    "$ref": "#/$defs/PropertyRefinement"
                  },
                  "title": "Refinements",
                  "type": "array"
                }
              },
              "required": [
                "label",
                "expression",
                "object_label",
                "established_by"
              ],
              "title": "Attribute",
              "type": "object"
            },
            "AttributeRefinement": {
              "description": "Tracks when a attribute is strengthened or generalized.\n\nExample: prop-continuous \u2192 prop-smooth (strengthening)\n\nMaps to Lean:\n    structure PropertyRefinement where\n      original_property : String\n      refined_property : String\n      ...",
              "attributes": {
                "original_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Original Property",
                  "type": "string"
                },
                "refined_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Refined Property",
                  "type": "string"
                },
                "refinement_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Refinement Theorem",
                  "type": "string"
                },
                "refinement_type": {
                  "$ref": "#/$defs/RefinementType"
                }
              },
              "required": [
                "original_property",
                "refined_property",
                "refinement_theorem",
                "refinement_type"
              ],
              "title": "AttributeRefinement",
              "type": "object"
            },
            "RefinementType": {
              "description": "Property refinement types.",
              "enum": [
                "strengthening",
                "generalization",
                "quantification"
              ],
              "title": "RefinementType",
              "type": "string"
            },
            "RelationType": {
              "description": "Types of relationships between mathematical objects.\n\nMaps to Lean:\n    inductive RelationType where\n      | equivalence : RelationType\n      | embedding : RelationType\n      ...",
              "enum": [
                "equivalence",
                "embedding",
                "approximation",
                "reduction",
                "extension",
                "generalization",
                "specialization",
                "other"
              ],
              "title": "RelationType",
              "type": "string"
            },
            "Relationship": {
              "description": "Relationship between two mathematical objects established by a theorem.\n\nFirst-class object with label, type, directionality, and attributes.\n\nExamples:\n    - Equivalence: discrete \u2261 continuous (bidirectional)\n    - Embedding: particles \u21aa fluid (directed)\n    - Approximation: discrete \u2248 continuous with O(N^{-1/d}) (directed)\n    - Reduction: PDE \u2192 ODE (directed)\n\nMaps to Lean:\n    structure Relationship where\n      label : String\n      relationship_type : RelationType\n      source_object : String\n      target_object : String\n      bidirectional : Bool\n      established_by : String\n      attributes : List RelationshipProperty\n      expression : String\n\n      def is_symmetric (r : Relationship) : Bool :=\n        r.bidirectional\n\n      def is_directed (r : Relationship) : Bool :=\n        !r.bidirectional",
              "attributes": {
                "label": {
                  "description": "Relationship label (format: rel-{source}-{target}-{type})",
                  "pattern": "^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$",
                  "title": "Label",
                  "type": "string"
                },
                "relationship_type": {
                  "$ref": "#/$defs/RelationType"
                },
                "bidirectional": {
                  "description": "Whether relationship is symmetric (auto-computed from type if not provided)",
                  "title": "Bidirectional",
                  "type": "boolean"
                },
                "source_object": {
                  "description": "Source object label",
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Source Object",
                  "type": "string"
                },
                "target_object": {
                  "description": "Target object label",
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Target Object",
                  "type": "string"
                },
                "established_by": {
                  "description": "Theorem that established this relationship",
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "expression": {
                  "description": "Mathematical expression of relationship",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "attributes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/$defs/RelationshipProperty"
                  },
                  "description": "Relationship-specific attributes (e.g., error bounds, convergence rates)",
                  "title": "Properties"
                },
                "tags": {
                  "description": "Category tags (e.g., 'mean-field', 'discrete-continuous')",
                  "items": {
                    "type": "string"
                  },
                  "title": "Tags",
                  "type": "array"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step when established",
                  "title": "Timestamp"
                }
              },
              "required": [
                "label",
                "relationship_type",
                "bidirectional",
                "source_object",
                "target_object",
                "established_by",
                "expression"
              ],
              "title": "Relationship",
              "type": "object"
            },
            "RelationshipAttribute": {
              "description": "Property of a relationship (e.g., error bounds, convergence rates).\n\nExample: For an approximation relationship, might have error = O(N^{-1/d})\n\nMaps to Lean:\n    structure RelationshipProperty where\n      label : String\n      expression : String\n      description : String",
              "attributes": {
                "label": {
                  "description": "Property label (e.g., 'approx-error-N')",
                  "pattern": "^[a-z][a-zA-Z0-9-]*$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "Mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Description"
                }
              },
              "required": [
                "label",
                "expression"
              ],
              "title": "RelationshipAttribute",
              "type": "object"
            },
            "TheoremOutputType": {
              "description": "The 13 fundamental theorem output types providing complete coverage\nof mathematical reasoning.\n\nMaps to Lean:\n    inductive TheoremOutputType where\n      | attribute : TheoremOutputType\n      | relation : TheoremOutputType\n      ...",
              "enum": [
                "Attribute",
                "Relation",
                "Existence",
                "Construction",
                "Classification",
                "Uniqueness",
                "Impossibility",
                "Embedding",
                "Approximation",
                "Equivalence",
                "Decomposition",
                "Extension",
                "Reduction"
              ],
              "title": "TheoremOutputType",
              "type": "string"
            }
          },
          "description": "Theorem as processing box with well-defined I/O.\n\nInputs: objects, axioms, parameters\nProperties Required: API signature (attributes objects must have)\nInternal Processing: DAG of lemmas\nOutputs: attributes, relations, existence statements, etc.\n\nConditionality is COMPUTED by checking properties_required\nagainst each object's current_properties.\n\nMaps to Lean:\n    structure TheoremBox where\n      label : String\n      name : String\n      input_objects : List String\n      input_axioms : List String\n      input_parameters : List String\n      properties_required : HashMap String (List String)\n      ...\n\n      def compute_conditionality\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : List String := ...\n\n      def is_conditional\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : Bool :=\n        !(thm.compute_conditionality objects).isEmpty",
          "attributes": {
            "label": {
              "pattern": "^thm-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "name": {
              "minLength": 1,
              "title": "Name",
              "type": "string"
            },
            "input_objects": {
              "items": {
                "type": "string"
              },
              "title": "Input Objects",
              "type": "array"
            },
            "input_axioms": {
              "items": {
                "type": "string"
              },
              "title": "Input Axioms",
              "type": "array"
            },
            "input_parameters": {
              "items": {
                "type": "string"
              },
              "title": "Input Parameters",
              "type": "array"
            },
            "attributes_required": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "description": "API signature: {object_label: [required_properties]}",
              "title": "Properties Required",
              "type": "object"
            },
            "internal_lemmas": {
              "items": {
                "type": "string"
              },
              "title": "Internal Lemmas",
              "type": "array"
            },
            "internal_propositions": {
              "items": {
                "type": "string"
              },
              "title": "Internal Propositions",
              "type": "array"
            },
            "lemma_dag_edges": {
              "description": "DAG edges: (from, to)",
              "items": {
                "maxItems": 2,
                "minItems": 2,
                "prefixItems": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "type": "array"
              },
              "title": "Lemma Dag Edges",
              "type": "array"
            },
            "output_type": {
              "$ref": "#/$defs/TheoremOutputType"
            },
            "attributes_added": {
              "items": {
                "$ref": "#/$defs/Property"
              },
              "title": "Properties Added",
              "type": "array"
            },
            "relations_established": {
              "description": "Relationships between objects established by this theorem",
              "items": {
                "$ref": "#/$defs/Relationship"
              },
              "title": "Relations Established",
              "type": "array"
            }
          },
          "required": [
            "label",
            "name",
            "output_type"
          ],
          "title": "TheoremBox",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "name": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_objects": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_axioms": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_parameters": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "attributes_required": {
            "type": "typing.Dict[str, typing.List[str]]",
            "required": false,
            "description": "API signature: {object_label: [required_properties]}",
            "default": "PydanticUndefined"
          },
          "internal_lemmas": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "internal_propositions": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "lemma_dag_edges": {
            "type": "typing.List[typing.Tuple[str, str]]",
            "required": false,
            "description": "DAG edges: (from, to)",
            "default": "PydanticUndefined"
          },
          "output_type": {
            "type": "<enum 'TheoremOutputType'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "attributes_added": {
            "type": "typing.List[mathster.core.pipeline_types.Property]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "relations_established": {
            "type": "typing.List[mathster.core.pipeline_types.Relationship]",
            "required": false,
            "description": "Relationships between objects established by this theorem",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "Attribute",
          "Relationship"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      }
    ],
    "level_2_intermediate": [
      {
        "name": "MathematicalObjectWithSymPy",
        "module": "mathster.sympy.object_extensions",
        "docstring": "MathematicalObject extended with SymPy support.\n\nThis is a non-invasive extension that adds:\n- Symbol table for SymPy validation\n- Global assumptions for this object\n- Helper methods for context creation\n\nIf symbol_table is empty, behaves identically to MathematicalObject.\n\nMaps to Lean:\n    structure MathematicalObjectWithSymPy extends MathematicalObject where\n      symbol_table : HashMap String SymbolDeclaration\n      global_assumptions : AssumptionSet",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "ObjectType": {
              "description": "Mathematical object categories.",
              "enum": [
                "set",
                "function",
                "measure",
                "space",
                "operator",
                "distribution",
                "field",
                "structure"
              ],
              "title": "ObjectType",
              "type": "string"
            },
            "Attribute": {
              "description": "Property assigned to a mathematical object by a theorem.\n\nConditionality is COMPUTED dynamically (not stored here).\nCheck theorem.properties_required vs object.current_properties.\n\nMaps to Lean:\n    structure Property where\n      label : String\n      expression : String\n      object_label : String\n      established_by : String\n      ...\n\n      def is_unconditional (p : Property) (conds : List String) : Bool :=\n        conds.isEmpty",
              "attributes": {
                "label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "LaTeX mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "object_label": {
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Object Label",
                  "type": "string"
                },
                "established_by": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step",
                  "title": "Timestamp"
                },
                "can_be_refined": {
                  "default": true,
                  "description": "Whether attribute can be strengthened",
                  "title": "Can Be Refined",
                  "type": "boolean"
                },
                "refinements": {
                  "items": {
                    "$ref": "#/$defs/PropertyRefinement"
                  },
                  "title": "Refinements",
                  "type": "array"
                }
              },
              "required": [
                "label",
                "expression",
                "object_label",
                "established_by"
              ],
              "title": "Attribute",
              "type": "object"
            },
            "AttributeEvent": {
              "description": "Event in attribute history timeline.",
              "attributes": {
                "timestamp": {
                  "minimum": 0,
                  "title": "Timestamp",
                  "type": "integer"
                },
                "property_label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Property Label",
                  "type": "string"
                },
                "added_by_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Added By Theorem",
                  "type": "string"
                },
                "event_type": {
                  "$ref": "#/$defs/PropertyEventType"
                }
              },
              "required": [
                "timestamp",
                "property_label",
                "added_by_theorem",
                "event_type"
              ],
              "title": "AttributeEvent",
              "type": "object"
            },
            "AttributeEventType": {
              "description": "Property timeline event types.",
              "enum": [
                "added",
                "refined",
                "conditional_upgrade"
              ],
              "title": "AttributeEventType",
              "type": "string"
            },
            "AttributeRefinement": {
              "description": "Tracks when a attribute is strengthened or generalized.\n\nExample: prop-continuous \u2192 prop-smooth (strengthening)\n\nMaps to Lean:\n    structure PropertyRefinement where\n      original_property : String\n      refined_property : String\n      ...",
              "attributes": {
                "original_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Original Property",
                  "type": "string"
                },
                "refined_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Refined Property",
                  "type": "string"
                },
                "refinement_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Refinement Theorem",
                  "type": "string"
                },
                "refinement_type": {
                  "$ref": "#/$defs/RefinementType"
                }
              },
              "required": [
                "original_property",
                "refined_property",
                "refinement_theorem",
                "refinement_type"
              ],
              "title": "AttributeRefinement",
              "type": "object"
            },
            "RefinementType": {
              "description": "Property refinement types.",
              "enum": [
                "strengthening",
                "generalization",
                "quantification"
              ],
              "title": "RefinementType",
              "type": "string"
            },
            "SymbolDeclaration": {
              "description": "Declaration of a symbolic variable with its attributes.\n\nMaps to Lean:\n    structure SymbolDeclaration where\n      name : String\n      latex_name : String\n      assumptions : AssumptionSet\n      description : Option String",
              "attributes": {
                "name": {
                  "description": "SymPy variable name",
                  "minLength": 1,
                  "title": "Name",
                  "type": "string"
                },
                "latex_name": {
                  "description": "LaTeX representation",
                  "minLength": 1,
                  "title": "Latex Name",
                  "type": "string"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Assumptions about this symbol"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Human-readable description",
                  "title": "Description"
                }
              },
              "required": [
                "name",
                "latex_name"
              ],
              "title": "SymbolDeclaration",
              "type": "object"
            }
          },
          "description": "MathematicalObject extended with SymPy support.\n\nThis is a non-invasive extension that adds:\n- Symbol table for SymPy validation\n- Global assumptions for this object\n- Helper methods for context creation\n\nIf symbol_table is empty, behaves identically to MathematicalObject.\n\nMaps to Lean:\n    structure MathematicalObjectWithSymPy extends MathematicalObject where\n      symbol_table : HashMap String SymbolDeclaration\n      global_assumptions : AssumptionSet",
          "attributes": {
            "label": {
              "pattern": "^obj-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "name": {
              "minLength": 1,
              "title": "Name",
              "type": "string"
            },
            "mathematical_expression": {
              "minLength": 1,
              "title": "Mathematical Expression",
              "type": "string"
            },
            "object_type": {
              "$ref": "#/$defs/ObjectType"
            },
            "current_attributes": {
              "items": {
                "$ref": "#/$defs/Property"
              },
              "title": "Current Properties",
              "type": "array"
            },
            "property_history": {
              "items": {
                "$ref": "#/$defs/PropertyEvent"
              },
              "title": "Property History",
              "type": "array"
            },
            "tags": {
              "description": "Category tags for filtering/searching (e.g., 'discrete', 'euclidean-gas', 'particle')",
              "items": {
                "type": "string"
              },
              "title": "Tags",
              "type": "array"
            },
            "symbol_table": {
              "additionalProperties": {
                "$ref": "#/$defs/SymbolDeclaration"
              },
              "description": "Symbol declarations for SymPy validation",
              "title": "Symbol Table",
              "type": "object"
            },
            "global_assumptions": {
              "$ref": "#/$defs/AssumptionSet",
              "description": "Global assumptions that hold for this object"
            }
          },
          "required": [
            "label",
            "name",
            "mathematical_expression",
            "object_type"
          ],
          "title": "MathematicalObjectWithSymPy",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "name": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "mathematical_expression": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "object_type": {
            "type": "<enum 'ObjectType'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "current_attributes": {
            "type": "typing.List[mathster.core.pipeline_types.Property]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "property_history": {
            "type": "typing.List[mathster.core.pipeline_types.PropertyEvent]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "tags": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Category tags for filtering/searching (e.g., 'discrete', 'euclidean-gas', 'particle')",
            "default": "PydanticUndefined"
          },
          "symbol_table": {
            "type": "typing.Dict[str, mathster.sympy.dual_representation.SymbolDeclaration]",
            "required": false,
            "description": "Symbol declarations for SymPy validation",
            "default": "PydanticUndefined"
          },
          "global_assumptions": {
            "type": "<class 'mathster.sympy.expressions.AssumptionSet'>",
            "required": false,
            "description": "Global assumptions that hold for this object",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "AssumptionSet",
          "Attribute",
          "AttributeEvent",
          "SymbolDeclaration"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      },
      {
        "name": "PropertyWithSymPy",
        "module": "mathster.sympy.object_extensions",
        "docstring": "Property extended with SymPy dual representation.\n\nThis is a non-invasive extension: if dual_expression is None,\nit behaves identically to Property.\n\nMaps to Lean:\n    structure PropertyWithSymPy extends Property where\n      dual_expression : Option DualExpr\n      assumption_set : AssumptionSet",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "DualExpr": {
              "additionalProperties": false,
              "description": "Dual representation: LaTeX (authoritative for display) + SymPy (authoritative for validation).\n\nMaps to Lean:\n    structure DualExpr where\n      latex : String\n      sympy : Option SymExpr\n      parse_status : ParseStatus\n\nParse Status:\n- 'ok': SymPy successfully represents this expression\n- 'unavailable': SymPy library not available\n- 'opaque': Expression uses domain-specific operators beyond SymPy\n- 'failed': LaTeX \u2192 SymPy parsing failed (with error message)",
              "attributes": {
                "latex": {
                  "description": "LaTeX representation (authoritative for display)",
                  "minLength": 1,
                  "title": "Latex",
                  "type": "string"
                },
                "sympy": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/SymExpr"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SymPy representation (authoritative for validation)"
                },
                "parse_status": {
                  "default": "ok",
                  "description": "Status of SymPy representation",
                  "enum": [
                    "ok",
                    "unavailable",
                    "opaque",
                    "failed"
                  ],
                  "title": "Parse Status",
                  "type": "string"
                },
                "parse_error": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Error message if parse_status='failed'",
                  "title": "Parse Error"
                }
              },
              "required": [
                "latex"
              ],
              "title": "DualExpr",
              "type": "object"
            },
            "AttributeRefinement": {
              "description": "Tracks when a attribute is strengthened or generalized.\n\nExample: prop-continuous \u2192 prop-smooth (strengthening)\n\nMaps to Lean:\n    structure PropertyRefinement where\n      original_property : String\n      refined_property : String\n      ...",
              "attributes": {
                "original_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Original Property",
                  "type": "string"
                },
                "refined_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Refined Property",
                  "type": "string"
                },
                "refinement_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Refinement Theorem",
                  "type": "string"
                },
                "refinement_type": {
                  "$ref": "#/$defs/RefinementType"
                }
              },
              "required": [
                "original_property",
                "refined_property",
                "refinement_theorem",
                "refinement_type"
              ],
              "title": "AttributeRefinement",
              "type": "object"
            },
            "RefinementType": {
              "description": "Property refinement types.",
              "enum": [
                "strengthening",
                "generalization",
                "quantification"
              ],
              "title": "RefinementType",
              "type": "string"
            },
            "SymExpr": {
              "additionalProperties": false,
              "description": "Base class for all SymPy expressions.\n\nUses discriminated union pattern with 'type' field for JSON serialization\nand type safety.\n\nAll subclasses must:\n1. Set type: Literal['SpecificType'] as class attribute\n2. Implement to_sympy() -> sympy.Basic\n3. Be frozen (immutable)\n\nMaps to Lean:\n    inductive SymExpr where\n      | Symbol : String \u2192 AssumptionSet \u2192 SymExpr\n      | Integer : Int \u2192 SymExpr\n      | Add : List SymExpr \u2192 SymExpr\n      ...",
              "attributes": {
                "type": {
                  "description": "Discriminant for union type",
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "title": "SymExpr",
              "type": "object"
            }
          },
          "description": "Property extended with SymPy dual representation.\n\nThis is a non-invasive extension: if dual_expression is None,\nit behaves identically to Property.\n\nMaps to Lean:\n    structure PropertyWithSymPy extends Property where\n      dual_expression : Option DualExpr\n      assumption_set : AssumptionSet",
          "attributes": {
            "label": {
              "pattern": "^prop-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "expression": {
              "description": "LaTeX mathematical expression",
              "minLength": 1,
              "title": "Expression",
              "type": "string"
            },
            "object_label": {
              "pattern": "^obj-[a-z0-9-]+$",
              "title": "Object Label",
              "type": "string"
            },
            "established_by": {
              "pattern": "^thm-[a-z0-9-]+$",
              "title": "Established By",
              "type": "string"
            },
            "timestamp": {
              "anyOf": [
                {
                  "minimum": 0,
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Pipeline execution step",
              "title": "Timestamp"
            },
            "can_be_refined": {
              "default": true,
              "description": "Whether attribute can be strengthened",
              "title": "Can Be Refined",
              "type": "boolean"
            },
            "refinements": {
              "items": {
                "$ref": "#/$defs/PropertyRefinement"
              },
              "title": "Refinements",
              "type": "array"
            },
            "dual_expression": {
              "anyOf": [
                {
                  "$ref": "#/$defs/DualExpr"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Dual representation (LaTeX + SymPy) of the attribute expression"
            },
            "assumption_set": {
              "$ref": "#/$defs/AssumptionSet",
              "description": "SymPy-compatible assumptions about this attribute"
            }
          },
          "required": [
            "label",
            "expression",
            "object_label",
            "established_by"
          ],
          "title": "PropertyWithSymPy",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "expression": {
            "type": "<class 'str'>",
            "required": true,
            "description": "LaTeX mathematical expression",
            "default": "PydanticUndefined"
          },
          "object_label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "established_by": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "timestamp": {
            "type": "typing.Optional[int]",
            "required": false,
            "description": "Pipeline execution step",
            "default": null
          },
          "can_be_refined": {
            "type": "<class 'bool'>",
            "required": false,
            "description": "Whether attribute can be strengthened",
            "default": "True"
          },
          "refinements": {
            "type": "typing.List[mathster.core.pipeline_types.PropertyRefinement]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "dual_expression": {
            "type": "typing.Optional[mathster.sympy.dual_representation.DualExpr]",
            "required": false,
            "description": "Dual representation (LaTeX + SymPy) of the attribute expression",
            "default": null
          },
          "assumption_set": {
            "type": "<class 'mathster.sympy.expressions.AssumptionSet'>",
            "required": false,
            "description": "SymPy-compatible assumptions about this attribute",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "AssumptionSet",
          "DualExpr",
          "AttributeRefinement"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      }
    ]
  },
  "dependency_graph": {
    "Axiom": [],
    "DataFlowEdge": [],
    "DataFlowNode": [],
    "DependencyEdge": [],
    "DependencyNode": [],
    "Err": [],
    "MathematicalObject": [
      "Attribute",
      "AttributeEvent"
    ],
    "Ok": [],
    "Parameter": [],
    "PipelineState": [
      "MathematicalObject"
    ],
    "Attribute": [
      "AttributeRefinement"
    ],
    "AttributeEvent": [],
    "AttributeRefinement": [],
    "Relationship": [
      "RelationshipAttribute"
    ],
    "RelationshipAttribute": [],
    "TheoremBox": [
      "Attribute",
      "Relationship"
    ],
    "AssumptionReference": [],
    "DirectDerivation": [],
    "LemmaApplication": [],
    "ProofBox": [
      "ProofBox",
      "ProofInput",
      "ProofOutput",
      "ProofStep"
    ],
    "ProofExpansionRequest": [
      "ProofInput",
      "ProofOutput"
    ],
    "ProofInput": [
      "AssumptionReference",
      "AttributeReference"
    ],
    "ProofOutput": [
      "AttributeReference"
    ],
    "ProofStep": [
      "DirectDerivation",
      "LemmaApplication",
      "ProofInput",
      "ProofOutput",
      "SubProofReference"
    ],
    "AttributeReference": [],
    "SubProofReference": [],
    "ProofTheoremMismatch": [],
    "ProofValidationResult": [
      "ProofTheoremMismatch"
    ],
    "AddExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "AssumptionSet": [],
    "BooleanExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "DerivativeExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "EqExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "FloatExpr": [],
    "FuncExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "IneqExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "IntegerExpr": [],
    "IntegralExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "LimitExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "MatrixSymbolExpr": [
      "AssumptionSet"
    ],
    "MulExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "OpExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "PiecewiseExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "PowExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "ProductExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "RationalExpr": [],
    "SumExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FloatExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegerExpr",
      "IntegralExpr",
      "LimitExpr",
      "MatrixSymbolExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "RationalExpr",
      "SumExpr",
      "SymbolExpr"
    ],
    "SymExpr": [],
    "SymbolExpr": [
      "AssumptionSet"
    ],
    "DualExpr": [
      "SymExpr"
    ],
    "DualStatement": [
      "AssumptionSet",
      "DualExpr"
    ],
    "SymPyContext": [
      "DualStatement",
      "SymbolDeclaration"
    ],
    "SymbolDeclaration": [
      "AssumptionSet"
    ],
    "PluginRegistry": [],
    "SymPyValidator": [
      "PluginRegistry",
      "SymPyContext"
    ],
    "Transformation": [
      "DualExpr"
    ],
    "ValidationIssue": [],
    "ValidationResult": [
      "ValidationIssue"
    ],
    "DirectDerivationWithSymPy": [
      "SymPyProofStep"
    ],
    "PropertyReferenceWithSymPy": [
      "DualStatement"
    ],
    "SymPyProofStep": [
      "DualStatement",
      "Transformation",
      "ValidationResult"
    ],
    "MathematicalObjectWithSymPy": [
      "AssumptionSet",
      "Attribute",
      "AttributeEvent",
      "SymbolDeclaration"
    ],
    "PropertyWithSymPy": [
      "AssumptionSet",
      "DualExpr",
      "AttributeRefinement"
    ],
    "CombinedTagQuery": [],
    "QueryResult": [],
    "ResolutionContext": [],
    "ResolvedReference": [],
    "TagQuery": [],
    "UnresolvedReference": [],
    "RegistryIndex": [],
    "StorageConfig": [],
    "EquivalenceClass": [],
    "GraphEdge": [],
    "GraphNode": [],
    "LineagePath": [
      "GraphEdge"
    ],
    "TheoremNode": []
  },
  "inverse_dependency_graph": {
    "Axiom": [],
    "DataFlowEdge": [],
    "DataFlowNode": [],
    "DependencyEdge": [],
    "DependencyNode": [],
    "Err": [],
    "MathematicalObject": [
      "PipelineState"
    ],
    "Ok": [],
    "Parameter": [],
    "PipelineState": [],
    "Attribute": [
      "MathematicalObject",
      "MathematicalObjectWithSymPy",
      "TheoremBox"
    ],
    "AttributeEvent": [
      "MathematicalObject",
      "MathematicalObjectWithSymPy"
    ],
    "AttributeRefinement": [
      "Attribute",
      "PropertyWithSymPy"
    ],
    "Relationship": [
      "TheoremBox"
    ],
    "RelationshipAttribute": [
      "Relationship"
    ],
    "TheoremBox": [],
    "AssumptionReference": [
      "ProofInput"
    ],
    "DirectDerivation": [
      "ProofStep"
    ],
    "LemmaApplication": [
      "ProofStep"
    ],
    "ProofBox": [
      "ProofBox"
    ],
    "ProofExpansionRequest": [],
    "ProofInput": [
      "ProofBox",
      "ProofExpansionRequest",
      "ProofStep"
    ],
    "ProofOutput": [
      "ProofBox",
      "ProofExpansionRequest",
      "ProofStep"
    ],
    "ProofStep": [
      "ProofBox"
    ],
    "AttributeReference": [
      "ProofInput",
      "ProofOutput"
    ],
    "SubProofReference": [
      "ProofStep"
    ],
    "ProofTheoremMismatch": [
      "ProofValidationResult"
    ],
    "ProofValidationResult": [],
    "AddExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "AssumptionSet": [
      "DualStatement",
      "MathematicalObjectWithSymPy",
      "MatrixSymbolExpr",
      "PropertyWithSymPy",
      "SymbolDeclaration",
      "SymbolExpr"
    ],
    "BooleanExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "DerivativeExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "EqExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "FloatExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "FuncExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "IneqExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "IntegerExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "IntegralExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "LimitExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "MatrixSymbolExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "MulExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "OpExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "PiecewiseExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "PowExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "ProductExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "RationalExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "SumExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "SymExpr": [
      "DualExpr"
    ],
    "SymbolExpr": [
      "AddExpr",
      "BooleanExpr",
      "DerivativeExpr",
      "EqExpr",
      "FuncExpr",
      "IneqExpr",
      "IntegralExpr",
      "LimitExpr",
      "MulExpr",
      "OpExpr",
      "PiecewiseExpr",
      "PowExpr",
      "ProductExpr",
      "SumExpr"
    ],
    "DualExpr": [
      "DualStatement",
      "PropertyWithSymPy",
      "Transformation"
    ],
    "DualStatement": [
      "PropertyReferenceWithSymPy",
      "SymPyContext",
      "SymPyProofStep"
    ],
    "SymPyContext": [
      "SymPyValidator"
    ],
    "SymbolDeclaration": [
      "MathematicalObjectWithSymPy",
      "SymPyContext"
    ],
    "PluginRegistry": [
      "SymPyValidator"
    ],
    "SymPyValidator": [],
    "Transformation": [
      "SymPyProofStep"
    ],
    "ValidationIssue": [
      "ValidationResult"
    ],
    "ValidationResult": [
      "SymPyProofStep"
    ],
    "DirectDerivationWithSymPy": [],
    "PropertyReferenceWithSymPy": [],
    "SymPyProofStep": [
      "DirectDerivationWithSymPy"
    ],
    "MathematicalObjectWithSymPy": [],
    "PropertyWithSymPy": [],
    "CombinedTagQuery": [],
    "QueryResult": [],
    "ResolutionContext": [],
    "ResolvedReference": [],
    "TagQuery": [],
    "UnresolvedReference": [],
    "RegistryIndex": [],
    "StorageConfig": [],
    "EquivalenceClass": [],
    "GraphEdge": [
      "LineagePath"
    ],
    "GraphNode": [],
    "LineagePath": [],
    "TheoremNode": []
  },
  "common_workflows": {
    "create_simple_theorem": {
      "description": "Create a basic theorem with one input object, one output attribute",
      "code_example": "See examples/complete_integration_example.py lines 100-150",
      "schema_refs": [
        "TheoremBox",
        "MathematicalObject",
        "Attribute"
      ]
    },
    "create_compositional_proof": {
      "description": "Multi-step proof with sub-proofs and attribute-level dataflow",
      "code_example": "See examples/proof_system_example.py - complete hierarchical proof structure",
      "schema_refs": [
        "ProofBox",
        "ProofStep",
        "DirectDerivation",
        "SubProofReference",
        "ProofInput",
        "ProofOutput"
      ]
    },
    "validate_and_submit": {
      "description": "Validate proof against theorem, submit for dual review, implement fixes",
      "workflow": [
        "1. result = validate_proof_for_theorem(proof, theorem)",
        "2. If result.is_valid: proceed, else fix issues first",
        "3. mcp__gemini-cli__ask-gemini(prompt='Review proof...', model='gemini-2.5-pro')",
        "4. mcp__codex__codex(prompt='<identical prompt>', ...)",
        "5. Compare reviews: consensus (high conf), discrepancies (verify), unique (medium conf)",
        "6. Cross-check suggestions against docs/glossary.md before implementing",
        "7. If disagreeing with reviewers, document reasoning and inform user"
      ]
    }
  },
  "validation_rules": {
    "id_conventions": {
      "objects": "obj-{kebab-case} (e.g., obj-euclidean-gas-discrete)",
      "theorems": "thm-{kebab-case} (e.g., thm-mean-field-limit)",
      "proofs": "proof-{theorem-label} (e.g., proof-thm-mean-field-limit)",
      "relationships": "rel-{source}-{target}-{type} (e.g., rel-discrete-continuous-equivalence)",
      "attributes": "prop-{kebab-case} (e.g., prop-lipschitz-potential)"
    },
    "referential_integrity": "All referenced IDs (in relationships, theorems, proofs) must exist in MathematicalRegistry. Use registry.validate_referential_integrity() to check.",
    "property_granularity": "ProofInputs/ProofOutputs use PropertyReference to specify exact attributes needed from objects, enabling fine-grained dataflow validation.",
    "dataflow_validation": "proof.validate_dataflow() checks that all step inputs are satisfied by previous step outputs or proof-level inputs. Must return empty list."
  },
  "documentation_index": {
    "glossary": "docs/glossary.md (683 mathematical entries across Euclidean Gas and Geometric Gas chapters)",
    "claude_guide": "CLAUDE.md \u00a7 Mathematical Proofing and Documentation (includes dual review protocol)",
    "examples": "examples/README.md (9 comprehensive examples with 400+ lines of documentation)",
    "lean_guide": "docs/LEAN_EMULATION_GUIDE.md (Lean-compatible design patterns)",
    "framework_docs": [
      "docs/source/1_euclidean_gas/ - Euclidean Gas framework (12 documents)",
      "docs/source/2_geometric_gas/ - Geometric Gas framework (advanced topics)"
    ]
  }
}
