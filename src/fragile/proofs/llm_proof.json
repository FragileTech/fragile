{
  "metadata": {
    "generated_at": "2025-10-26T00:53:13.785448",
    "version": "2.0.0",
    "purpose": "LLM reference for writing rigorous mathematical proofs",
    "task_focus": "rigorous_proofs",
    "quality_standard": "Top-tier journal (Annals of Mathematics, JAMS)",
    "total_schemas": 7,
    "excluded_from_full": 69
  },
  "task_guide": {
    "objective": "Create rigorous, publishable mathematical proofs with full validation",
    "when_to_use": "When writing complete, peer-review-ready proofs with full mathematical derivations",
    "quality_standard": "Every claim must be proven. Every step must be justified. SymPy validation where possible.",
    "review_process": "MANDATORY dual review by Gemini 2.5 Pro + Codex before acceptance",
    "key_difference_from_sketches": "Includes full SymPy validation system for mathematical correctness checking"
  },
  "workflow": {
    "steps": [
      "1. Understand theorem: Read TheoremBox to see what attributes are required and what we establish",
      "2. Plan proof strategy: Outline high-level approach (3-5 key steps)",
      "3. Create ProofBox: Define attribute-level ProofInputs (exact attributes needed, not whole objects)",
      "4. Write each ProofStep sequentially:",
      "   - DirectDerivation: MUST include full mathematical content in `mathematical_content` field",
      "   - Use DualExpr for LaTeX + SymPy dual representation where possible",
      "   - Apply Transformations step-by-step to show mathematical reasoning",
      "   - Reference specific attributes using PropertyReference (not object IDs)",
      "5. Validate dataflow: proof.validate_dataflow() must return empty list",
      "6. Validate against theorem: validate_proof_for_theorem(proof, theorem)",
      "7. SymPy validation: Use SymPyValidator for mathematical correctness where applicable",
      "8. Dual review (MANDATORY):",
      "   - Submit to Gemini 2.5 Pro: mcp__gemini-cli__ask-gemini(model='gemini-2.5-pro')",
      "   - Submit to Codex: mcp__codex__codex (use IDENTICAL prompt)",
      "   - Compare: consensus issues (high confidence), discrepancies (verify manually), unique (medium confidence)",
      "9. Cross-check all suggestions against docs/glossary.md before implementing",
      "10. Mark steps as ProofStepStatus.VERIFIED after validation passes"
    ],
    "best_practices": [
      "ALWAYS include full mathematical derivation in DirectDerivation steps",
      "Use DualExpr (LaTeX + SymPy) for expressions that can be validated",
      "Never mark a step as VERIFIED without validation (SymPy or dual review)",
      "Property-level granularity: specify exact attributes, not entire objects",
      "Dataflow first: ensure proof.validate_dataflow() returns [] before dual review",
      "Dual review with IDENTICAL prompts: prevents inconsistent feedback",
      "When reviewers contradict, manually verify against docs/glossary.md (potential hallucination)",
      "Cross-reference notation to docs/glossary.md (683 entries) for consistency",
      "Use SubProofReference for complex steps (hierarchical proofs)",
      "All claims must be proven - no SKETCHED steps in final proof"
    ],
    "common_patterns": [
      "Induction proofs: Base case + inductive step as separate ProofSteps",
      "Contradiction proofs: Assume negation \u2192 derive contradiction \u2192 conclude original",
      "Constructive proofs: Build object step-by-step, verify attributes",
      "Hierarchical proofs: Main proof with SubProofReference for technical lemmas",
      "SymPy-validated derivations: Use Transformation system for step-by-step validation"
    ]
  },
  "schemas": {
    "level_0_primitives": [
      {
        "name": "Axiom",
        "module": "fragile.proofs.core.pipeline_types",
        "docstring": "Immutable foundational truth never modified by theorems.\n\nAxioms can be used by any theorem but are never proved.\n\nMaps to Lean:\n    structure Axiom where\n      label : String\n      statement : String\n      mathematical_expression : String\n      foundational_framework : String",
        "json_schema": {
          "description": "Immutable foundational truth never modified by theorems.\n\nAxioms can be used by any theorem but are never proved.\n\nMaps to Lean:\n    structure Axiom where\n      label : String\n      statement : String\n      mathematical_expression : String\n      foundational_framework : String",
          "attributes": {
            "label": {
              "pattern": "^axiom-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "statement": {
              "minLength": 1,
              "title": "Statement",
              "type": "string"
            },
            "mathematical_expression": {
              "minLength": 1,
              "title": "Mathematical Expression",
              "type": "string"
            },
            "foundational_framework": {
              "minLength": 1,
              "title": "Foundational Framework",
              "type": "string"
            }
          },
          "required": [
            "label",
            "statement",
            "mathematical_expression",
            "foundational_framework"
          ],
          "title": "Axiom",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "statement": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "mathematical_expression": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "foundational_framework": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [
          "def-axiom-non-degenerate-noise",
          "def-axiom-guaranteed-revival",
          "def-axiom-bounded-deviation-variance",
          "def-axiom-margin-stability",
          "def-axiom-projection-compatibility",
          "def-axiom-sufficient-amplification",
          "def-axiom-boundary-regularity",
          "def-swarm-aggregation-operator-axiomatic",
          "def-axiom-geometric-consistency",
          "lem-validation-uniform-ball",
          "def-axiom-environmental-richness",
          "def-axiom-boundary-smoothness",
          "def-axiom-bounded-relative-collapse",
          "def-axiom-bounded-algorithmic-diameter",
          "def-axiom-range-respecting-mean",
          "def-assumption-instep-independence",
          "lem-empirical-aggregator-attributes",
          "def-axiom-bounded-variance-production",
          "def-axiom-reward-regularity"
        ],
        "example_instance": null
      },
      {
        "name": "Err",
        "module": "fragile.proofs.core.pipeline_types",
        "docstring": "Error result containing error message.",
        "json_schema": {
          "description": "Error result containing error message.",
          "attributes": {
            "error": {
              "title": "Error",
              "type": "string"
            }
          },
          "required": [
            "error"
          ],
          "title": "Err",
          "type": "object"
        },
        "fields": {
          "error": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [
          "thm-total-error-bound",
          "thm-langevin-baoab-discretization-error",
          "prop-mixing-rate-relationship",
          "thm-full-system-discretization-error",
          "lem-lipschitz-observable-error",
          "prop-finite-second-moment-meanfield",
          "prop-fourth-moment-baoab",
          "thm-mean-square-standardization-error",
          "thm-quantitative-propagation-chaos",
          "lem-baoab-invariant-measure-error",
          "lem-lie-splitting-weak-error",
          "lem-wasserstein-entropy",
          "def-components-mean-square-standardization-error",
          "prop-empirical-wasserstein-concentration",
          "thm-quantitative-error-propagation",
          "lem-baoab-weak-error",
          "prop-interaction-complexity-bound",
          "lem-quantitative-kl-bound",
          "lem-uniform-geometric-ergodicity"
        ],
        "example_instance": {
          "error": "example"
        }
      },
      {
        "name": "Ok",
        "module": "fragile.proofs.core.pipeline_types",
        "docstring": "Success result containing a value.",
        "json_schema": {
          "description": "Success result containing a value.",
          "attributes": {
            "value": {
              "title": "Value"
            }
          },
          "required": [
            "value"
          ],
          "title": "Ok",
          "type": "object"
        },
        "fields": {
          "value": {
            "type": "~T",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "value": null
        }
      }
    ],
    "level_1_basic": [
      {
        "name": "ProofExpansionRequest",
        "module": "fragile.proofs.core.proof_system",
        "docstring": "Request to expand a sketched step.\n\nThis is what gets sent to the LLM for expansion.",
        "json_schema": {
          "$defs": {
            "AssumptionReference": {
              "description": "Reference to an assumption (attribute that may not be proven yet).\n\nAssumptions are attributes that we require but may not have proven.\nThey make the proof conditional.\n\nMaps to Lean:\n    structure AssumptionReference where\n      object_id : String\n      assumption_id : String\n      assumption_statement : String\n      justification : Option String",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "assumption_id": {
                  "description": "Assumption ID",
                  "title": "Assumption Id",
                  "type": "string"
                },
                "assumption_statement": {
                  "description": "Mathematical statement of assumption",
                  "title": "Assumption Statement",
                  "type": "string"
                },
                "justification": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Why this assumption is reasonable",
                  "title": "Justification"
                }
              },
              "required": [
                "object_id",
                "assumption_id",
                "assumption_statement"
              ],
              "title": "AssumptionReference",
              "type": "object"
            },
            "ProofInput": {
              "description": "Input specification for a proof: object + specific attributes needed.\n\nThis is like a function signature: we specify exactly what attributes\nof what objects we need as input.\n\nMaps to Lean:\n    structure ProofInput where\n      object_id : String\n      required_properties : List PropertyReference\n      required_assumptions : List AssumptionReference",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "required_properties": {
                  "description": "Proven attributes required",
                  "items": {
                    "$ref": "#/$defs/PropertyReference"
                  },
                  "title": "Required Properties",
                  "type": "array"
                },
                "required_assumptions": {
                  "description": "Assumptions required (make proof conditional)",
                  "items": {
                    "$ref": "#/$defs/AssumptionReference"
                  },
                  "title": "Required Assumptions",
                  "type": "array"
                }
              },
              "required": [
                "object_id"
              ],
              "title": "ProofInput",
              "type": "object"
            },
            "ProofOutput": {
              "description": "Output specification for a proof: object + attributes established.\n\nAfter the proof, these attributes are now available for the output object.\n\nMaps to Lean:\n    structure ProofOutput where\n      object_id : String\n      properties_established : List PropertyReference",
              "attributes": {
                "object_id": {
                  "description": "Object ID",
                  "title": "Object Id",
                  "type": "string"
                },
                "properties_established": {
                  "description": "Properties proven to hold",
                  "items": {
                    "$ref": "#/$defs/PropertyReference"
                  },
                  "minItems": 1,
                  "title": "Properties Established",
                  "type": "array"
                }
              },
              "required": [
                "object_id",
                "properties_established"
              ],
              "title": "ProofOutput",
              "type": "object"
            },
            "AttributeReference": {
              "description": "Reference to a specific attribute of an object.\n\nThis is the fundamental unit of proof dataflow: we don't say\n\"I need object X\", we say \"I need attribute P of object X\".\n\nMaps to Lean:\n    structure PropertyReference where\n      object_id : String\n      property_id : String\n      property_statement : String",
              "attributes": {
                "object_id": {
                  "description": "Object ID (e.g., 'obj-discrete-system')",
                  "minLength": 1,
                  "title": "Object Id",
                  "type": "string"
                },
                "property_id": {
                  "description": "Property ID (e.g., 'prop-lipschitz-continuity')",
                  "minLength": 1,
                  "title": "Property Id",
                  "type": "string"
                },
                "property_statement": {
                  "description": "Mathematical statement of the attribute",
                  "title": "Property Statement",
                  "type": "string"
                }
              },
              "required": [
                "object_id",
                "property_id",
                "property_statement"
              ],
              "title": "AttributeReference",
              "type": "object"
            }
          },
          "description": "Request to expand a sketched step.\n\nThis is what gets sent to the LLM for expansion.",
          "attributes": {
            "proof_id": {
              "description": "Parent proof ID",
              "title": "Proof Id",
              "type": "string"
            },
            "step_id": {
              "description": "Step to expand",
              "title": "Step Id",
              "type": "string"
            },
            "step_description": {
              "description": "What the step should accomplish",
              "title": "Step Description",
              "type": "string"
            },
            "inputs": {
              "description": "Available inputs",
              "items": {
                "$ref": "#/$defs/ProofInput"
              },
              "title": "Inputs",
              "type": "array"
            },
            "outputs": {
              "description": "Required outputs",
              "items": {
                "$ref": "#/$defs/ProofOutput"
              },
              "title": "Outputs",
              "type": "array"
            },
            "context": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Additional context from proof strategy",
              "title": "Context"
            }
          },
          "required": [
            "proof_id",
            "step_id",
            "step_description",
            "inputs",
            "outputs"
          ],
          "title": "ProofExpansionRequest",
          "type": "object"
        },
        "fields": {
          "proof_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Parent proof ID",
            "default": "PydanticUndefined"
          },
          "step_id": {
            "type": "<class 'str'>",
            "required": true,
            "description": "Step to expand",
            "default": "PydanticUndefined"
          },
          "step_description": {
            "type": "<class 'str'>",
            "required": true,
            "description": "What the step should accomplish",
            "default": "PydanticUndefined"
          },
          "inputs": {
            "type": "typing.List[fragile.proofs.core.proof_system.ProofInput]",
            "required": true,
            "description": "Available inputs",
            "default": "PydanticUndefined"
          },
          "outputs": {
            "type": "typing.List[fragile.proofs.core.proof_system.ProofOutput]",
            "required": true,
            "description": "Required outputs",
            "default": "PydanticUndefined"
          },
          "context": {
            "type": "typing.Optional[str]",
            "required": false,
            "description": "Additional context from proof strategy",
            "default": null
          }
        },
        "dependencies": [
          "ProofInput",
          "ProofOutput"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "proof_id": "example",
          "step_id": "example",
          "step_description": "example",
          "inputs": [],
          "outputs": [],
          "context": null
        }
      },
      {
        "name": "ProofValidationResult",
        "module": "fragile.proofs.core.proof_integration",
        "docstring": "Result of validating proof against theorem.\n\nMaps to Lean:\n    structure ProofValidationResult where\n      is_valid : Bool\n      mismatches : List ProofTheoremMismatch\n      warnings : List String",
        "json_schema": {
          "$defs": {
            "ProofTheoremMismatch": {
              "description": "Describes a mismatch between proof and theorem.\n\nMaps to Lean:\n    structure ProofTheoremMismatch where\n      mismatch_type : String\n      description : String\n      expected : String\n      actual : String",
              "attributes": {
                "mismatch_type": {
                  "description": "Type of mismatch (input/output/attribute)",
                  "title": "Mismatch Type",
                  "type": "string"
                },
                "description": {
                  "description": "Human-readable description",
                  "title": "Description",
                  "type": "string"
                },
                "expected": {
                  "description": "What the theorem expects",
                  "title": "Expected",
                  "type": "string"
                },
                "actual": {
                  "description": "What the proof provides",
                  "title": "Actual",
                  "type": "string"
                }
              },
              "required": [
                "mismatch_type",
                "description",
                "expected",
                "actual"
              ],
              "title": "ProofTheoremMismatch",
              "type": "object"
            }
          },
          "description": "Result of validating proof against theorem.\n\nMaps to Lean:\n    structure ProofValidationResult where\n      is_valid : Bool\n      mismatches : List ProofTheoremMismatch\n      warnings : List String",
          "attributes": {
            "is_valid": {
              "description": "Whether proof matches theorem",
              "title": "Is Valid",
              "type": "boolean"
            },
            "mismatches": {
              "description": "Validation errors",
              "items": {
                "$ref": "#/$defs/ProofTheoremMismatch"
              },
              "title": "Mismatches",
              "type": "array"
            },
            "warnings": {
              "description": "Non-blocking warnings",
              "items": {
                "type": "string"
              },
              "title": "Warnings",
              "type": "array"
            }
          },
          "required": [
            "is_valid"
          ],
          "title": "ProofValidationResult",
          "type": "object"
        },
        "fields": {
          "is_valid": {
            "type": "<class 'bool'>",
            "required": true,
            "description": "Whether proof matches theorem",
            "default": "PydanticUndefined"
          },
          "mismatches": {
            "type": "typing.List[fragile.proofs.core.proof_integration.ProofTheoremMismatch]",
            "required": false,
            "description": "Validation errors",
            "default": "PydanticUndefined"
          },
          "warnings": {
            "type": "typing.List[str]",
            "required": false,
            "description": "Non-blocking warnings",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "ProofTheoremMismatch"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "is_valid": false,
          "mismatches": [],
          "warnings": []
        }
      },
      {
        "name": "SymPyValidator",
        "module": "fragile.proofs.sympy.validation",
        "docstring": "Core validation engine using SymPy.\n\nMaps to Lean:\n    structure SymPyValidator where\n      context : SymPyContext\n      plugin_registry : PluginRegistry\n      strict_mode : Bool",
        "json_schema": {
          "$defs": {
            "AssumptionSet": {
              "description": "Mathematical assumptions about symbols/expressions.\n\nMaps to SymPy's Q.* assumptions where possible.\nAlso includes framework-specific attributes that SymPy doesn't understand.\n\nMaps to Lean:\n    structure AssumptionSet where\n      real : Bool\n      positive : Bool\n      ...",
              "attributes": {
                "real": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Real"
                },
                "positive": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Positive"
                },
                "negative": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Negative"
                },
                "zero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Zero"
                },
                "nonzero": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Nonzero"
                },
                "integer": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integer"
                },
                "rational": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Rational"
                },
                "complex": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Complex"
                },
                "finite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Finite"
                },
                "infinite": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Infinite"
                },
                "even": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Even"
                },
                "odd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Odd"
                },
                "prime": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Prime"
                },
                "symmetric": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Symmetric"
                },
                "hermitian": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Hermitian"
                },
                "orthogonal": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Orthogonal"
                },
                "unitary": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Unitary"
                },
                "spd": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Spd"
                },
                "invertible": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Invertible"
                },
                "bounded": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Bounded"
                },
                "continuous": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Continuous"
                },
                "differentiable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Differentiable"
                },
                "lipschitz": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Lipschitz"
                },
                "measurable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Measurable"
                },
                "integrable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Integrable"
                },
                "custom": {
                  "additionalProperties": true,
                  "title": "Custom",
                  "type": "object"
                }
              },
              "title": "AssumptionSet",
              "type": "object"
            },
            "DualExpr": {
              "additionalProperties": false,
              "description": "Dual representation: LaTeX (authoritative for display) + SymPy (authoritative for validation).\n\nMaps to Lean:\n    structure DualExpr where\n      latex : String\n      sympy : Option SymExpr\n      parse_status : ParseStatus\n\nParse Status:\n- 'ok': SymPy successfully represents this expression\n- 'unavailable': SymPy library not available\n- 'opaque': Expression uses domain-specific operators beyond SymPy\n- 'failed': LaTeX \u2192 SymPy parsing failed (with error message)",
              "attributes": {
                "latex": {
                  "description": "LaTeX representation (authoritative for display)",
                  "minLength": 1,
                  "title": "Latex",
                  "type": "string"
                },
                "sympy": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/SymExpr"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SymPy representation (authoritative for validation)"
                },
                "parse_status": {
                  "default": "ok",
                  "description": "Status of SymPy representation",
                  "enum": [
                    "ok",
                    "unavailable",
                    "opaque",
                    "failed"
                  ],
                  "title": "Parse Status",
                  "type": "string"
                },
                "parse_error": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Error message if parse_status='failed'",
                  "title": "Parse Error"
                }
              },
              "required": [
                "latex"
              ],
              "title": "DualExpr",
              "type": "object"
            },
            "DualStatement": {
              "additionalProperties": false,
              "description": "Mathematical statement with dual representation.\n\nExamples:\n- Equality: lhs = rhs\n- Inequality: lhs < rhs, lhs \u2264 rhs\n- Logical: A \u27f9 B, A \u27fa B\n\nMaps to Lean:\n    structure DualStatement where\n      lhs : DualExpr\n      relation : RelationSymbol\n      rhs : DualExpr\n      assumptions : AssumptionSet\n      context : Option String",
              "attributes": {
                "lhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Left-hand side expression"
                },
                "relation": {
                  "description": "Relation symbol",
                  "enum": [
                    "=",
                    "<",
                    "<=",
                    ">",
                    ">=",
                    "!=",
                    "\u27f9",
                    "\u27fa",
                    "\u2208",
                    "\u2286"
                  ],
                  "title": "Relation",
                  "type": "string"
                },
                "rhs": {
                  "$ref": "#/$defs/DualExpr",
                  "description": "Right-hand side expression"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Required assumptions for this statement"
                },
                "context": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional context (e.g., 'for all x > 0')",
                  "title": "Context"
                }
              },
              "required": [
                "lhs",
                "relation",
                "rhs"
              ],
              "title": "DualStatement",
              "type": "object"
            },
            "PluginRegistry": {
              "description": "Registry of validation plugins.",
              "attributes": {
                "plugins": {
                  "description": "Registered plugins (must match ValidationPlugin protocol)",
                  "items": {},
                  "title": "Plugins",
                  "type": "array"
                }
              },
              "title": "PluginRegistry",
              "type": "object"
            },
            "SymExpr": {
              "additionalProperties": false,
              "description": "Base class for all SymPy expressions.\n\nUses discriminated union pattern with 'type' field for JSON serialization\nand type safety.\n\nAll subclasses must:\n1. Set type: Literal['SpecificType'] as class attribute\n2. Implement to_sympy() -> sympy.Basic\n3. Be frozen (immutable)\n\nMaps to Lean:\n    inductive SymExpr where\n      | Symbol : String \u2192 AssumptionSet \u2192 SymExpr\n      | Integer : Int \u2192 SymExpr\n      | Add : List SymExpr \u2192 SymExpr\n      ...",
              "attributes": {
                "type": {
                  "description": "Discriminant for union type",
                  "title": "Type",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "title": "SymExpr",
              "type": "object"
            },
            "SymPyContext": {
              "description": "Symbol table and assumption management for SymPy validation.\n\nThe context tracks:\n1. Symbol declarations (variables with their attributes)\n2. Global assumptions (facts that hold throughout a proof)\n3. Local assumptions (facts that hold in current scope)\n4. Parse cache (memoize LaTeX \u2192 SymPy conversions)\n\nMaps to Lean:\n    structure SymPyContext where\n      symbols : HashMap String SymbolDeclaration\n      global_assumptions : List DualStatement\n      local_assumptions : List DualStatement",
              "attributes": {
                "symbols": {
                  "additionalProperties": {
                    "$ref": "#/$defs/SymbolDeclaration"
                  },
                  "description": "Symbol table (name \u2192 declaration)",
                  "title": "Symbols",
                  "type": "object"
                },
                "global_assumptions": {
                  "description": "Global assumptions for entire proof",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Global Assumptions",
                  "type": "array"
                },
                "local_assumptions": {
                  "description": "Local assumptions for current scope",
                  "items": {
                    "$ref": "#/$defs/DualStatement"
                  },
                  "title": "Local Assumptions",
                  "type": "array"
                }
              },
              "title": "SymPyContext",
              "type": "object"
            },
            "SymbolDeclaration": {
              "description": "Declaration of a symbolic variable with its attributes.\n\nMaps to Lean:\n    structure SymbolDeclaration where\n      name : String\n      latex_name : String\n      assumptions : AssumptionSet\n      description : Option String",
              "attributes": {
                "name": {
                  "description": "SymPy variable name",
                  "minLength": 1,
                  "title": "Name",
                  "type": "string"
                },
                "latex_name": {
                  "description": "LaTeX representation",
                  "minLength": 1,
                  "title": "Latex Name",
                  "type": "string"
                },
                "assumptions": {
                  "$ref": "#/$defs/AssumptionSet",
                  "description": "Assumptions about this symbol"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Human-readable description",
                  "title": "Description"
                }
              },
              "required": [
                "name",
                "latex_name"
              ],
              "title": "SymbolDeclaration",
              "type": "object"
            }
          },
          "description": "Core validation engine using SymPy.\n\nMaps to Lean:\n    structure SymPyValidator where\n      context : SymPyContext\n      plugin_registry : PluginRegistry\n      strict_mode : Bool",
          "attributes": {
            "context": {
              "$ref": "#/$defs/SymPyContext",
              "description": "Symbol table and assumptions"
            },
            "plugin_registry": {
              "$ref": "#/$defs/PluginRegistry",
              "description": "Domain-specific plugins"
            },
            "strict_mode": {
              "default": false,
              "description": "If True, require SymPy validation (no LLM fallback for uncertain cases)",
              "title": "Strict Mode",
              "type": "boolean"
            }
          },
          "title": "SymPyValidator",
          "type": "object"
        },
        "fields": {
          "context": {
            "type": "<class 'fragile.proofs.sympy.dual_representation.SymPyContext'>",
            "required": false,
            "description": "Symbol table and assumptions",
            "default": "PydanticUndefined"
          },
          "plugin_registry": {
            "type": "<class 'fragile.proofs.sympy.validation.PluginRegistry'>",
            "required": false,
            "description": "Domain-specific plugins",
            "default": "PydanticUndefined"
          },
          "strict_mode": {
            "type": "<class 'bool'>",
            "required": false,
            "description": "If True, require SymPy validation (no LLM fallback for uncertain cases)",
            "default": "False"
          }
        },
        "dependencies": [
          "PluginRegistry",
          "SymPyContext"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": {
          "context": {
            "symbols": {},
            "global_assumptions": [],
            "local_assumptions": []
          },
          "plugin_registry": {
            "plugins": []
          },
          "strict_mode": false
        }
      },
      {
        "name": "TheoremBox",
        "module": "fragile.proofs.core.pipeline_types",
        "docstring": "Theorem as processing box with well-defined I/O.\n\nInputs: objects, axioms, parameters\nProperties Required: API signature (attributes objects must have)\nInternal Processing: DAG of lemmas\nOutputs: attributes, relations, existence statements, etc.\n\nConditionality is COMPUTED by checking properties_required\nagainst each object's current_properties.\n\nMaps to Lean:\n    structure TheoremBox where\n      label : String\n      name : String\n      input_objects : List String\n      input_axioms : List String\n      input_parameters : List String\n      properties_required : HashMap String (List String)\n      ...\n\n      def compute_conditionality\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : List String := ...\n\n      def is_conditional\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : Bool :=\n        !(thm.compute_conditionality objects).isEmpty",
        "json_schema": {
          "$defs": {
            "Attribute": {
              "description": "Property assigned to a mathematical object by a theorem.\n\nConditionality is COMPUTED dynamically (not stored here).\nCheck theorem.properties_required vs object.current_properties.\n\nMaps to Lean:\n    structure Property where\n      label : String\n      expression : String\n      object_label : String\n      established_by : String\n      ...\n\n      def is_unconditional (p : Property) (conds : List String) : Bool :=\n        conds.isEmpty",
              "attributes": {
                "label": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "LaTeX mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "object_label": {
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Object Label",
                  "type": "string"
                },
                "established_by": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step",
                  "title": "Timestamp"
                },
                "can_be_refined": {
                  "default": true,
                  "description": "Whether attribute can be strengthened",
                  "title": "Can Be Refined",
                  "type": "boolean"
                },
                "refinements": {
                  "items": {
                    "$ref": "#/$defs/PropertyRefinement"
                  },
                  "title": "Refinements",
                  "type": "array"
                }
              },
              "required": [
                "label",
                "expression",
                "object_label",
                "established_by"
              ],
              "title": "Attribute",
              "type": "object"
            },
            "AttributeRefinement": {
              "description": "Tracks when a attribute is strengthened or generalized.\n\nExample: prop-continuous \u2192 prop-smooth (strengthening)\n\nMaps to Lean:\n    structure PropertyRefinement where\n      original_property : String\n      refined_property : String\n      ...",
              "attributes": {
                "original_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Original Property",
                  "type": "string"
                },
                "refined_property": {
                  "pattern": "^prop-[a-z0-9-]+$",
                  "title": "Refined Property",
                  "type": "string"
                },
                "refinement_theorem": {
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Refinement Theorem",
                  "type": "string"
                },
                "refinement_type": {
                  "$ref": "#/$defs/RefinementType"
                }
              },
              "required": [
                "original_property",
                "refined_property",
                "refinement_theorem",
                "refinement_type"
              ],
              "title": "AttributeRefinement",
              "type": "object"
            },
            "RefinementType": {
              "description": "Property refinement types.",
              "enum": [
                "strengthening",
                "generalization",
                "quantification"
              ],
              "title": "RefinementType",
              "type": "string"
            },
            "RelationType": {
              "description": "Types of relationships between mathematical objects.\n\nMaps to Lean:\n    inductive RelationType where\n      | equivalence : RelationType\n      | embedding : RelationType\n      ...",
              "enum": [
                "equivalence",
                "embedding",
                "approximation",
                "reduction",
                "extension",
                "generalization",
                "specialization",
                "other"
              ],
              "title": "RelationType",
              "type": "string"
            },
            "Relationship": {
              "description": "Relationship between two mathematical objects established by a theorem.\n\nFirst-class object with label, type, directionality, and attributes.\n\nExamples:\n    - Equivalence: discrete \u2261 continuous (bidirectional)\n    - Embedding: particles \u21aa fluid (directed)\n    - Approximation: discrete \u2248 continuous with O(N^{-1/d}) (directed)\n    - Reduction: PDE \u2192 ODE (directed)\n\nMaps to Lean:\n    structure Relationship where\n      label : String\n      relationship_type : RelationType\n      source_object : String\n      target_object : String\n      bidirectional : Bool\n      established_by : String\n      attributes : List RelationshipProperty\n      expression : String\n\n      def is_symmetric (r : Relationship) : Bool :=\n        r.bidirectional\n\n      def is_directed (r : Relationship) : Bool :=\n        !r.bidirectional",
              "attributes": {
                "label": {
                  "description": "Relationship label (format: rel-{source}-{target}-{type})",
                  "pattern": "^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$",
                  "title": "Label",
                  "type": "string"
                },
                "relationship_type": {
                  "$ref": "#/$defs/RelationType"
                },
                "bidirectional": {
                  "description": "Whether relationship is symmetric (auto-computed from type if not provided)",
                  "title": "Bidirectional",
                  "type": "boolean"
                },
                "source_object": {
                  "description": "Source object label",
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Source Object",
                  "type": "string"
                },
                "target_object": {
                  "description": "Target object label",
                  "pattern": "^obj-[a-z0-9-]+$",
                  "title": "Target Object",
                  "type": "string"
                },
                "established_by": {
                  "description": "Theorem that established this relationship",
                  "pattern": "^thm-[a-z0-9-]+$",
                  "title": "Established By",
                  "type": "string"
                },
                "expression": {
                  "description": "Mathematical expression of relationship",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "attributes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/$defs/RelationshipProperty"
                  },
                  "description": "Relationship-specific attributes (e.g., error bounds, convergence rates)",
                  "title": "Properties"
                },
                "tags": {
                  "description": "Category tags (e.g., 'mean-field', 'discrete-continuous')",
                  "items": {
                    "type": "string"
                  },
                  "title": "Tags",
                  "type": "array"
                },
                "timestamp": {
                  "anyOf": [
                    {
                      "minimum": 0,
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Pipeline execution step when established",
                  "title": "Timestamp"
                }
              },
              "required": [
                "label",
                "relationship_type",
                "bidirectional",
                "source_object",
                "target_object",
                "established_by",
                "expression"
              ],
              "title": "Relationship",
              "type": "object"
            },
            "RelationshipAttribute": {
              "description": "Property of a relationship (e.g., error bounds, convergence rates).\n\nExample: For an approximation relationship, might have error = O(N^{-1/d})\n\nMaps to Lean:\n    structure RelationshipProperty where\n      label : String\n      expression : String\n      description : String",
              "attributes": {
                "label": {
                  "description": "Property label (e.g., 'approx-error-N')",
                  "pattern": "^[a-z][a-zA-Z0-9-]*$",
                  "title": "Label",
                  "type": "string"
                },
                "expression": {
                  "description": "Mathematical expression",
                  "minLength": 1,
                  "title": "Expression",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Description"
                }
              },
              "required": [
                "label",
                "expression"
              ],
              "title": "RelationshipAttribute",
              "type": "object"
            },
            "TheoremOutputType": {
              "description": "The 13 fundamental theorem output types providing complete coverage\nof mathematical reasoning.\n\nMaps to Lean:\n    inductive TheoremOutputType where\n      | attribute : TheoremOutputType\n      | relation : TheoremOutputType\n      ...",
              "enum": [
                "Attribute",
                "Relation",
                "Existence",
                "Construction",
                "Classification",
                "Uniqueness",
                "Impossibility",
                "Embedding",
                "Approximation",
                "Equivalence",
                "Decomposition",
                "Extension",
                "Reduction"
              ],
              "title": "TheoremOutputType",
              "type": "string"
            }
          },
          "description": "Theorem as processing box with well-defined I/O.\n\nInputs: objects, axioms, parameters\nProperties Required: API signature (attributes objects must have)\nInternal Processing: DAG of lemmas\nOutputs: attributes, relations, existence statements, etc.\n\nConditionality is COMPUTED by checking properties_required\nagainst each object's current_properties.\n\nMaps to Lean:\n    structure TheoremBox where\n      label : String\n      name : String\n      input_objects : List String\n      input_axioms : List String\n      input_parameters : List String\n      properties_required : HashMap String (List String)\n      ...\n\n      def compute_conditionality\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : List String := ...\n\n      def is_conditional\n        (thm : TheoremBox)\n        (objects : HashMap String MathematicalObject)\n        : Bool :=\n        !(thm.compute_conditionality objects).isEmpty",
          "attributes": {
            "label": {
              "pattern": "^thm-[a-z0-9-]+$",
              "title": "Label",
              "type": "string"
            },
            "name": {
              "minLength": 1,
              "title": "Name",
              "type": "string"
            },
            "input_objects": {
              "items": {
                "type": "string"
              },
              "title": "Input Objects",
              "type": "array"
            },
            "input_axioms": {
              "items": {
                "type": "string"
              },
              "title": "Input Axioms",
              "type": "array"
            },
            "input_parameters": {
              "items": {
                "type": "string"
              },
              "title": "Input Parameters",
              "type": "array"
            },
            "attributes_required": {
              "additionalProperties": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "description": "API signature: {object_label: [required_properties]}",
              "title": "Properties Required",
              "type": "object"
            },
            "internal_lemmas": {
              "items": {
                "type": "string"
              },
              "title": "Internal Lemmas",
              "type": "array"
            },
            "internal_propositions": {
              "items": {
                "type": "string"
              },
              "title": "Internal Propositions",
              "type": "array"
            },
            "lemma_dag_edges": {
              "description": "DAG edges: (from, to)",
              "items": {
                "maxItems": 2,
                "minItems": 2,
                "prefixItems": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "type": "array"
              },
              "title": "Lemma Dag Edges",
              "type": "array"
            },
            "output_type": {
              "$ref": "#/$defs/TheoremOutputType"
            },
            "attributes_added": {
              "items": {
                "$ref": "#/$defs/Property"
              },
              "title": "Properties Added",
              "type": "array"
            },
            "relations_established": {
              "description": "Relationships between objects established by this theorem",
              "items": {
                "$ref": "#/$defs/Relationship"
              },
              "title": "Relations Established",
              "type": "array"
            }
          },
          "required": [
            "label",
            "name",
            "output_type"
          ],
          "title": "TheoremBox",
          "type": "object"
        },
        "fields": {
          "label": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "name": {
            "type": "<class 'str'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_objects": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_axioms": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "input_parameters": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "attributes_required": {
            "type": "typing.Dict[str, typing.List[str]]",
            "required": false,
            "description": "API signature: {object_label: [required_properties]}",
            "default": "PydanticUndefined"
          },
          "internal_lemmas": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "internal_propositions": {
            "type": "typing.List[str]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "lemma_dag_edges": {
            "type": "typing.List[typing.Tuple[str, str]]",
            "required": false,
            "description": "DAG edges: (from, to)",
            "default": "PydanticUndefined"
          },
          "output_type": {
            "type": "<enum 'TheoremOutputType'>",
            "required": true,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "attributes_added": {
            "type": "typing.List[fragile.proofs.core.pipeline_types.Property]",
            "required": false,
            "description": "No description",
            "default": "PydanticUndefined"
          },
          "relations_established": {
            "type": "typing.List[fragile.proofs.core.pipeline_types.Relationship]",
            "required": false,
            "description": "Relationships between objects established by this theorem",
            "default": "PydanticUndefined"
          }
        },
        "dependencies": [
          "Attribute",
          "Relationship"
        ],
        "used_by": [],
        "glossary_refs": [],
        "example_instance": null
      }
    ]
  },
  "examples": {
    "minimal_direct_proof": {
      "description": "Single-step proof with DirectDerivation",
      "use_case": "Simple theorems requiring one direct argument",
      "example_structure": {
        "proof_id": "proof-thm-simple",
        "proves": "thm-simple",
        "steps": [
          {
            "step_type": "DirectDerivation",
            "status": "EXPANDED",
            "mathematical_content": "Full LaTeX derivation here"
          }
        ]
      },
      "code_reference": "See examples/complete_integration_example.py"
    },
    "hierarchical_proof": {
      "description": "Multi-level proof with sub-proofs",
      "use_case": "Complex theorems requiring modular proof structure",
      "example_structure": {
        "main_proof": "proof-thm-main",
        "steps": [
          {
            "step_type": "SubProofReference",
            "sub_proof_id": "proof-lem-technical"
          },
          {
            "step_type": "DirectDerivation",
            "mathematical_content": "..."
          }
        ],
        "sub_proofs": {
          "proof-lem-technical": "..."
        }
      },
      "code_reference": "See examples/proof_system_example.py lines 50-200"
    },
    "sympy_validated_proof": {
      "description": "Proof with SymPy mathematical validation",
      "use_case": "Algebraic/analytical theorems with symbolic computation",
      "workflow": [
        "1. Define DualExpr for each mathematical expression",
        "2. Use Transformation to show step-by-step derivation",
        "3. SymPyValidator.validate() to check correctness",
        "4. Include ValidationResult in proof documentation"
      ],
      "code_reference": "See examples/sympy_integration_example.py"
    }
  },
  "validation_checklist": [
    "[ ] All ProofInputs specify exact attributes (PropertyReference), not object IDs",
    "[ ] All ProofOutputs establish new attributes with PropertyReference",
    "[ ] proof.validate_dataflow() returns empty list (no missing inputs)",
    "[ ] validate_proof_for_theorem() returns is_valid=True",
    "[ ] All DirectDerivation steps have non-empty mathematical_content",
    "[ ] SymPy validation used where applicable (algebraic/analytical steps)",
    "[ ] Dual review completed: Gemini 2.5 Pro + Codex with IDENTICAL prompts",
    "[ ] All reviewer suggestions cross-checked against docs/glossary.md",
    "[ ] No ProofStepStatus.SKETCHED in final proof (all EXPANDED or VERIFIED)",
    "[ ] All notation consistent with docs/glossary.md (683 entries)",
    "[ ] Proof claims exactly match theorem requirements (no more, no less)",
    "[ ] All IDs follow conventions: proof-{thm-label}, prop-{name}, obj-{name}"
  ],
  "common_pitfalls": [
    "\u274c Marking step as VERIFIED without actual validation",
    "\u274c Using object_id instead of PropertyReference in ProofInput",
    "\u274c Empty mathematical_content in DirectDerivation (must include full derivation)",
    "\u274c Skipping SymPy validation for algebraic steps (use DualExpr + Transformation)",
    "\u274c Accepting reviewer suggestions without cross-checking docs/glossary.md",
    "\u274c Using different prompts for Gemini vs Codex (must be IDENTICAL)",
    "\u274c Leaving ProofStepStatus.SKETCHED in supposedly rigorous proof",
    "\u274c Claiming more than theorem requires (scope creep)",
    "\u274c Forgetting to validate dataflow before dual review (waste of reviewer time)",
    "\u274c Inventing notation not in docs/glossary.md (breaks consistency)"
  ],
  "documentation_refs": {
    "examples": {
      "proof_system_example.py": "Hierarchical proof structure with sub-proofs (lines 37-400)",
      "complete_integration_example.py": "Theorem \u2192 Proof \u2192 Validation workflow (lines 100-300)",
      "sympy_integration_example.py": "SymPy validation and DualExpr usage (full file)"
    },
    "guides": {
      "CLAUDE.md": "\u00a7 Mathematical Proofing and Documentation (dual review protocol)",
      "examples/README.md": "Complete proof system documentation (400+ lines)",
      "LEAN_EMULATION_GUIDE.md": "Lean-compatible design patterns"
    },
    "glossary": "docs/glossary.md (683 mathematical entries - USE THIS for notation)",
    "framework_docs": [
      "docs/source/1_euclidean_gas/ - Euclidean Gas framework (12 documents)",
      "docs/source/2_geometric_gas/ - Geometric Gas framework"
    ]
  }
}