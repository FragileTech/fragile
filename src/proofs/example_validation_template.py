"""
Symbolic Validation Template for Mathematical Theorems

This is an EXAMPLE template showing the structure of validation scripts
generated by the Math Verifier agent.

Source: EXAMPLE (not a real theorem)
Generated: Template
Agent: Math Verifier v1.0

PURPOSE:
--------
This module provides sympy-based validation of algebraic manipulations
in mathematical proofs. Each function validates one algebraic step.

USAGE:
------
1. Direct execution:
   python src/proofs/{doc_name}/{theorem_label}.py

2. With pytest:
   pytest src/proofs/{doc_name}/{theorem_label}.py -v

3. Run all validations for a document:
   pytest src/proofs/{doc_name}/ -v

4. Continuous validation (after edits):
   pytest src/proofs/{doc_name}/ --exitfirst

STRUCTURE:
----------
- Framework symbols (extracted from glossary.md)
- Validation functions (one per algebraic step)
- Test runner
- Documentation with source references
"""

from sympy import (
    symbols,      # Define symbolic variables
    simplify,     # Algebraic simplification
    expand,       # Expand products
    factor,       # Factor expressions
    log, exp,     # Logarithmic and exponential functions
    sqrt,         # Square root
    diff,         # Differentiation
    Matrix,       # Linear algebra
)
import pytest


# ========================================
# FRAMEWORK SYMBOLS (from glossary.md)
# ========================================

# These symbols are extracted from the glossary and used across
# multiple validation functions. Adjust assumptions based on context.

# Common parameters
SIGMA, GAMMA, TAU = symbols('sigma gamma tau', positive=True, real=True)
EPSILON, KAPPA = symbols('epsilon kappa', positive=True, real=True)
LAMBDA_V = symbols('lambda_v', positive=True, real=True)

# Fractions and weights
ALPHA, BETA = symbols('alpha beta', positive=True, real=True)
F_H, F_L = symbols('f_H f_L', positive=True, real=True)

# Means and variances
MU_H, MU_L, MU_V = symbols('mu_H mu_L mu_V', real=True)
VAR_X, VAR_V = symbols('Var_x Var_v', positive=True, real=True)

# Bounds
V_MAX, V_MIN = symbols('V_max V_min', positive=True, real=True)


# ========================================
# VALIDATION FUNCTIONS
# ========================================

def test_example_variance_decomposition():
    """
    Verify: Law of Total Variance decomposition

    Claim: Var_B = f_H * f_L * (μ_H - μ_L)²

    Source: EXAMPLE (template)
    Category: Variance Decomposition
    """

    # Define symbols
    f_H, f_L = symbols('f_H f_L', positive=True, real=True)
    mu_H, mu_L = symbols('mu_H mu_L', real=True)

    # Constraint: f_H + f_L = 1
    # We'll apply by substituting f_L = 1 - f_H

    # Total mean (barycenter)
    mu_V = f_H * mu_H + f_L * mu_L

    # Between-group variance definition
    Var_B_def = f_H * (mu_H - mu_V)**2 + f_L * (mu_L - mu_V)**2

    # Claimed form
    Var_B_claimed = f_H * f_L * (mu_H - mu_L)**2

    # Expand definition
    Var_B_expanded = expand(Var_B_def.subs(mu_V, f_H * mu_H + f_L * mu_L))

    # Apply constraint f_L = 1 - f_H
    difference = Var_B_expanded - Var_B_claimed
    difference_constrained = difference.subs(f_L, 1 - f_H)

    # Verify equality
    assert simplify(difference_constrained) == 0, \
        f"Variance decomposition failed: diff = {simplify(difference_constrained)}"

    print("✓ Law of Total Variance decomposition verified")


def test_example_logarithmic_identity():
    """
    Verify: Logarithmic identity transformation

    Claim: ln(V_max) - ln(V_max - κ) = ln(1 + κ/(V_max - κ))

    Source: EXAMPLE (template)
    Category: Logarithmic Bounds
    """

    V_max, kappa = symbols('V_max kappa', positive=True, real=True)

    # LHS: difference of logarithms
    lhs = log(V_max) - log(V_max - kappa)

    # Intermediate form: ln(a/b)
    middle = log(V_max / (V_max - kappa))

    # Verify first transformation
    assert simplify(lhs - middle) == 0, \
        f"Log difference transformation failed: {simplify(lhs - middle)}"

    # RHS: ln(1 + x) form
    rhs = log(1 + kappa / (V_max - kappa))

    # Verify second transformation
    # Need to show: V_max / (V_max - κ) = 1 + κ/(V_max - κ)
    ratio_check = simplify(V_max / (V_max - kappa) - (1 + kappa / (V_max - kappa)))
    assert ratio_check == 0, f"Ratio conversion failed: {ratio_check}"

    # Final verification
    assert simplify(lhs - rhs) == 0, \
        f"Logarithmic identity failed: diff = {simplify(lhs - rhs)}"

    print("✓ Logarithmic identity verified: ln(a) - ln(b) = ln(1 + (a-b)/b)")


def test_example_quadratic_form_expansion():
    """
    Verify: Quadratic form expansion with bilinear term

    Claim: q(a + b) = q(a) + q(b) + 2⟨a, b⟩_q
    where q(Δx, Δv) = Δx² + λ_v·Δv² + b·Δx·Δv

    Source: EXAMPLE (template)
    Category: Hypocoercive Cost / Quadratic Forms
    """

    # Define variables
    a_x, a_v, b_x, b_v = symbols('a_x a_v b_x b_v', real=True)
    lambda_v, b_coeff = symbols('lambda_v b', positive=True, real=True)

    # Hypocoercive quadratic form
    def q(dx, dv):
        """q(Δx, Δv) = Δx² + λ_v·Δv² + b·Δx·Δv"""
        return dx**2 + lambda_v * dv**2 + b_coeff * dx * dv

    # Bilinear form: 2⟨a, b⟩_q
    def bilinear(ax, av, bx, bv):
        """2⟨a, b⟩_q for hypocoercive metric"""
        return 2 * (ax * bx + lambda_v * av * bv +
                    b_coeff * (ax * bv + av * bx))

    # Left-hand side: q(a + b)
    lhs = q(a_x + b_x, a_v + b_v)
    lhs_expanded = expand(lhs)

    # Right-hand side: q(a) + q(b) + 2⟨a, b⟩_q
    rhs = q(a_x, a_v) + q(b_x, b_v) + bilinear(a_x, a_v, b_x, b_v)
    rhs_expanded = expand(rhs)

    # Verify expansion
    difference = simplify(lhs_expanded - rhs_expanded)
    assert difference == 0, \
        f"Quadratic form expansion failed: diff = {difference}"

    print("✓ Quadratic form expansion verified: q(a+b) = q(a) + q(b) + 2⟨a,b⟩")


def test_example_derivative_verification():
    """
    Verify: Derivative of logistic function

    Claim: d/dz [2/(1 + e^(-z))] = 2e^(-z) / (1 + e^(-z))²

    Source: EXAMPLE (template)
    Category: Logistic Functions
    """

    z = symbols('z', real=True)

    # Logistic function
    g = 2 / (1 + exp(-z))

    # Compute derivative
    g_prime = diff(g, z)

    # Claimed derivative form
    g_prime_claimed = 2 * exp(-z) / (1 + exp(-z))**2

    # Verify
    difference = simplify(g_prime - g_prime_claimed)
    assert difference == 0, \
        f"Logistic derivative failed: diff = {difference}"

    # Also verify alternative form: g'(z) = g(z) * (1 - g(z)/2)
    g_prime_alt = g * (1 - g / 2)
    difference_alt = simplify(g_prime - g_prime_alt)
    assert difference_alt == 0, \
        f"Alternative form failed: diff = {difference_alt}"

    print("✓ Logistic derivative verified (both forms)")


def test_example_simple_algebraic_identity():
    """
    Verify: Simple algebraic manipulation

    Claim: (a + b)² = a² + 2ab + b²

    Source: EXAMPLE (template)
    Category: Simple Identities
    """

    a, b = symbols('a b', real=True)

    # LHS: square of sum
    lhs = (a + b)**2
    lhs_expanded = expand(lhs)

    # RHS: expanded form
    rhs = a**2 + 2*a*b + b**2

    # Verify
    difference = simplify(lhs_expanded - rhs)
    assert difference == 0, f"Binomial expansion failed: diff = {difference}"

    print("✓ Binomial expansion verified: (a+b)² = a² + 2ab + b²")


# ========================================
# EDGE CASE VALIDATION EXAMPLES
# ========================================

def test_example_constraint_application():
    """
    Example: How to apply constraints in validation

    Demonstrates: Using .subs() to apply constraints like f_H + f_L = 1

    Source: EXAMPLE (template)
    """

    f_H, f_L = symbols('f_H f_L', positive=True, real=True)

    # Expression involving both f_H and f_L
    expr = f_H * f_L * (f_H + f_L)

    # Without constraint: expr is unsimplified
    # With constraint f_H + f_L = 1: expr = f_H * f_L

    expr_constrained = expr.subs(f_L, 1 - f_H)
    expected = f_H * (1 - f_H)

    assert simplify(expr_constrained - expected) == 0, \
        "Constraint application failed"

    print("✓ Constraint application verified")


def test_example_special_value_check():
    """
    Example: Verify identity holds for special values

    Demonstrates: Checking algebraic identity at specific points

    Source: EXAMPLE (template)
    """

    x = symbols('x', real=True)

    # Identity: (x - 1)² + 2x = x² + 1
    lhs = (x - 1)**2 + 2*x
    rhs = x**2 + 1

    # Verify symbolically
    assert simplify(expand(lhs) - rhs) == 0, "Symbolic verification failed"

    # Verify at special values
    special_values = [0, 1, -1, 2]
    for val in special_values:
        lhs_val = lhs.subs(x, val)
        rhs_val = rhs.subs(x, val)
        assert lhs_val == rhs_val, \
            f"Identity failed at x={val}: {lhs_val} ≠ {rhs_val}"

    print("✓ Identity verified symbolically and at special values")


# ========================================
# TEST RUNNER
# ========================================

def run_all_validations():
    """
    Run all validation tests for this module

    Returns:
        tuple: (passed_count, failed_count)
    """

    tests = [
        test_example_variance_decomposition,
        test_example_logarithmic_identity,
        test_example_quadratic_form_expansion,
        test_example_derivative_verification,
        test_example_simple_algebraic_identity,
        test_example_constraint_application,
        test_example_special_value_check,
    ]

    passed = 0
    failed = 0
    errors = []

    print("="*60)
    print("RUNNING SYMBOLIC VALIDATION TESTS")
    print("="*60)
    print()

    for test in tests:
        try:
            test()
            passed += 1
        except AssertionError as e:
            print(f"✗ {test.__name__} FAILED")
            print(f"  Error: {e}")
            failed += 1
            errors.append((test.__name__, str(e)))
        except Exception as e:
            print(f"✗ {test.__name__} ERROR")
            print(f"  Exception: {e}")
            failed += 1
            errors.append((test.__name__, str(e)))

    print()
    print("="*60)
    print(f"VALIDATION SUMMARY")
    print("="*60)
    print(f"Total Tests:  {len(tests)}")
    print(f"Passed:       {passed} ({passed/len(tests)*100:.1f}%)")
    print(f"Failed:       {failed}")
    print("="*60)

    if errors:
        print()
        print("FAILED TESTS:")
        for test_name, error_msg in errors:
            print(f"  - {test_name}")
            print(f"    {error_msg}")

    return passed, failed


# ========================================
# PYTEST INTEGRATION
# ========================================

# Pytest will automatically discover and run all functions
# starting with "test_". No additional configuration needed.

# To run with pytest:
#   pytest src/proofs/example_validation_template.py -v


# ========================================
# MAIN EXECUTION
# ========================================

if __name__ == "__main__":
    # Run all validations when executed directly
    passed, failed = run_all_validations()

    # Exit with appropriate code
    import sys
    sys.exit(0 if failed == 0 else 1)
