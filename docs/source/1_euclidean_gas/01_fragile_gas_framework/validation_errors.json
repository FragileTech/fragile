{
  "pipeline_dir": "docs/source/1_euclidean_gas/01_fragile_gas_framework/pipeline_data",
  "statistics": {
    "total_files": 216,
    "axioms_valid": 20,
    "axioms_errors": 2,
    "objects_valid": 56,
    "parameters_valid": 52,
    "parameters_errors": 3,
    "theorems_errors": 47,
    "theorems_valid": 36
  },
  "total_errors": 52,
  "errors": [
    {
      "file": "axioms/axiom-well-behaved-rescale-function.json",
      "entity_type": "axioms",
      "error": "  - statement: String should have at least 1 character\n    Input: \n  - mathematical_expression: String should have at least 1 character\n    Input: "
    },
    {
      "file": "axioms/def-axiom-rescale-function.json",
      "entity_type": "axioms",
      "error": "  - label: String should match pattern '^axiom-[a-z0-9-]+$'\n    Input: def-axiom-rescale-function\n  - statement: String should have at least 1 character\n    Input: \n  - mathematical_expression: String should have at least 1 character\n    Input: "
    },
    {
      "file": "parameters/param-l-sigma'-reg.json",
      "entity_type": "parameters",
      "error": "  - label: String should match pattern '^param-[a-z0-9-]+$'\n    Input: param-l-sigma'-reg"
    },
    {
      "file": "parameters/param-\\delta-{x-i}.json",
      "entity_type": "parameters",
      "error": "  - label: String should match pattern '^param-[a-z0-9-]+$'\n    Input: param-\\delta-{x-i}"
    },
    {
      "file": "parameters/param-\\mathcal{x}.json",
      "entity_type": "parameters",
      "error": "  - label: String should match pattern '^param-[a-z0-9-]+$'\n    Input: param-\\mathcal{x}"
    },
    {
      "file": "theorems/lem-probabilistic-bound-perturbation-displacement.json",
      "entity_type": "theorems",
      "error": "  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-potential-boundedness.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-perturbation-positional-bound.json",
      "entity_type": "theorems",
      "error": "  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-boundary-heat-kernel.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Lipschitz constant bounded by C_d'*Per(E)/sigma\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Heat-kernel smoothed probability P_sigma(x) is Lipschitz continuous\n  - relations_established -> 2: Input should be a valid dictionary or instance of Relationship\n    Input: In algorithmic metric: L_death <= (Per(phi(E))/sigma)*L_phi\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: $E=\\mathcal{X}_{\\mathrm{invalid}}$ has finite perimeter\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n    Input: $p_{\\sigma^2}$ is heat kernel at scale $\\sigma$\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: $|P_\\sigma(x)-P_\\sigma(y)| \\le C_d'\\,\\frac{\\mathrm{Per}(E)}{\\sigma}\\, d_{\\mathcal X}(x,y)$"
    },
    {
      "file": "theorems/lem-cubic-patch-derivative-bounds.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Explicit bound: L_P = 1 + (3log(2)-2)^2/(3(2log(2)-1)) ~= 1.0054\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Cubic patch derivative P'(z(s)) is uniformly bounded: 0 <= P'(z(s)) <= L_P\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-unify-holder-terms.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Unified H\u00f6lder bound for multiple terms\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-component-potential-lipschitz.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-sigma-patch-derivative-bound.json",
      "entity_type": "theorems",
      "error": "  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-single-walker-structural-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Bounds structural error in expected distance for walker i due to companion selection measure change\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-stable-walker-error-decomposition.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Stable walker error decomposes into positional, structural, and own-status components\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-lipschitz-variance-functional.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/cor-pipeline-continuity-margin-stability.json",
      "entity_type": "theorems",
      "error": "  - label: String should match pattern '^(thm|lem|prop)-[a-z0-9-]+$'\n    Input: cor-pipeline-continuity-margin-stability\n  - statement_type: Input should be 'theorem', 'lemma' or 'proposition'\n    Input: TheoremBox\n  - lemma_dag_edges -> 0: Input should be a valid tuple\n  - lemma_dag_edges -> 1: Input should be a valid tuple\n    Input: {'source': 'cor-pipeline-continuity-margin-stability', 'target': 'def-axiom-margin-stability'}"
    },
    {
      "file": "theorems/lem-single-walker-own-status-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Change in expected distance from walker's own status change bounded by D_Y\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/cor-chain-rule-sigma-reg-var.json",
      "entity_type": "theorems",
      "error": "  - label: String should match pattern '^(thm|lem|prop)-[a-z0-9-]+$'\n    Input: cor-chain-rule-sigma-reg-var\n  - statement_type: Input should be 'theorem', 'lemma' or 'proposition'\n    Input: TheoremBox\n  - lemma_dag_edges -> 0: Input should be a valid tuple\n    Input: {'source': 'cor-chain-rule-sigma-reg-var', 'target': 'lem-lipschitz-variance-functional'}\n  - lemma_dag_edges -> 1: Input should be a valid tuple\n    Input: {'source': 'cor-chain-rule-sigma-reg-var', 'target': 'lem-sigma-patch-derivative-bound'}\n  - lemma_dag_edges -> 2: Input should be a valid tuple\n    Input: {'source': 'cor-chain-rule-sigma-reg-var', 'target': 'lem-empirical-aggregator-properties'}"
    },
    {
      "file": "theorems/lem-stats-value-continuity.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Mean and regularized standard deviation are Lipschitz continuous with respect to raw value vector\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-cubic-patch-coefficients.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Coefficients A, B, C, D of cubic patch P(z) are uniquely determined\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Determined by boundary conditions and parameter z_max > 1\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: z_max > 1"
    },
    {
      "file": "theorems/lem-stable-structural-error-bound.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Structural error for stable walkers bounded by status changes\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-validation-heat-kernel.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Heat kernel satisfies boundary regularity conditions\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: Polish metric measure space $(\\mathcal{X}, d_{\\mathcal{X}}, \\mu)$\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n    Input: Heat kernel $p_t(x, \\cdot)$ with uniformly bounded second moment\n  - assumptions -> 2: Input should be a valid dictionary or instance of DualStatement\n    Input: Sufficiently regular boundary of $\\mathcal{X}_{\\mathrm{valid}}$\n  - conclusion: Input should be a valid dictionary or instance of DualStatement"
    },
    {
      "file": "theorems/lem-subadditivity-power.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Subadditivity property for fractional powers with 0 < \u03b1 \u2264 1\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-final-status-change-bound.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Final status change bounded by initial displacement squared\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-final-positional-displacement-bound.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Final positional displacement bounded by initial displacement squared\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-polynomial-patch-monotonicity.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-total-squared-error-stable.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Total squared error from stable walkers is bounded\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-bounded-differences-favg.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Applies to normalized functional f_avg = (1/N)Delta_pert^2(S_in)\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Establishes McDiarmid bounded-difference constants c_i = D_Y^2/N\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-inequality-toolbox.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-empirical-moments-lipschitz.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Empirical mean is Lipschitz: L_{mu,M} = 1/sqrt(k)\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Empirical second moment is Lipschitz: L_{m2,M} = 2V_max/sqrt(k)"
    },
    {
      "file": "theorems/lem-total-clone-prob-structural-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Bounds structural component of cloning probability error by number of status changes\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: Structural error bounded by status changes"
    },
    {
      "file": "theorems/cor-closed-form-lipschitz-composite.json",
      "entity_type": "theorems",
      "error": "  - label: String should match pattern '^(thm|lem|prop)-[a-z0-9-]+$'\n    Input: cor-closed-form-lipschitz-composite\n  - statement_type: Input should be 'theorem', 'lemma' or 'proposition'\n    Input: TheoremBox\n  - lemma_dag_edges -> 0: Input should be a valid tuple\n    Input: {'source': 'cor-closed-form-lipschitz-composite', 'target': 'cor-chain-rule-sigma-reg-var'}\n  - lemma_dag_edges -> 1: Input should be a valid tuple\n    Input: {'source': 'cor-closed-form-lipschitz-composite', 'target': 'thm-rescale-function-lipschitz'}\n  - lemma_dag_edges -> 2: Input should be a valid tuple\n    Input: {'source': 'cor-closed-form-lipschitz-composite', 'target': 'lem-empirical-aggregator-properties'}"
    },
    {
      "file": "theorems/thm-canonical-logistic-validity.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: PROPERTY"
    },
    {
      "file": "theorems/lem-validation-uniform-ball.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Uniform ball distribution satisfies boundary regularity conditions\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: Uniform probability measure over ball $B(x, \\sigma)$\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n    Input: Sufficiently regular boundary (Lipschitz or finite perimeter)\n  - conclusion: Input should be a valid dictionary or instance of DualStatement"
    },
    {
      "file": "theorems/lem-sigma-reg-derivative-bounds.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Bounds on derivatives of regularized standard deviation sigma'_reg\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/thm-deterministic-potential-continuity.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-single-walker-positional-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Bound on error in expected distance measurement from positional displacement\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/thm-mean-square-standardization-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: OTHER\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: The number of alive walkers, k_1 = |A(S_1)|, is large\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: \\mathbb{E}[\\| \\mathbf{z}_1 - \\mathbf{z}_2 \\|_2^2] \\in O(E_{V,ms}^2(k_1)) + O(E_{S,ms}^2(k_1))"
    },
    {
      "file": "theorems/lem-total-clone-prob-value-error.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Bounds value component of cloning probability error\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: Value error bounded by expected potential error"
    },
    {
      "file": "theorems/lem-empirical-aggregator-properties.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-is-valid-swarm-aggregator\n  - relations_established -> 0 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: INSTANTIATION\n  - relations_established -> 0 -> bidirectional: Field required\n  - relations_established -> 0 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 0 -> established_by: Field required\n  - relations_established -> 0 -> expression: Field required\n  - relations_established -> 1 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-value-lipschitz-mean\n  - relations_established -> 1 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 1 -> bidirectional: Field required\n  - relations_established -> 1 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 1 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: L_mu_M\n  - relations_established -> 1 -> established_by: Field required\n  - relations_established -> 2 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-value-lipschitz-m2\n  - relations_established -> 2 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 2 -> bidirectional: Field required\n  - relations_established -> 2 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 2 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: L_m2_M\n  - relations_established -> 2 -> established_by: Field required\n  - relations_established -> 3 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-structural-lipschitz-mean\n  - relations_established -> 3 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 3 -> bidirectional: Field required\n  - relations_established -> 3 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 3 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: L_mu_S\n  - relations_established -> 3 -> established_by: Field required\n  - relations_established -> 4 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-structural-lipschitz-m2\n  - relations_established -> 4 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 4 -> bidirectional: Field required\n  - relations_established -> 4 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 4 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: L_m2_S\n  - relations_established -> 4 -> established_by: Field required\n  - relations_established -> 5 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-variance-deviation-factor\n  - relations_established -> 5 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 5 -> bidirectional: Field required\n  - relations_established -> 5 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 5 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: kappa_var\n  - relations_established -> 5 -> established_by: Field required\n  - relations_established -> 6 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-range-variance-factor\n  - relations_established -> 6 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 6 -> bidirectional: Field required\n  - relations_established -> 6 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 6 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: kappa_range\n  - relations_established -> 6 -> established_by: Field required\n  - relations_established -> 7 -> label: String should match pattern '^rel-[a-z0-9]+(-[a-z0-9]+)*-(equivalence|embedding|approximation|reduction|extension|generalization|specialization|other)$'\n    Input: rel-empirical-aggregator-structural-growth-exponents\n  - relations_established -> 7 -> relationship_type: Input should be 'equivalence', 'embedding', 'approximation', 'reduction', 'extension', 'generalization', 'specialization' or 'other'\n    Input: PROPERTY\n  - relations_established -> 7 -> bidirectional: Field required\n  - relations_established -> 7 -> source_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: empirical-measure-aggregator\n  - relations_established -> 7 -> target_object: String should match pattern '^obj-[a-z0-9-]+$'\n    Input: structural_growth_exponents\n  - relations_established -> 7 -> established_by: Field required\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: Raw values bounded: |v_i| <= V_max for all i\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n    Input: Alive set non-empty: k = |A(S)| >= 1\n  - assumptions -> 2: Input should be a valid dictionary or instance of DualStatement\n    Input: Bounded relative collapse holds: k_2 >= c_min * k_1 for axiom verification\n  - conclusion: Input should be a valid dictionary or instance of DualStatement"
    },
    {
      "file": "theorems/lem-stats-structural-continuity.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Mean and regularized standard deviation are continuous with respect to swarm structure changes\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-total-squared-error-unstable.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Total squared error from unstable walkers bounded by status changes\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/lem-rescale-monotonicity.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/thm-distance-operator-satisfies-bounded-variance-axiom.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-cubic-patch-derivative.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: General Result\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Derivative of cubic patch P(z) is P'(z) = 3Az^2 + 2Bz + C\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: "
    },
    {
      "file": "theorems/thm-pipeline-continuity-margin-stability.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-cubic-patch-uniqueness.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Cubic polynomial with 4 boundary conditions has unique solution via confluent Vandermonde matrix\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: z_max > 1"
    },
    {
      "file": "theorems/lem-boundary-uniform-ball.json",
      "entity_type": "theorems",
      "error": "  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n    Input: Uniform ball death probability P_sigma(x) is Lipschitz continuous\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Lipschitz bound: |P_sigma(x) - P_sigma(y)| <= C_d*Per(E)/sigma*d_X(x,y)\n  - assumptions -> 0: Input should be a valid dictionary or instance of DualStatement\n    Input: $E=\\mathcal{X}_{\\mathrm{invalid}}$ has finite perimeter (BV boundary)\n  - assumptions -> 1: Input should be a valid dictionary or instance of DualStatement\n    Input: $\\mathcal P_\\sigma(x,\\cdot)$ is uniform law on $B(x,\\sigma)$\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: $|P_\\sigma(x)-P_\\sigma(y)| \\le C_d\\,\\frac{\\mathrm{Per}(E)}{\\sigma}\\, d_{\\mathcal X}(x,y)$"
    },
    {
      "file": "theorems/lem-potential-stable-error-mean-square.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity"
    },
    {
      "file": "theorems/thm-cloning-transition-operator-continuity-recorrected.json",
      "entity_type": "theorems",
      "error": "  - document_id: Input should be a valid string\n  - file_path: Input should be a valid string"
    },
    {
      "file": "theorems/lem-cloning-probability-lipschitz.json",
      "entity_type": "theorems",
      "error": "  - output_type: Input should be 'Property', 'Relation', 'Existence', 'Construction', 'Classification', 'Uniqueness', 'Impossibility', 'Embedding', 'Approximation', 'Equivalence', 'Decomposition', 'Extension', 'Reduction', 'Bound', 'Convergence' or 'Contraction'\n    Input: Lipschitz Continuity\n  - relations_established -> 0: Input should be a valid dictionary or instance of Relationship\n  - relations_established -> 1: Input should be a valid dictionary or instance of Relationship\n    Input: Conditional cloning probability pi(v_c, v_i) is Lipschitz continuous\n  - conclusion: Input should be a valid dictionary or instance of DualStatement\n    Input: The cloning probability function is Lipschitz continuous with explicit constants"
    }
  ]
}