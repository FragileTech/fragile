{
  "document_id": "01_fragile_gas_framework",
  "stage": "directives",
  "directive_type": "definition",
  "generated_at": "2025-11-12T08:56:16.996269+00:00",
  "count": 44,
  "items": [
    {
      "directive_type": "definition",
      "label": "def-walker",
      "title": "Walker",
      "start_line": 153,
      "end_line": 165,
      "header_lines": [
        154
      ],
      "content_start": 156,
      "content_end": 164,
      "content": "156: :label: def-walker\n157: \n158: A **walker**, denoted $w$, is a tuple consisting of a position and a status:\n159: \n160: $$\n161: w := (x, s)\n162: $$\n163: \n164: where:",
      "metadata": {
        "label": "def-walker"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "153: :::\n154: \n155: :::{prf:definition} Walker\n156: :label: def-walker\n157: \n158: A **walker**, denoted $w$, is a tuple consisting of a position and a status:\n159: \n160: $$\n161: w := (x, s)\n162: $$\n163: \n164: where:\n165: 1.  $x \\in \\mathcal{X}$ is the walker's **position** in a state space $\\mathcal{X}$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-swarm-and-state-space",
      "title": "Swarm and Swarm State Space",
      "start_line": 180,
      "end_line": 195,
      "header_lines": [
        181
      ],
      "content_start": 183,
      "content_end": 194,
      "content": "183: :label: def-swarm-and-state-space\n184: \n185: A **swarm**, denoted $\\mathcal{S}$, is an N-tuple of walkers:\n186: \n187: $$\n188: \\mathcal{S} := (w_1, w_2, \\dots, w_N)\n189: $$\n190: \n191: The **Swarm State Space**, denoted $\\Sigma_N$, is the set of all possible swarms of size N. It is the N-fold Cartesian product of the single-walker state space:\n192: \n193: $$\n194: \\Sigma_N := (\\mathcal{X} \\times \\{0, 1\\})^N",
      "metadata": {
        "label": "def-swarm-and-state-space"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "180: :::\n181: \n182: :::{prf:definition} Swarm and Swarm State Space\n183: :label: def-swarm-and-state-space\n184: \n185: A **swarm**, denoted $\\mathcal{S}$, is an N-tuple of walkers:\n186: \n187: $$\n188: \\mathcal{S} := (w_1, w_2, \\dots, w_N)\n189: $$\n190: \n191: The **Swarm State Space**, denoted $\\Sigma_N$, is the set of all possible swarms of size N. It is the N-fold Cartesian product of the single-walker state space:\n192: \n193: $$\n194: \\Sigma_N := (\\mathcal{X} \\times \\{0, 1\\})^N\n195: $$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-alive-dead-sets",
      "title": "Alive and Dead Sets",
      "start_line": 199,
      "end_line": 218,
      "header_lines": [
        200
      ],
      "content_start": 202,
      "content_end": 217,
      "content": "202: :label: def-alive-dead-sets\n203: \n204: For any swarm state $\\mathcal{S} = ((x_1, s_1), \\dots, (x_N, s_N)) \\in \\Sigma_N$:\n205: \n206: 1.  The **alive set**, $\\mathcal{A}(\\mathcal{S})$, is the set of indices of all walkers with a survival status of 1.\n207: \n208: \n209: $$\n210: \\mathcal{A}(\\mathcal{S}) := \\{i \\in \\{1, \\dots, N\\} \\mid s_i = 1\\}\n211: $$\n212: \n213: 2.  The **dead set**, $\\mathcal{D}(\\mathcal{S})$, is the set of indices of all walkers with a survival status of 0.\n214: \n215: \n216: $$\n217: \\mathcal{D}(\\mathcal{S}) := \\{i \\in \\{1, \\dots, N\\} \\mid s_i = 0\\}",
      "metadata": {
        "label": "def-alive-dead-sets"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "199: For any swarm $\\mathcal{S}$, we define two critical index sets that partition the walkers based on their survival status.\n200: \n201: :::{prf:definition} Alive and Dead Sets\n202: :label: def-alive-dead-sets\n203: \n204: For any swarm state $\\mathcal{S} = ((x_1, s_1), \\dots, (x_N, s_N)) \\in \\Sigma_N$:\n205: \n206: 1.  The **alive set**, $\\mathcal{A}(\\mathcal{S})$, is the set of indices of all walkers with a survival status of 1.\n207: \n208: \n209: $$\n210: \\mathcal{A}(\\mathcal{S}) := \\{i \\in \\{1, \\dots, N\\} \\mid s_i = 1\\}\n211: $$\n212: \n213: 2.  The **dead set**, $\\mathcal{D}(\\mathcal{S})$, is the set of indices of all walkers with a survival status of 0.\n214: \n215: \n216: $$\n217: \\mathcal{D}(\\mathcal{S}) := \\{i \\in \\{1, \\dots, N\\} \\mid s_i = 0\\}\n218: $$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-valid-state-space",
      "title": "Valid State Space",
      "start_line": 256,
      "end_line": 272,
      "header_lines": [
        257
      ],
      "content_start": 259,
      "content_end": 271,
      "content": "259: :label: def-valid-state-space\n260: \n261: A **Valid State Space** is a tuple $(\\mathcal{X}, d_{\\mathcal{X}}, \\mu_{\\mathcal{X}})$ with the following properties:\n262: \n263: 1.  **Topological Structure:** The space $(\\mathcal{X}, d_{\\mathcal{X}})$ must be a **Polish space** (a complete, separable metric space). This ensures that notions of convergence and probability measures are well-defined.\n264: \n265: 2.  **Measure Structure:** The space must be equipped with a **reference measure** $\\mu_{\\mathcal{X}}$ (e.g., Lebesgue measure for Euclidean spaces, or the Riemannian volume measure for manifolds). This measure is used to define probability densities for the noise kernels.\n266: \n267: 3.  **Existence of Valid Noise:** The space must support a **Valid Noise Measure** ($\\mathcal{P}_\\sigma$ and $\\mathcal{Q}_\\delta$) as per {prf:ref}`def-valid-noise-measure`. This is the most critical functional requirement, as it implies the space has enough geometric regularity to satisfy:\n268:     *   The **Axiom of Bounded Second Moment of Perturbation** ([](#def-axiom-bounded-second-moment-perturbation)).\n269:     *   The **Axiom of Boundary Regularity** ([](#axiom-boundary-regularity)).\n270: \n271: 4.  **Regularity of the Domain:** The **Valid Domain** $\\mathcal{X}_{\\mathrm{valid}} \\subset \\mathcal{X}$ must have a boundary $\\partial \\mathcal{X}_{\\mathrm{valid}}$ that is a null set with respect to any admissible noise measure. For example, if $\\mathcal{X}$ is a smooth manifold, requiring a $C^1$ boundary is sufficient.",
      "metadata": {
        "label": "def-valid-state-space"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [
        "def-valid-noise-measure"
      ],
      "raw_directive": "256: For the analytical framework to be sound, the State Space $(\\mathcal{X}, d_{\\mathcal{X}}, \\mu_{\\mathcal{X}})$ in which walkers evolve must satisfy a set of foundational properties. Any space that meets these criteria is considered a **Valid State Space**.\n257: \n258: :::{prf:definition} Valid State Space\n259: :label: def-valid-state-space\n260: \n261: A **Valid State Space** is a tuple $(\\mathcal{X}, d_{\\mathcal{X}}, \\mu_{\\mathcal{X}})$ with the following properties:\n262: \n263: 1.  **Topological Structure:** The space $(\\mathcal{X}, d_{\\mathcal{X}})$ must be a **Polish space** (a complete, separable metric space). This ensures that notions of convergence and probability measures are well-defined.\n264: \n265: 2.  **Measure Structure:** The space must be equipped with a **reference measure** $\\mu_{\\mathcal{X}}$ (e.g., Lebesgue measure for Euclidean spaces, or the Riemannian volume measure for manifolds). This measure is used to define probability densities for the noise kernels.\n266: \n267: 3.  **Existence of Valid Noise:** The space must support a **Valid Noise Measure** ($\\mathcal{P}_\\sigma$ and $\\mathcal{Q}_\\delta$) as per {prf:ref}`def-valid-noise-measure`. This is the most critical functional requirement, as it implies the space has enough geometric regularity to satisfy:\n268:     *   The **Axiom of Bounded Second Moment of Perturbation** ([](#def-axiom-bounded-second-moment-perturbation)).\n269:     *   The **Axiom of Boundary Regularity** ([](#axiom-boundary-regularity)).\n270: \n271: 4.  **Regularity of the Domain:** The **Valid Domain** $\\mathcal{X}_{\\mathrm{valid}} \\subset \\mathcal{X}$ must have a boundary $\\partial \\mathcal{X}_{\\mathrm{valid}}$ that is a null set with respect to any admissible noise measure. For example, if $\\mathcal{X}$ is a smooth manifold, requiring a $C^1$ boundary is sufficient.\n272: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-reference-measures",
      "title": "Reference Noise and Kernel Families",
      "start_line": 324,
      "end_line": 334,
      "header_lines": [
        325
      ],
      "content_start": 327,
      "content_end": 333,
      "content": "327: :label: def-reference-measures\n328: \n329: - **Perturbation kernels on $\\mathcal{X}$ (dimension $d$):**\n330:   - Gaussian: $\\xi \\sim \\mathcal{N}(0, \\sigma^2 I_d)$ so that $\\mathbb{E}[\\|\\xi\\|_2^2] = d\\,\\sigma^2$.\n331:   - Uniform ball: $\\xi$ uniform on $B_d(0,\\sigma)$ with density $1/\\lambda_d(B_d(0,\\sigma))$.\n332: - **Cloning kernels on $\\mathcal{X}$:** analogously parameterized by $\\delta>0$ (e.g., $\\mathcal{N}(0, \\delta^2 I_d)$ or uniform on $B_d(0,\\delta)$).\n333: - **Smoothing kernels on $\\mathcal{Y}$ (dimension $m$):**",
      "metadata": {
        "label": "def-reference-measures"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "324: :::\n325: \n326: :::{prf:definition} Reference Noise and Kernel Families\n327: :label: def-reference-measures\n328: \n329: - **Perturbation kernels on $\\mathcal{X}$ (dimension $d$):**\n330:   - Gaussian: $\\xi \\sim \\mathcal{N}(0, \\sigma^2 I_d)$ so that $\\mathbb{E}[\\|\\xi\\|_2^2] = d\\,\\sigma^2$.\n331:   - Uniform ball: $\\xi$ uniform on $B_d(0,\\sigma)$ with density $1/\\lambda_d(B_d(0,\\sigma))$.\n332: - **Cloning kernels on $\\mathcal{X}$:** analogously parameterized by $\\delta>0$ (e.g., $\\mathcal{N}(0, \\delta^2 I_d)$ or uniform on $B_d(0,\\delta)$).\n333: - **Smoothing kernels on $\\mathcal{Y}$ (dimension $m$):**\n334:   - Gaussian: $K_\\sigma(y) = (2\\pi\\sigma^2)^{-m/2} \\exp(-\\|y\\|_2^2/(2\\sigma^2))$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-n-particle-displacement-metric",
      "title": "N-Particle Displacement Pseudometric ($d_{\\text{Disp},\\mathcal{Y}}$)",
      "start_line": 416,
      "end_line": 445,
      "header_lines": [
        417,
        436,
        437
      ],
      "content_start": 419,
      "content_end": 444,
      "content": "419: :label: def-n-particle-displacement-metric\n420: \n421: For any two swarms, $\\mathcal{S}_1$ and $\\mathcal{S}_2$, define the (pseudo)metric by\n422: \n423: $$\n424: d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2)\n425: := \\Bigg( \\frac{1}{N} \\sum_{i=1}^N d_{\\mathcal{Y}}\\!\\big(\\varphi(x_{1,i}), \\varphi(x_{2,i})\\big)^2\n426: \\;+\n427: \\; \\frac{\\lambda_{\\mathrm{status}}}{N} \\sum_{i=1}^N (s_{1,i} - s_{2,i})^2 \\Bigg)^{\\!1/2}.\n428: $$\n429: \n430: For algebraic convenience we will frequently write and bound its square,\n431: \n432: $$\n433: d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2)^2\n434: = \\frac{1}{N} \\sum_{i=1}^N d_{\\mathcal{Y}}(\\varphi(x_{1,i}), \\varphi(x_{2,i}))^2 + \\frac{\\lambda_{\\mathrm{status}}}{N} \\sum_{i=1}^N (s_{1,i} - s_{2,i})^2.\n435: $$\n436: \n437: :::{admonition} Breaking Down the Formula\n438: :class: note\n439: :open:\n440: This formula has two parts:\n441: \n442: 1. **Position Changes** (first term): For each walker $i$, measure how far it moved in the algorithmic space, square it, then average over all walkers.\n443: \n444: 2. **Status Changes** (second term): For each walker $i$, check if its status changed (alive ↔ dead). Since status is 0 or 1, $(s_{1,i} - s_{2,i})^2$ equals 1 if status changed, 0 if unchanged. Sum these up and weight by $\\lambda_{\\text{status}}$.",
      "metadata": {
        "label": "def-n-particle-displacement-metric",
        "class": "note",
        "open": ""
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "416: :::\n417: \n418: :::{prf:definition} N-Particle Displacement Pseudometric ($d_{\\text{Disp},\\mathcal{Y}}$)\n419: :label: def-n-particle-displacement-metric\n420: \n421: For any two swarms, $\\mathcal{S}_1$ and $\\mathcal{S}_2$, define the (pseudo)metric by\n422: \n423: $$\n424: d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2)\n425: := \\Bigg( \\frac{1}{N} \\sum_{i=1}^N d_{\\mathcal{Y}}\\!\\big(\\varphi(x_{1,i}), \\varphi(x_{2,i})\\big)^2\n426: \\;+\n427: \\; \\frac{\\lambda_{\\mathrm{status}}}{N} \\sum_{i=1}^N (s_{1,i} - s_{2,i})^2 \\Bigg)^{\\!1/2}.\n428: $$\n429: \n430: For algebraic convenience we will frequently write and bound its square,\n431: \n432: $$\n433: d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2)^2\n434: = \\frac{1}{N} \\sum_{i=1}^N d_{\\mathcal{Y}}(\\varphi(x_{1,i}), \\varphi(x_{2,i}))^2 + \\frac{\\lambda_{\\mathrm{status}}}{N} \\sum_{i=1}^N (s_{1,i} - s_{2,i})^2.\n435: $$\n436: \n437: :::{admonition} Breaking Down the Formula\n438: :class: note\n439: :open:\n440: This formula has two parts:\n441: \n442: 1. **Position Changes** (first term): For each walker $i$, measure how far it moved in the algorithmic space, square it, then average over all walkers.\n443: \n444: 2. **Status Changes** (second term): For each walker $i$, check if its status changed (alive ↔ dead). Since status is 0 or 1, $(s_{1,i} - s_{2,i})^2$ equals 1 if status changed, 0 if unchanged. Sum these up and weight by $\\lambda_{\\text{status}}$.\n445: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-metric-quotient",
      "title": "Metric quotient of $(\\Sigma_N, d_{\\text{Disp},\\mathcal{Y}})$",
      "start_line": 449,
      "end_line": 458,
      "header_lines": [
        450
      ],
      "content_start": 451,
      "content_end": 457,
      "content": "451: :::{prf:definition} Metric quotient of $(\\Sigma_N, d_{\\text{Disp},\\mathcal{Y}})$\n452: :label: def-metric-quotient\n453: Define the equivalence relation $\\mathcal{S}_1\\sim\\mathcal{S}_2$ iff $d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2)=0$. The **metric identification** (Kolmogorov quotient) is $\\overline{\\Sigma}_N := \\Sigma_N/\\!\\sim$ with metric\n454: \n455: $$\n456: \\overline d_{\\text{Disp},\\mathcal{Y}}\\big([\\mathcal{S}_1],[\\mathcal{S}_2]\\big):= d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2),\n457: $$",
      "metadata": {
        "label": "def-metric-quotient"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "449: #### 1.6.1 Metric identification (Kolmogorov quotient)\n450: \n451: :::{prf:definition} Metric quotient of $(\\Sigma_N, d_{\\text{Disp},\\mathcal{Y}})$\n452: :label: def-metric-quotient\n453: Define the equivalence relation $\\mathcal{S}_1\\sim\\mathcal{S}_2$ iff $d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2)=0$. The **metric identification** (Kolmogorov quotient) is $\\overline{\\Sigma}_N := \\Sigma_N/\\!\\sim$ with metric\n454: \n455: $$\n456: \\overline d_{\\text{Disp},\\mathcal{Y}}\\big([\\mathcal{S}_1],[\\mathcal{S}_2]\\big):= d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2),\n457: $$\n458: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-displacement-components",
      "title": "Components of Swarm Displacement",
      "start_line": 509,
      "end_line": 522,
      "header_lines": [
        510
      ],
      "content_start": 512,
      "content_end": 521,
      "content": "512: :label: def-displacement-components\n513: \n514: For any two swarms, $\\mathcal{S}_1$ and $\\mathcal{S}_2$, their total displacement is decomposed into two fundamental components:\n515: \n516: 1.  **The Squared Positional Displacement ($\\Delta_{\\text{pos}}^2$):** The sum of squared distances between corresponding walkers in the algorithmic space.\n517: \n518: $$\n519: \\Delta_{\\text{pos}}^2(\\mathcal{S}_1, \\mathcal{S}_2) := \\sum_{i=1}^N d_{\\mathcal{Y}}(\\varphi(x_{1,i}), \\varphi(x_{2,i}))^2\n520: $$\n521: ",
      "metadata": {
        "label": "def-displacement-components"
      },
      "section": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters",
      "references": [],
      "raw_directive": "509: This section formally defines the two components of swarm displacement that will be used as inputs to the generalized continuity axioms.\n510: \n511: :::{prf:definition} Components of Swarm Displacement\n512: :label: def-displacement-components\n513: \n514: For any two swarms, $\\mathcal{S}_1$ and $\\mathcal{S}_2$, their total displacement is decomposed into two fundamental components:\n515: \n516: 1.  **The Squared Positional Displacement ($\\Delta_{\\text{pos}}^2$):** The sum of squared distances between corresponding walkers in the algorithmic space.\n517: \n518: $$\n519: \\Delta_{\\text{pos}}^2(\\mathcal{S}_1, \\mathcal{S}_2) := \\sum_{i=1}^N d_{\\mathcal{Y}}(\\varphi(x_{1,i}), \\varphi(x_{2,i}))^2\n520: $$\n521: \n522: :::{hint}",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 2,
        "chapter_file": "chapter_2.json",
        "section_id": "## 2. Global Conventions: Foundational Objects and Core Algorithmic Parameters"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-valid-noise-measure",
      "title": "Valid Noise Measure",
      "start_line": 834,
      "end_line": 843,
      "header_lines": [
        835
      ],
      "content_start": 836,
      "content_end": 842,
      "content": "836: :::{prf:definition} Valid Noise Measure\n837: :label: def-valid-noise-measure\n838: A kernel $\\mathcal P_\\sigma$ (and analogously $\\mathcal Q_\\delta$) is valid if it is Feller and satisfies:\n839: - Bounded second moment in $\\mathcal Y$ with constant $M_{\\mathrm{pert}}^2$ (as used in the perturbation continuity bounds);\n840: - Boundary regularity assumptions required by the status‑continuity theorem (Section 14);\n841: - Non‑degeneracy as stipulated where needed.\n842: This consolidates the standing noise requirements referenced elsewhere in the framework.",
      "metadata": {
        "label": "def-valid-noise-measure"
      },
      "section": "## 3. Axiomatic Foundations: A Parametric Debugging Framework",
      "references": [
        "def-valid-state-space",
        "def-perturbation-measure",
        "def-cloning-measure"
      ],
      "raw_directive": "834: ### 2.3 Algorithmic & Operator Axioms: Parameters of Dynamic Behavior\n835: \n836: :::{prf:definition} Valid Noise Measure\n837: :label: def-valid-noise-measure\n838: A kernel $\\mathcal P_\\sigma$ (and analogously $\\mathcal Q_\\delta$) is valid if it is Feller and satisfies:\n839: - Bounded second moment in $\\mathcal Y$ with constant $M_{\\mathrm{pert}}^2$ (as used in the perturbation continuity bounds);\n840: - Boundary regularity assumptions required by the status‑continuity theorem (Section 14);\n841: - Non‑degeneracy as stipulated where needed.\n842: This consolidates the standing noise requirements referenced elsewhere in the framework.\n843: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 3,
        "chapter_file": "chapter_3.json",
        "section_id": "## 3. Axiomatic Foundations: A Parametric Debugging Framework"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-components-mean-square-standardization-error",
      "title": "Components of Mean-Square Standardization Error",
      "start_line": 886,
      "end_line": 894,
      "header_lines": [
        887
      ],
      "content_start": 889,
      "content_end": 893,
      "content": "889: :label: def-components-mean-square-standardization-error\n890: \n891: The total expected squared error of the standardization operator, $\\mathbb{E}[\\|\\mathbf{z}(\\mathcal{S}_1, V, M) - \\mathbf{z}(\\mathcal{S}_2, V, M)\\|_2^2]$, is bounded by the sum of two components:\n892: \n893: 1.  **The Expected Squared Value Error ($E^2_{V,ms}$):** The error arising from the change in the raw value vector's probability distribution (from $V(\\mathcal{S}_1)$ to $V(\\mathcal{S}_2)$) while the swarm's structure is held fixed at $\\mathcal{S}_1$. This component quantifies the propagation of measurement stochasticity.",
      "metadata": {
        "label": "def-components-mean-square-standardization-error"
      },
      "section": "## 3. Axiomatic Foundations: A Parametric Debugging Framework",
      "references": [],
      "raw_directive": "886: To formalize this analysis, we first define the two fundamental and independent sources of error that contribute to the total mean-square error.\n887: \n888: :::{prf:definition} Components of Mean-Square Standardization Error\n889: :label: def-components-mean-square-standardization-error\n890: \n891: The total expected squared error of the standardization operator, $\\mathbb{E}[\\|\\mathbf{z}(\\mathcal{S}_1, V, M) - \\mathbf{z}(\\mathcal{S}_2, V, M)\\|_2^2]$, is bounded by the sum of two components:\n892: \n893: 1.  **The Expected Squared Value Error ($E^2_{V,ms}$):** The error arising from the change in the raw value vector's probability distribution (from $V(\\mathcal{S}_1)$ to $V(\\mathcal{S}_2)$) while the swarm's structure is held fixed at $\\mathcal{S}_1$. This component quantifies the propagation of measurement stochasticity.\n894: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 3,
        "chapter_file": "chapter_3.json",
        "section_id": "## 3. Axiomatic Foundations: A Parametric Debugging Framework"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-reward-measurement",
      "title": "Reward Measurement",
      "start_line": 1115,
      "end_line": 1122,
      "header_lines": [
        1116
      ],
      "content_start": 1117,
      "content_end": 1121,
      "content": "1117: :label: def-reward-measurement\n1118: The reward value $r_i$ for walker $i$ at position $x_i$ is the result of integrating the global Reward Function $R$ against the walker's **positional measure**, which is the Dirac delta measure $\\delta_{x_i}$ on $\\mathcal{X}$.\n1119: $$\n1120: r_i := \\mathbb{E}_{\\delta_{x_i}}[R] = \\int_{\\mathcal{X}} R(x) \\, d\\delta_{x_i}(x) = R(x_i)\n1121: $$",
      "metadata": {
        "label": "def-reward-measurement"
      },
      "section": "## 4. The Environment: State and Reward Measurement",
      "references": [],
      "raw_directive": "1115: A walker determines the value of its location by evaluating the global Reward Function.\n1116: :::{prf:definition} Reward Measurement\n1117: :label: def-reward-measurement\n1118: The reward value $r_i$ for walker $i$ at position $x_i$ is the result of integrating the global Reward Function $R$ against the walker's **positional measure**, which is the Dirac delta measure $\\delta_{x_i}$ on $\\mathcal{X}$.\n1119: $$\n1120: r_i := \\mathbb{E}_{\\delta_{x_i}}[R] = \\int_{\\mathcal{X}} R(x) \\, d\\delta_{x_i}(x) = R(x_i)\n1121: $$\n1122: This formalizes the act of \"evaluating the reward\" as a measurement process.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 4,
        "chapter_file": "chapter_4.json",
        "section_id": "## 4. The Environment: State and Reward Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-perturbation-measure",
      "title": "Perturbation Measure",
      "start_line": 1127,
      "end_line": 1130,
      "header_lines": [
        1128
      ],
      "content_start": 1129,
      "content_end": 1129,
      "content": "1129: :label: def-perturbation-measure",
      "metadata": {
        "label": "def-perturbation-measure"
      },
      "section": "## 5. Algorithmic Noise Measures",
      "references": [
        "def-valid-noise-measure"
      ],
      "raw_directive": "1127: The algorithm uses two distinct noise measures, both of which are required to be instantiations of a Valid Noise Measure.\n1128: :::{prf:definition} Perturbation Measure\n1129: :label: def-perturbation-measure\n1130: For a given noise scale $\\sigma > 0$, the **Perturbation Measure**, $\\mathcal{P}_\\sigma(x, \\cdot)$, is a **Valid Noise Measure** according to {prf:ref}`def-valid-noise-measure`. It governs the random walks during the perturbation step of the algorithm.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 5,
        "chapter_file": "chapter_5.json",
        "section_id": "## 5. Algorithmic Noise Measures"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-cloning-measure",
      "title": "Cloning Measure",
      "start_line": 1131,
      "end_line": 1134,
      "header_lines": [
        1132
      ],
      "content_start": 1133,
      "content_end": 1133,
      "content": "1133: :label: def-cloning-measure",
      "metadata": {
        "label": "def-cloning-measure"
      },
      "section": "## 5. Algorithmic Noise Measures",
      "references": [
        "def-valid-noise-measure"
      ],
      "raw_directive": "1131: :::\n1132: :::{prf:definition} Cloning Measure\n1133: :label: def-cloning-measure\n1134: For a given cloning noise scale $\\delta > 0$, the **Cloning Measure**, $\\mathcal{Q}_\\delta(x, \\cdot)$, is a **Valid Noise Measure** according to {prf:ref}`def-valid-noise-measure`. It governs the displacement for newly created walkers during the cloning step.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 5,
        "chapter_file": "chapter_5.json",
        "section_id": "## 5. Algorithmic Noise Measures"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-algorithmic-space-generic",
      "title": "Algorithmic Space",
      "start_line": 1227,
      "end_line": 1230,
      "header_lines": [
        1228
      ],
      "content_start": 1229,
      "content_end": 1229,
      "content": "1229: :label: def-algorithmic-space-generic",
      "metadata": {
        "label": "def-algorithmic-space-generic"
      },
      "section": "## 6. Algorithm Space and Distance Measurement",
      "references": [],
      "raw_directive": "1227: ### 6.1 Specification of the Algorithmic Space\n1228: :::{prf:definition} Algorithmic Space\n1229: :label: def-algorithmic-space-generic\n1230: An **algorithmic space** is a pair $(\\mathcal{Y}, d_{\\mathcal{Y}})$ consisting of a real vector space $\\mathcal{Y}$ and a true metric $d_{\\mathcal{Y}}$ on $\\mathcal{Y}$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 6,
        "chapter_file": "chapter_6.json",
        "section_id": "## 6. Algorithm Space and Distance Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-distance-positional-measures",
      "title": "Distance Between Positional Measures",
      "start_line": 1233,
      "end_line": 1243,
      "header_lines": [
        1234
      ],
      "content_start": 1235,
      "content_end": 1242,
      "content": "1235: :label: def-distance-positional-measures\n1236: Let two walkers, $i$ and $j$, have their positions represented by the Dirac positional measures $\\delta_{x_i}$ and $\\delta_{x_j}$. The distance between them in the algorithmic space is the **1-Wasserstein distance ($W_1$)** between their **projected positional measures**, with $d_{\\mathcal{Y}}$ as the ground metric.\n1237: The projected positional measure for walker $i$ is the pushforward measure $\\varphi_* \\delta_{x_i} = \\delta_{\\varphi(x_i)}$. The distance is then:\n1238: $$\n1239: \n1240: d(\\varphi_* \\delta_{x_i}, \\varphi_* \\delta_{x_j}) := W_1(\\delta_{\\varphi(x_i)}, \\delta_{\\varphi(x_j)})\n1241: \n1242: $$",
      "metadata": {
        "label": "def-distance-positional-measures"
      },
      "section": "## 6. Algorithm Space and Distance Measurement",
      "references": [],
      "raw_directive": "1233: The distance between two walkers is formally defined as the distance between the probability measures representing their positions.\n1234: :::{prf:definition} Distance Between Positional Measures\n1235: :label: def-distance-positional-measures\n1236: Let two walkers, $i$ and $j$, have their positions represented by the Dirac positional measures $\\delta_{x_i}$ and $\\delta_{x_j}$. The distance between them in the algorithmic space is the **1-Wasserstein distance ($W_1$)** between their **projected positional measures**, with $d_{\\mathcal{Y}}$ as the ground metric.\n1237: The projected positional measure for walker $i$ is the pushforward measure $\\varphi_* \\delta_{x_i} = \\delta_{\\varphi(x_i)}$. The distance is then:\n1238: $$\n1239: \n1240: d(\\varphi_* \\delta_{x_i}, \\varphi_* \\delta_{x_j}) := W_1(\\delta_{\\varphi(x_i)}, \\delta_{\\varphi(x_j)})\n1241: \n1242: $$\n1243: For Dirac measures, the Wasserstein distance simplifies to the ground metric distance between their points of support.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 6,
        "chapter_file": "chapter_6.json",
        "section_id": "## 6. Algorithm Space and Distance Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-alg-distance",
      "title": "Algorithmic Distance",
      "start_line": 1245,
      "end_line": 1254,
      "header_lines": [
        1246
      ],
      "content_start": 1247,
      "content_end": 1253,
      "content": "1247: :label: def-alg-distance\n1248: The **algorithmic distance** $d_{\\text{alg}}\\colon\\mathcal{X}\\times\\mathcal{X}\\to\\mathbb{R}_{\\ge0}$ is the distance between the projected positional measures of two walkers. In practice, this is the distance or semidistance function $d_{\\mathcal{Y}}$ applied to the projected points in the algorithmic space:\n1249: $$\n1250: \n1251: \\boxed{d_{\\text{alg}}(x_1, x_2) := d_{\\mathcal{Y}}(\\varphi(x_1), \\varphi(x_2))}\n1252: \n1253: $$",
      "metadata": {
        "label": "def-alg-distance"
      },
      "section": "## 6. Algorithm Space and Distance Measurement",
      "references": [],
      "raw_directive": "1245: ### 6.3 Algorithmic Distance\n1246: :::{prf:definition} Algorithmic Distance\n1247: :label: def-alg-distance\n1248: The **algorithmic distance** $d_{\\text{alg}}\\colon\\mathcal{X}\\times\\mathcal{X}\\to\\mathbb{R}_{\\ge0}$ is the distance between the projected positional measures of two walkers. In practice, this is the distance or semidistance function $d_{\\mathcal{Y}}$ applied to the projected points in the algorithmic space:\n1249: $$\n1250: \n1251: \\boxed{d_{\\text{alg}}(x_1, x_2) := d_{\\mathcal{Y}}(\\varphi(x_1), \\varphi(x_2))}\n1252: \n1253: $$\n1254: This is the practical implementation of the Wasserstein distance between the walkers' projected Dirac measures and serves as the ground distance for all subsequent calculations.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 6,
        "chapter_file": "chapter_6.json",
        "section_id": "## 6. Algorithm Space and Distance Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-swarm-aggregation-operator-axiomatic",
      "title": "Swarm Aggregation Operator",
      "start_line": 1286,
      "end_line": 1312,
      "header_lines": [
        1287
      ],
      "content_start": 1288,
      "content_end": 1311,
      "content": "1288: :label: def-swarm-aggregation-operator-axiomatic\n1289: A **Swarm Aggregation Operator**, denoted $M$, is a function that maps a swarm state $\\mathcal{S}$ and a raw value vector $\\mathbf{v}$ (defined on the alive set $\\mathcal{A}(\\mathcal{S})$) to a probability measure $\\mu_{\\mathbf{v}}$ on $\\mathbb{R}$.\n1290: **Signature:** $M: \\Sigma_N \\times \\mathbb{R}^{|\\mathcal{A}(\\mathcal{S})|} \\to \\mathcal{P}(\\mathbb{R})$\n1291: For the operator to be valid, it must satisfy the foundational axioms for aggregators defined in Section 2.3.4. Furthermore, the user must provide proofs and explicit functions for the following continuity and structural properties.\n1292: 1.  **Value Continuity (Lipschitz):** For a fixed swarm structure $\\mathcal{S}$, the moment functions must be Lipschitz continuous with respect to the L2-norm of the input value vector $\\mathbf{v}$. The user must provide the **Value Lipschitz Functions**, $L_{\\mu,M}(\\mathcal{S})$ and $L_{m_2,M}(\\mathcal{S})$, such that for any two value vectors $\\mathbf{v}_1, \\mathbf{v}_2$:\n1293: \n1294: $$\n1295: |\\mu(\\mathcal{S}, \\mathbf{v}_1) - \\mu(\\mathcal{S}, \\mathbf{v}_2)| \\le L_{\\mu,M}(\\mathcal{S}) \\cdot \\|\\mathbf{v}_1 - \\mathbf{v}_2\\|_2\n1296: $$\n1297: $$\n1298: |m_2(\\mathcal{S}, \\mathbf{v}_1) - m_2(\\mathcal{S}, \\mathbf{v}_2)| \\le L_{m_2,M}(\\mathcal{S}) \\cdot \\|\\mathbf{v}_1 - \\mathbf{v}_2\\|_2\n1299: $$\n1300: \n1301: 2.  **Structural Continuity (Quadratic):** For a fixed value vector $\\mathbf{v}$, the change in the moment functions due to a change in the swarm's alive set must be bounded. The user must provide the **Structural Continuity Functions**, $L_{\\mu,S}(\\mathcal{S}_1, \\mathcal{S}_2)$ and $L_{m_2,S}(\\mathcal{S}_1, \\mathcal{S}_2)$, which may depend on both the initial and final swarm states. These functions must satisfy the following inequalities for any two swarms $\\mathcal{S}_1, \\mathcal{S}_2$:\n1302: \n1303: $$\n1304: |\\mu(\\mathcal{S}_1, \\mathbf{v}) - \\mu(\\mathcal{S}_2, \\mathbf{v})| \\le L_{\\mu,S}(\\mathcal{S}_1, \\mathcal{S}_2) \\cdot \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2\n1305: $$\n1306: \n1307: $$\n1308: |m_2(\\mathcal{S}_1, \\mathbf{v}) - m_2(\\mathcal{S}_2, \\mathbf{v})| \\le L_{m_2,S}(\\mathcal{S}_1, \\mathcal{S}_2) \\cdot \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2\n1309: $$\n1310: *Note: The structural continuity is defined with respect to the squared L2-norm of the status change vector. For notational convenience in subsequent sections, we define the **total number of status changes** between two swarms as $n_c := \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2 = \\sum_{j=1}^N (s_{1,j} - s_{2,j})^2$. This quadratic form is a natural choice because the error in common aggregators (like the empirical mean) is directly proportional to the number of added or removed data points, not its square root.*\n1311: :::{hint}",
      "metadata": {
        "label": "def-swarm-aggregation-operator-axiomatic"
      },
      "section": "## 7. Swarm Measuring",
      "references": [],
      "raw_directive": "1286: #### 7.2.1 Definition: Swarm Aggregation Operator\n1287: :::{prf:definition} Swarm Aggregation Operator\n1288: :label: def-swarm-aggregation-operator-axiomatic\n1289: A **Swarm Aggregation Operator**, denoted $M$, is a function that maps a swarm state $\\mathcal{S}$ and a raw value vector $\\mathbf{v}$ (defined on the alive set $\\mathcal{A}(\\mathcal{S})$) to a probability measure $\\mu_{\\mathbf{v}}$ on $\\mathbb{R}$.\n1290: **Signature:** $M: \\Sigma_N \\times \\mathbb{R}^{|\\mathcal{A}(\\mathcal{S})|} \\to \\mathcal{P}(\\mathbb{R})$\n1291: For the operator to be valid, it must satisfy the foundational axioms for aggregators defined in Section 2.3.4. Furthermore, the user must provide proofs and explicit functions for the following continuity and structural properties.\n1292: 1.  **Value Continuity (Lipschitz):** For a fixed swarm structure $\\mathcal{S}$, the moment functions must be Lipschitz continuous with respect to the L2-norm of the input value vector $\\mathbf{v}$. The user must provide the **Value Lipschitz Functions**, $L_{\\mu,M}(\\mathcal{S})$ and $L_{m_2,M}(\\mathcal{S})$, such that for any two value vectors $\\mathbf{v}_1, \\mathbf{v}_2$:\n1293: \n1294: $$\n1295: |\\mu(\\mathcal{S}, \\mathbf{v}_1) - \\mu(\\mathcal{S}, \\mathbf{v}_2)| \\le L_{\\mu,M}(\\mathcal{S}) \\cdot \\|\\mathbf{v}_1 - \\mathbf{v}_2\\|_2\n1296: $$\n1297: $$\n1298: |m_2(\\mathcal{S}, \\mathbf{v}_1) - m_2(\\mathcal{S}, \\mathbf{v}_2)| \\le L_{m_2,M}(\\mathcal{S}) \\cdot \\|\\mathbf{v}_1 - \\mathbf{v}_2\\|_2\n1299: $$\n1300: \n1301: 2.  **Structural Continuity (Quadratic):** For a fixed value vector $\\mathbf{v}$, the change in the moment functions due to a change in the swarm's alive set must be bounded. The user must provide the **Structural Continuity Functions**, $L_{\\mu,S}(\\mathcal{S}_1, \\mathcal{S}_2)$ and $L_{m_2,S}(\\mathcal{S}_1, \\mathcal{S}_2)$, which may depend on both the initial and final swarm states. These functions must satisfy the following inequalities for any two swarms $\\mathcal{S}_1, \\mathcal{S}_2$:\n1302: \n1303: $$\n1304: |\\mu(\\mathcal{S}_1, \\mathbf{v}) - \\mu(\\mathcal{S}_2, \\mathbf{v})| \\le L_{\\mu,S}(\\mathcal{S}_1, \\mathcal{S}_2) \\cdot \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2\n1305: $$\n1306: \n1307: $$\n1308: |m_2(\\mathcal{S}_1, \\mathbf{v}) - m_2(\\mathcal{S}_2, \\mathbf{v})| \\le L_{m_2,S}(\\mathcal{S}_1, \\mathcal{S}_2) \\cdot \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2\n1309: $$\n1310: *Note: The structural continuity is defined with respect to the squared L2-norm of the status change vector. For notational convenience in subsequent sections, we define the **total number of status changes** between two swarms as $n_c := \\|\\mathbf{s}_1 - \\mathbf{s}_2\\|_2^2 = \\sum_{j=1}^N (s_{1,j} - s_{2,j})^2$. This quadratic form is a natural choice because the error in common aggregators (like the empirical mean) is directly proportional to the number of added or removed data points, not its square root.*\n1311: :::{hint}\n1312: Why quadratic dependence on status changes? When a walker dies or revives, it's like suddenly adding or removing a data point from your dataset. The resulting error in statistics (like the mean) jumps discontinuously. The quadratic form $n_c$ counts these discontinuous jumps, making it the natural measure for how much the aggregated statistics can change.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 7,
        "chapter_file": "chapter_7.json",
        "section_id": "## 7. Swarm Measuring"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-smoothed-gaussian-measure",
      "title": "Smoothed Gaussian Measure",
      "start_line": 1438,
      "end_line": 1448,
      "header_lines": [
        1439
      ],
      "content_start": 1440,
      "content_end": 1447,
      "content": "1440: :label: def-smoothed-gaussian-measure\n1441: The creation of a smoothed measure requires a key analytical parameter:\n1442: *   **Smoothed Measure Kernel Scale ($\\ell$):** The length scale (standard deviation), $\\ell > 0$, of the Gaussian kernel used for smoothing. A larger $\\ell$ results in a smoother, less detailed density estimate.\n1443: Let $K_\\ell(y, y')$ be a Gaussian kernel with length scale $\\ell$. The **smoothed Gaussian measure**, denoted $\\tilde{\\nu}_{\\mathcal{S}, \\ell}$, is the probability measure whose density is given by:\n1444: \n1445: $$\n1446: \\tilde{\\rho}_{\\mathcal{S}, \\ell}(y) := \\frac{1}{|\\mathcal{A}(\\mathcal{S})|} \\sum_{i \\in \\mathcal{A}(\\mathcal{S})} K_\\ell(y, \\varphi(x_i))\n1447: $$",
      "metadata": {
        "label": "def-smoothed-gaussian-measure"
      },
      "section": "## 7. Swarm Measuring",
      "references": [],
      "raw_directive": "1438: For analyses where the precise locations of individual walkers are less important than their overall density, we represent the swarm's state using a kernel density estimate.\n1439: :::{prf:definition} Smoothed Gaussian Measure\n1440: :label: def-smoothed-gaussian-measure\n1441: The creation of a smoothed measure requires a key analytical parameter:\n1442: *   **Smoothed Measure Kernel Scale ($\\ell$):** The length scale (standard deviation), $\\ell > 0$, of the Gaussian kernel used for smoothing. A larger $\\ell$ results in a smoother, less detailed density estimate.\n1443: Let $K_\\ell(y, y')$ be a Gaussian kernel with length scale $\\ell$. The **smoothed Gaussian measure**, denoted $\\tilde{\\nu}_{\\mathcal{S}, \\ell}$, is the probability measure whose density is given by:\n1444: \n1445: $$\n1446: \\tilde{\\rho}_{\\mathcal{S}, \\ell}(y) := \\frac{1}{|\\mathcal{A}(\\mathcal{S})|} \\sum_{i \\in \\mathcal{A}(\\mathcal{S})} K_\\ell(y, \\varphi(x_i))\n1447: $$\n1448: This representation provides a smooth, differentiable approximation of the swarm's distribution in the algorithmic space and is the foundation for the $d_{\\Sigma_N, L_2}$ distance.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 7,
        "chapter_file": "chapter_7.json",
        "section_id": "## 7. Swarm Measuring"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-algorithmic-cemetery-extension",
      "title": "Algorithmic space with cemetery point",
      "start_line": 1451,
      "end_line": 1460,
      "header_lines": [
        1452
      ],
      "content_start": 1453,
      "content_end": 1459,
      "content": "1453: :label: def-algorithmic-cemetery-extension\n1454: Define $\\mathcal{Y}^{\\dagger}:=\\mathcal{Y}\\cup\\{\\dagger\\}$ with metric $d_\\dagger$ given by\n1455: $$\n1456: \n1457: d_\\dagger(y_1,y_2)=d_{\\mathcal{Y}}(y_1,y_2),\\quad d_\\dagger(y,\\dagger)=D_{\\mathrm{valid}}\\quad \\text{for all }y\\in\\mathcal{Y}.\n1458: \n1459: $$",
      "metadata": {
        "label": "def-algorithmic-cemetery-extension"
      },
      "section": "## 7. Swarm Measuring",
      "references": [],
      "raw_directive": "1451: To ensure that our swarm metrics are well-defined for all possible outcomes, including the absorption of the swarm into the cemetery state, we must formally define its distributional representation. This is achieved by introducing a unique, abstract measure that represents this terminal state.\n1452: :::{prf:definition} Algorithmic space with cemetery point\n1453: :label: def-algorithmic-cemetery-extension\n1454: Define $\\mathcal{Y}^{\\dagger}:=\\mathcal{Y}\\cup\\{\\dagger\\}$ with metric $d_\\dagger$ given by\n1455: $$\n1456: \n1457: d_\\dagger(y_1,y_2)=d_{\\mathcal{Y}}(y_1,y_2),\\quad d_\\dagger(y,\\dagger)=D_{\\mathrm{valid}}\\quad \\text{for all }y\\in\\mathcal{Y}.\n1458: \n1459: $$\n1460: Identifying a dead walker with the point $\\dagger$ makes the Wasserstein distance to the cemetery law canonical: for any living swarm law $\\nu$ and the cemetery $\\delta_{\\dagger}$ we have $W_p(\\nu,\\delta_{\\dagger})=D_{\\mathrm{valid}}$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 7,
        "chapter_file": "chapter_7.json",
        "section_id": "## 7. Swarm Measuring"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-cemetery-state-measure",
      "title": "Cemetery State Measure",
      "start_line": 1465,
      "end_line": 1471,
      "header_lines": [
        1466
      ],
      "content_start": 1467,
      "content_end": 1470,
      "content": "1467: :label: def-cemetery-state-measure\n1468: Let $\\mathcal{S}$ be a swarm. Its distributional representation, denoted $\\mu_{\\mathcal{S}}$, is defined as:\n1469: 1.  If $|\\mathcal{A}(\\mathcal{S})| > 0$, $\\mu_{\\mathcal{S}}$ is the empirical or smoothed measure as defined in 5.1 and 5.2 (i.e., $\\mu_{\\mathcal{S}} = \\nu_{\\mathcal{S}}$ or $\\mu_{\\mathcal{S}} = \\tilde{\\nu}_{\\mathcal{S}, \\ell}$).\n1470: 2.  If $|\\mathcal{A}(\\mathcal{S})| = 0$, its representation is the unique **Cemetery State Measure**, denoted $\\mu_{\\mathcal{S}} := \\nu_{\\emptyset}$.",
      "metadata": {
        "label": "def-cemetery-state-measure"
      },
      "section": "## 7. Swarm Measuring",
      "references": [],
      "raw_directive": "1465: :::\n1466: :::{prf:definition} Cemetery State Measure\n1467: :label: def-cemetery-state-measure\n1468: Let $\\mathcal{S}$ be a swarm. Its distributional representation, denoted $\\mu_{\\mathcal{S}}$, is defined as:\n1469: 1.  If $|\\mathcal{A}(\\mathcal{S})| > 0$, $\\mu_{\\mathcal{S}}$ is the empirical or smoothed measure as defined in 5.1 and 5.2 (i.e., $\\mu_{\\mathcal{S}} = \\nu_{\\mathcal{S}}$ or $\\mu_{\\mathcal{S}} = \\tilde{\\nu}_{\\mathcal{S}, \\ell}$).\n1470: 2.  If $|\\mathcal{A}(\\mathcal{S})| = 0$, its representation is the unique **Cemetery State Measure**, denoted $\\mu_{\\mathcal{S}} := \\nu_{\\emptyset}$.\n1471: The Cemetery State Measure $\\nu_{\\emptyset}$ is an abstract object that does not have a density on $\\mathcal{Y}$. Its properties are defined entirely by its interaction with the distance functions used in the swarm metrics.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 7,
        "chapter_file": "chapter_7.json",
        "section_id": "## 7. Swarm Measuring"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-distance-to-cemetery-state",
      "title": "Distance to the Cemetery State",
      "start_line": 1472,
      "end_line": 1486,
      "header_lines": [
        1473
      ],
      "content_start": 1474,
      "content_end": 1485,
      "content": "1474: :label: def-distance-to-cemetery-state\n1475: The distance between any valid probability measure $\\nu$ (representing a living swarm) and the Cemetery State Measure $\\nu_{\\emptyset}$ is defined to be a maximal constant, ensuring that entering the cemetery state represents the largest possible jump in distributional terms.\n1476: *   **For the Wasserstein Metric:** Using [](#def-algorithmic-cemetery-extension), for any measure $\\nu$ corresponding to a living swarm:\n1477: \n1478: $$\n1479:     W_p(\\nu, \\nu_{\\emptyset}) := D_{\\mathrm{valid}} \\quad \\text{and} \\quad W_p(\\nu_{\\emptyset}, \\nu_{\\emptyset}) := 0\n1480: $$\n1481: *   **For the MMD (on living swarms):** We evaluate $\\mathrm{MMD}_k$ only between measures supported on $\\mathcal Y$ (living swarms). No cemetery extension is defined here. If an extension is required, one must specify an explicit positive‑definite kernel $k^{\\dagger}$ on $\\mathcal Y^{\\dagger}$ that yields the desired constant distances while preserving metric properties. When $k$ is characteristic (e.g., Gaussian/RBF), MMD is a true metric on probability measures over $\\mathcal Y$.\n1482: *   **For the $L_2$ Distance:** The distance is a pre-defined maximal value $M_{L2}$ for the norm. For any density $\\tilde{\\rho}$ corresponding to a living swarm:\n1483: \n1484: $$\n1485:     \\|\\tilde{\\rho} - \\tilde{\\rho}_{\\emptyset}\\|_{L_2} := M_{L2} \\quad \\text{and} \\quad \\|\\tilde{\\rho}_{\\emptyset} - \\tilde{\\rho}_{\\emptyset}\\|_{L2} := 0",
      "metadata": {
        "label": "def-distance-to-cemetery-state"
      },
      "section": "## 7. Swarm Measuring",
      "references": [],
      "raw_directive": "1472: :::\n1473: :::{prf:definition} Distance to the Cemetery State\n1474: :label: def-distance-to-cemetery-state\n1475: The distance between any valid probability measure $\\nu$ (representing a living swarm) and the Cemetery State Measure $\\nu_{\\emptyset}$ is defined to be a maximal constant, ensuring that entering the cemetery state represents the largest possible jump in distributional terms.\n1476: *   **For the Wasserstein Metric:** Using [](#def-algorithmic-cemetery-extension), for any measure $\\nu$ corresponding to a living swarm:\n1477: \n1478: $$\n1479:     W_p(\\nu, \\nu_{\\emptyset}) := D_{\\mathrm{valid}} \\quad \\text{and} \\quad W_p(\\nu_{\\emptyset}, \\nu_{\\emptyset}) := 0\n1480: $$\n1481: *   **For the MMD (on living swarms):** We evaluate $\\mathrm{MMD}_k$ only between measures supported on $\\mathcal Y$ (living swarms). No cemetery extension is defined here. If an extension is required, one must specify an explicit positive‑definite kernel $k^{\\dagger}$ on $\\mathcal Y^{\\dagger}$ that yields the desired constant distances while preserving metric properties. When $k$ is characteristic (e.g., Gaussian/RBF), MMD is a true metric on probability measures over $\\mathcal Y$.\n1482: *   **For the $L_2$ Distance:** The distance is a pre-defined maximal value $M_{L2}$ for the norm. For any density $\\tilde{\\rho}$ corresponding to a living swarm:\n1483: \n1484: $$\n1485:     \\|\\tilde{\\rho} - \\tilde{\\rho}_{\\emptyset}\\|_{L_2} := M_{L2} \\quad \\text{and} \\quad \\|\\tilde{\\rho}_{\\emptyset} - \\tilde{\\rho}_{\\emptyset}\\|_{L2} := 0\n1486: $$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 7,
        "chapter_file": "chapter_7.json",
        "section_id": "## 7. Swarm Measuring"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-companion-selection-measure",
      "title": "Companion Selection Measure",
      "start_line": 1503,
      "end_line": 1511,
      "header_lines": [
        1504
      ],
      "content_start": 1505,
      "content_end": 1510,
      "content": "1505: :label: def-companion-selection-measure\n1506: For each walker $i \\in \\{1, \\dots, N\\}$ in a swarm $\\mathcal{S}$ with alive set $\\mathcal{A}$, the **Companion Selection Measure**, $\\mathbb{C}_i(\\mathcal{S})$, is a **uniform discrete probability measure** over a support set $S_i \\subseteq \\{1, \\dots, N\\}$ of valid companion indices. The support set is defined as:\n1507: *   If walker $i$ is alive ($i \\in \\mathcal{A}$) and there is at least one other alive walker ($|\\mathcal{A}| \\ge 2$), the support set is all other alive walkers: $S_i := \\mathcal{A} \\setminus \\{i\\}$.\n1508: *   If walker $i$ is dead ($i \\notin \\mathcal{A}$) and the alive set is not empty ($|\\mathcal{A}| \\ge 1$), the support set is all alive walkers: $S_i := \\mathcal{A}$.\n1509: *   If walker $i$ is the only one alive ($|\\mathcal{A}| = 1$ and $\\mathcal{A} = \\{i\\}$), it is its own companion: $S_i := \\{i\\}$.\n1510: *   If the swarm is empty ($|\\mathcal{A}|=0$), the support set is empty: $S_i := \\emptyset$.",
      "metadata": {
        "label": "def-companion-selection-measure"
      },
      "section": "## 8. Companion Selection",
      "references": [],
      "raw_directive": "1503: :::\n1504: :::{prf:definition} Companion Selection Measure\n1505: :label: def-companion-selection-measure\n1506: For each walker $i \\in \\{1, \\dots, N\\}$ in a swarm $\\mathcal{S}$ with alive set $\\mathcal{A}$, the **Companion Selection Measure**, $\\mathbb{C}_i(\\mathcal{S})$, is a **uniform discrete probability measure** over a support set $S_i \\subseteq \\{1, \\dots, N\\}$ of valid companion indices. The support set is defined as:\n1507: *   If walker $i$ is alive ($i \\in \\mathcal{A}$) and there is at least one other alive walker ($|\\mathcal{A}| \\ge 2$), the support set is all other alive walkers: $S_i := \\mathcal{A} \\setminus \\{i\\}$.\n1508: *   If walker $i$ is dead ($i \\notin \\mathcal{A}$) and the alive set is not empty ($|\\mathcal{A}| \\ge 1$), the support set is all alive walkers: $S_i := \\mathcal{A}$.\n1509: *   If walker $i$ is the only one alive ($|\\mathcal{A}| = 1$ and $\\mathcal{A} = \\{i\\}$), it is its own companion: $S_i := \\{i\\}$.\n1510: *   If the swarm is empty ($|\\mathcal{A}|=0$), the support set is empty: $S_i := \\emptyset$.\n1511: The measure is defined as $\\mathbb{C}_i(\\mathcal{S})(\\{j\\}) = 1/|S_i|$ if $j \\in S_i$ and $|S_i|>0$, and 0 otherwise. The expectation of any function $f$ under this measure is $\\mathbb{E}_{j \\sim \\mathbb{C}_i(\\mathcal{S})}[f(j)] = \\frac{1}{|S_i|} \\sum_{j \\in S_i} f(j)$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 8,
        "chapter_file": "chapter_8.json",
        "section_id": "## 8. Companion Selection"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-asymmetric-rescale-function",
      "title": "Smooth Piecewise Rescale Function",
      "start_line": 1681,
      "end_line": 1702,
      "header_lines": [
        1682
      ],
      "content_start": 1683,
      "content_end": 1701,
      "content": "1683: :label: def-asymmetric-rescale-function\n1684: The rescale function is parameterized by the **Rescale Saturation Threshold ($z_{\\max}$)**, which defines the upper saturation limit. For the function to be well-posed with distinct segments, this parameter must satisfy the constraint $z_{\\max} > 1$.\n1685: The **Smooth Piecewise Rescale Function** $g_A: \\mathbb{R} \\to \\mathbb{R}_{>0}$ is defined as:\n1686: $$\n1687: \n1688: g_A(z) :=\n1689: \\begin{cases}\n1690: \\exp(z), & z \\le 0 \\\\\n1691: \\log(1 + z) + 1, & 0 < z < z_{\\max} - 1 \\\\\n1692: P(z), & z_{\\max} - 1 \\le z \\le z_{\\max} \\\\\n1693: \\log(1 + z_{\\max}) + 1, & z > z_{\\max}\n1694: \\end{cases}\n1695: \n1696: $$\n1697: The function $P(z)$ is a unique cubic polynomial defined on the interval $[z_{\\max}-1, z_{\\max}]$. It serves as a $C^1$ (continuously differentiable) patch that smoothly connects the logarithmic curve to the constant saturation value. Its four coefficients are uniquely determined by solving for the following four boundary conditions:\n1698: 1.  **Match Value at Start:** $P(z_{\\max}-1) = \\log(z_{\\max}) + 1$\n1699: 2.  **Match Slope at Start:** $P'(z_{\\max}-1) = 1 / z_{\\max}$\n1700: 3.  **Match Value at End:** $P(z_{\\max}) = \\log(1 + z_{\\max}) + 1$\n1701: 4.  **Match Slope at End:** $P'(z_{\\max}) = 0$",
      "metadata": {
        "label": "def-asymmetric-rescale-function"
      },
      "section": "## 9. Rescale Transformation",
      "references": [],
      "raw_directive": "1681: #### 8.2.1 Definition of the Asymmetric Rescale Function\n1682: :::{prf:definition} Smooth Piecewise Rescale Function\n1683: :label: def-asymmetric-rescale-function\n1684: The rescale function is parameterized by the **Rescale Saturation Threshold ($z_{\\max}$)**, which defines the upper saturation limit. For the function to be well-posed with distinct segments, this parameter must satisfy the constraint $z_{\\max} > 1$.\n1685: The **Smooth Piecewise Rescale Function** $g_A: \\mathbb{R} \\to \\mathbb{R}_{>0}$ is defined as:\n1686: $$\n1687: \n1688: g_A(z) :=\n1689: \\begin{cases}\n1690: \\exp(z), & z \\le 0 \\\\\n1691: \\log(1 + z) + 1, & 0 < z < z_{\\max} - 1 \\\\\n1692: P(z), & z_{\\max} - 1 \\le z \\le z_{\\max} \\\\\n1693: \\log(1 + z_{\\max}) + 1, & z > z_{\\max}\n1694: \\end{cases}\n1695: \n1696: $$\n1697: The function $P(z)$ is a unique cubic polynomial defined on the interval $[z_{\\max}-1, z_{\\max}]$. It serves as a $C^1$ (continuously differentiable) patch that smoothly connects the logarithmic curve to the constant saturation value. Its four coefficients are uniquely determined by solving for the following four boundary conditions:\n1698: 1.  **Match Value at Start:** $P(z_{\\max}-1) = \\log(z_{\\max}) + 1$\n1699: 2.  **Match Slope at Start:** $P'(z_{\\max}-1) = 1 / z_{\\max}$\n1700: 3.  **Match Value at End:** $P(z_{\\max}) = \\log(1 + z_{\\max}) + 1$\n1701: 4.  **Match Slope at End:** $P'(z_{\\max}) = 0$\n1702: This construction ensures that $g_A(z)$ is continuously differentiable across its entire domain.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 9,
        "chapter_file": "chapter_9.json",
        "section_id": "## 9. Rescale Transformation"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-canonical-logistic-rescale-function-example",
      "title": "Canonical Logistic Rescale Function",
      "start_line": 2094,
      "end_line": 2104,
      "header_lines": [
        2095
      ],
      "content_start": 2096,
      "content_end": 2103,
      "content": "2096: :label: def-canonical-logistic-rescale-function-example\n2097: The **Canonical Logistic Rescale Function** $g_A: \\mathbb{R} \\to \\mathbb{R}_{>0}$ is defined as:\n2098: $$\n2099: \n2100: g_A(z) := \\frac{2}{1 + e^{-z}}\n2101: \n2102: $$\n2103: ",
      "metadata": {
        "label": "def-canonical-logistic-rescale-function-example"
      },
      "section": "## 9. Rescale Transformation",
      "references": [
        "02_euclidean_gas"
      ],
      "raw_directive": "2094: #### 8.3.1. Definition: Canonical Logistic Rescale Function\n2095: :::{prf:definition} Canonical Logistic Rescale Function\n2096: :label: def-canonical-logistic-rescale-function-example\n2097: The **Canonical Logistic Rescale Function** $g_A: \\mathbb{R} \\to \\mathbb{R}_{>0}$ is defined as:\n2098: $$\n2099: \n2100: g_A(z) := \\frac{2}{1 + e^{-z}}\n2101: \n2102: $$\n2103: \n2104: This canonical rescale function is used in {prf:ref}`02_euclidean_gas` as the standard choice for the logistic rescaling step in the Euclidean Gas implementation.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 9,
        "chapter_file": "chapter_9.json",
        "section_id": "## 9. Rescale Transformation"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-raw-value-operator",
      "title": "Raw Value Operator",
      "start_line": 2127,
      "end_line": 2135,
      "header_lines": [
        2128
      ],
      "content_start": 2129,
      "content_end": 2134,
      "content": "2129: :label: def-raw-value-operator\n2130: A **Raw Value Operator**, denoted $V$, is a function that maps a swarm state $S \\in \\Sigma_N$ to a **probability distribution** over N-dimensional real-valued vectors, $P(\\mathbb{R}^N)$.\n2131: **Signature:** $V: \\Sigma_N \\to P(\\mathbb{R}^N)$\n2132: For any swarm state $S$, a single sample $v \\sim V(S)$ produces a raw value vector. This process must adhere to the following rules:\n2133: 1.  **Alive Set Dependency:** The sampling process for the components of $v$ corresponding to the alive set $\\mathcal{A}(S)$ may depend on the entire state $S$.\n2134: 2.  **Dead Set Determinism:** For any walker $i$ that is not in the alive set ($i \\notin \\mathcal{A}(S)$), the corresponding component of the raw value vector is deterministically zero: $v_i = 0$.",
      "metadata": {
        "label": "def-raw-value-operator"
      },
      "section": "## 10. Abstract Raw Value Measurement",
      "references": [],
      "raw_directive": "2127: ### 9.1 The Raw Value Operator\n2128: :::{prf:definition} Raw Value Operator\n2129: :label: def-raw-value-operator\n2130: A **Raw Value Operator**, denoted $V$, is a function that maps a swarm state $S \\in \\Sigma_N$ to a **probability distribution** over N-dimensional real-valued vectors, $P(\\mathbb{R}^N)$.\n2131: **Signature:** $V: \\Sigma_N \\to P(\\mathbb{R}^N)$\n2132: For any swarm state $S$, a single sample $v \\sim V(S)$ produces a raw value vector. This process must adhere to the following rules:\n2133: 1.  **Alive Set Dependency:** The sampling process for the components of $v$ corresponding to the alive set $\\mathcal{A}(S)$ may depend on the entire state $S$.\n2134: 2.  **Dead Set Determinism:** For any walker $i$ that is not in the alive set ($i \\notin \\mathcal{A}(S)$), the corresponding component of the raw value vector is deterministically zero: $v_i = 0$.\n2135: This definition encapsulates both deterministic measurements (like reward, where the distribution is a Dirac delta) and stochastic measurements (like distance-to-companion).",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 10,
        "chapter_file": "chapter_10.json",
        "section_id": "## 10. Abstract Raw Value Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-distance-to-companion-measurement",
      "title": "Distance-to-Companion Measurement",
      "start_line": 2170,
      "end_line": 2180,
      "header_lines": [
        2171
      ],
      "content_start": 2172,
      "content_end": 2179,
      "content": "2172: :label: def-distance-to-companion-measurement\n2173: The distance value $d_i$ for walker $i$ is the result of a two-stage sampling process. First, a **potential companion** index, denoted $c_{\\text{pot}}(i)$, is sampled from the **Companion Selection Measure** $\\mathbb{C}_i$. Second, the **Algorithmic Distance** is computed to that specific companion.\n2174: This process is equivalent to sampling a single value from the **Distance-to-Companion Measure** $\\mathbb{D}_i$, which is the pushforward of $\\mathbb{C}_i$ by the distance function $D_i(j) = d_{\\text{alg}}(x_i, x_j)$.\n2175: $$\n2176: \n2177: d_i := d_{\\text{alg}}(x_i, x_{c_{\\text{pot}}(i)}) \\quad \\text{where} \\quad c_{\\text{pot}}(i) \\sim \\mathbb{C}_i(\\cdot)\n2178: \n2179: $$",
      "metadata": {
        "label": "def-distance-to-companion-measurement"
      },
      "section": "## 11. Distance-to-Companion Measurement",
      "references": [],
      "raw_directive": "2170: ### 10.1 Definition of Distance-to-Companion Measurement\n2171: :::{prf:definition} Distance-to-Companion Measurement\n2172: :label: def-distance-to-companion-measurement\n2173: The distance value $d_i$ for walker $i$ is the result of a two-stage sampling process. First, a **potential companion** index, denoted $c_{\\text{pot}}(i)$, is sampled from the **Companion Selection Measure** $\\mathbb{C}_i$. Second, the **Algorithmic Distance** is computed to that specific companion.\n2174: This process is equivalent to sampling a single value from the **Distance-to-Companion Measure** $\\mathbb{D}_i$, which is the pushforward of $\\mathbb{C}_i$ by the distance function $D_i(j) = d_{\\text{alg}}(x_i, x_j)$.\n2175: $$\n2176: \n2177: d_i := d_{\\text{alg}}(x_i, x_{c_{\\text{pot}}(i)}) \\quad \\text{where} \\quad c_{\\text{pot}}(i) \\sim \\mathbb{C}_i(\\cdot)\n2178: \n2179: $$\n2180: The **Raw Distance Vector Operator**, denoted $\\mathbf{d}(\\mathcal{S})$, maps a swarm state $\\mathcal{S}$ to a *distribution* over N-dimensional vectors. A single realization of this vector is produced by performing the distance-to-companion measurement independently for each alive walker. For dead walkers, the component is zero.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 11,
        "chapter_file": "chapter_11.json",
        "section_id": "## 11. Distance-to-Companion Measurement"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-standardization-operator-n-dimensional",
      "title": "N-Dimensional Standardization Operator",
      "start_line": 2808,
      "end_line": 2831,
      "header_lines": [
        2809
      ],
      "content_start": 2810,
      "content_end": 2830,
      "content": "2810: :label: def-standardization-operator-n-dimensional\n2811: The **N-Dimensional Standardization Operator**, denoted $z$, is a function that maps a swarm state $S$ to an N-dimensional vector, parameterized by a choice of a raw value operator and an aggregation operator.\n2812: **Signature:** $z: \\Sigma_N \\times (\\text{Raw Value Operator}) \\times (\\text{Swarm Aggregation Operator}) \\to \\mathbb{R}^N$\n2813: **Inputs:**\n2814: *   The current swarm state, $S_t$.\n2815: *   A **Raw Value Operator**, $V$ (per [](#def-raw-value-operator)).\n2816: *   A **Swarm Aggregation Operator**, $M$ (e.g., $R_{\\text{agg}}$ or $M_D$, per [](#def-swarm-aggregation-operator-axiomatic)).\n2817: *   All relevant implicit parameters ($\\varepsilon_{\\text{std}}$).\n2818: **Operation:**\n2819: The operator computes the output vector $z = z(S_t, V, M)$ as follows:\n2820: 1.  **Generate Raw Values:**\n2821:     a. Let $\\mathcal{A}(S_t)$ be the set of alive walkers. Let $k = |\\mathcal{A}(S_t)|$. If $k=0$, return the zero vector and terminate.\n2822:     b. Generate a single stochastic sample of the raw value vector by drawing $v \\sim V(S_t)$. Let $v_A$ be the k-dimensional sub-vector corresponding to the alive set.\n2823: 2.  **Aggregate and Measure Statistics:**\n2824:     a. Form the **Swarm Aggregation Measure**: $\\mu_v = M(S_t; v_A)$.\n2825:     b. Measure the statistical properties $(\\mu_A, \\sigma'_A)$ from $\\mu_v$ (per Def. 11.1.2), using the provided $\\varepsilon_{\\text{std}}$ and the regularized standard deviation $\\sigma\\'_{\\text{reg}}$.\n2826: 3.  **Standardize and Assemble N-Dimensional Vector:**\n2827:     a. Initialize an N-dimensional zero vector, $z_{\\text{out}} \\leftarrow 0$.\n2828:     b. For each walker $i \\in \\mathcal{A}(S_t)$:\n2829:         *   Compute its Z-score: $z_i := (v_i - \\mu_A) / \\sigma'_A$.\n2830:         *   Set the $i$-th component of the output vector: $z_{\\text{out}}[i] := z_i$.",
      "metadata": {
        "label": "def-standardization-operator-n-dimensional"
      },
      "section": "## 12. Standardization pipeline",
      "references": [],
      "raw_directive": "2808: #### 11.1.1 N-Dimensional Standardization Operator\n2809: :::{prf:definition} N-Dimensional Standardization Operator\n2810: :label: def-standardization-operator-n-dimensional\n2811: The **N-Dimensional Standardization Operator**, denoted $z$, is a function that maps a swarm state $S$ to an N-dimensional vector, parameterized by a choice of a raw value operator and an aggregation operator.\n2812: **Signature:** $z: \\Sigma_N \\times (\\text{Raw Value Operator}) \\times (\\text{Swarm Aggregation Operator}) \\to \\mathbb{R}^N$\n2813: **Inputs:**\n2814: *   The current swarm state, $S_t$.\n2815: *   A **Raw Value Operator**, $V$ (per [](#def-raw-value-operator)).\n2816: *   A **Swarm Aggregation Operator**, $M$ (e.g., $R_{\\text{agg}}$ or $M_D$, per [](#def-swarm-aggregation-operator-axiomatic)).\n2817: *   All relevant implicit parameters ($\\varepsilon_{\\text{std}}$).\n2818: **Operation:**\n2819: The operator computes the output vector $z = z(S_t, V, M)$ as follows:\n2820: 1.  **Generate Raw Values:**\n2821:     a. Let $\\mathcal{A}(S_t)$ be the set of alive walkers. Let $k = |\\mathcal{A}(S_t)|$. If $k=0$, return the zero vector and terminate.\n2822:     b. Generate a single stochastic sample of the raw value vector by drawing $v \\sim V(S_t)$. Let $v_A$ be the k-dimensional sub-vector corresponding to the alive set.\n2823: 2.  **Aggregate and Measure Statistics:**\n2824:     a. Form the **Swarm Aggregation Measure**: $\\mu_v = M(S_t; v_A)$.\n2825:     b. Measure the statistical properties $(\\mu_A, \\sigma'_A)$ from $\\mu_v$ (per Def. 11.1.2), using the provided $\\varepsilon_{\\text{std}}$ and the regularized standard deviation $\\sigma\\'_{\\text{reg}}$.\n2826: 3.  **Standardize and Assemble N-Dimensional Vector:**\n2827:     a. Initialize an N-dimensional zero vector, $z_{\\text{out}} \\leftarrow 0$.\n2828:     b. For each walker $i \\in \\mathcal{A}(S_t)$:\n2829:         *   Compute its Z-score: $z_i := (v_i - \\mu_A) / \\sigma'_A$.\n2830:         *   Set the $i$-th component of the output vector: $z_{\\text{out}}[i] := z_i$.\n2831: **Output:** The full N-dimensional standardized vector $z_{\\text{out}}$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 12,
        "chapter_file": "chapter_12.json",
        "section_id": "## 12. Standardization pipeline"
      }
    },
    {
      "directive_type": "definition",
      "label": "lem-sigma-reg-derivative-bounds",
      "title": "Statistical Properties Measurement",
      "start_line": 2834,
      "end_line": 2881,
      "header_lines": [
        2835,
        2854
      ],
      "content_start": 2836,
      "content_end": 2880,
      "content": "2836: :label: def-statistical-properties-measurement\n2837: Let $\\mathbf{v}_{\\mathcal{A}}$ be the vector of raw scalar values for the alive set $\\mathcal{A}_t$. Let $\\mu_{\\mathbf{v}} = M(\\mathcal{S}_t; \\mathbf{v}_{\\mathcal{A}})$ be the **Swarm Aggregation Measure** for these values. The **Statistical Properties Measurement** extracts the effective mean and a smoothed, regularized standard deviation from this measure:\n2838: *   **Mean:** $\\mu_{\\mathcal{A}} := \\mathbb{E}[\\mu_{\\mathbf{v}}]$\n2839: *   **Regularized Standard Deviation:** $\\sigma'_{\\mathcal{A}} := \\sigma'_{\\text{reg}}(\\operatorname{Var}[\\mu_{\\mathbf{v}}])$\n2840: where $\\sigma'_{\\text{reg}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$ is the **Regularized Standard Deviation**. This $C^\\infty$ replacement for the square-root prevents pathological sensitivity near zero variance while maintaining smooth behavior everywhere. It is defined as:\n2841: $$\n2842: \n2843: \\sigma'_{\\text{reg}}(V) := \\sqrt{V + \\sigma'^2_{\\min}}\n2844: \n2845: $$\n2846: where $\\sigma'_{\\min} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2} > 0$ is the **regularization parameter** combining the variance floor threshold $\\kappa_{\\text{var,min}} > 0$ and the numerical stability parameter $\\varepsilon_{\\text{std}} > 0$.\n2847: **Properties:**\n2848: 1. **C^∞ Regularity:** The function is infinitely differentiable on $[0, \\infty)$ as a composition of smooth functions.\n2849: 2. **Positive Lower Bound:** $\\sigma'_{\\text{reg}}(V) \\ge \\sigma'_{\\min} > 0$ for all $V \\ge 0$, preventing division by zero.\n2850: 3. **Asymptotic Behavior:** For large $V \\gg \\sigma'^2_{\\min}$, the regularized function closely approximates the natural square root: $\\sigma'_{\\text{reg}}(V) \\approx \\sqrt{V} + \\frac{\\sigma'^2_{\\min}}{2\\sqrt{V}}$.\n2851: 4. **Monotonicity:** The function is strictly increasing, with $\\sigma'_{\\text{reg}}(0) = \\sigma'_{\\min}$ and $\\lim_{V \\to \\infty} \\sigma'_{\\text{reg}}(V) = \\infty$.\n2852: \n2853: This regularized standardization operator is applied in {prf:ref}`02_euclidean_gas` for the patched standardization step that produces standardized reward and distance scores.\n2854: ::{prf:lemma} Derivative Bounds for Regularized Standard Deviation\n2855: :label: lem-sigma-reg-derivative-bounds\n2856: The regularized standard deviation $\\sigma'_{\text{reg}}(V) = \\sqrt{V + \\sigma'^2_{\\min}}$ has explicit derivative bounds for all orders. For the first three derivatives:\n2857: $$\n2858: \n2859: \\left|(\\sigma'_{\text{reg}})'(V)\n2860: ight| = \n2861: rac{1}{2\\sqrt{V + \\sigma'^2_{\\min}}} \\le \n2862: rac{1}{2\\sigma'_{\\min}} =: L_{\\sigma'_{\text{reg}}}\n2863: \n2864: $$\n2865: $$\n2866: \\left|(\\sigma'_{\text{reg}})''(V)\n2867: ight| = \n2868: rac{1}{4(V + \\sigma'^2_{\\min})^{3/2}} \\le \n2869: rac{1}{4\\sigma'^3_{\\min}} =: L_{\\sigma''_{\text{reg}}}\n2870: $$\n2871: \n2872: $$\n2873: \\left|(\\sigma'_{\text{reg}})'''(V)\n2874: ight| = \n2875: rac{3}{8(V + \\sigma'^2_{\\min})^{5/2}} \\le \n2876: rac{3}{8\\sigma'^5_{\\min}} =: L_{\\sigma'''_{\text{reg}}}\n2877: $$\n2878: General form: For the $n$-th derivative with $n \\ge 1$,\n2879: \n2880: $$",
      "metadata": {
        "label": "lem-sigma-reg-derivative-bounds"
      },
      "section": "## 12. Standardization pipeline",
      "references": [
        "02_euclidean_gas",
        "def-fragile-gas-algorithm"
      ],
      "raw_directive": "2834: The first step is to distill the vector of raw measurements from the alive set into a few key statistics. This is achieved by calculating the moments of the **Swarm Aggregation Measure**. The definition of the standard deviation is modified to use a smoothed function, which is a critical and mandatory component for securing a global Lipschitz control on the denominator and, ultimately, the Hölder continuity bounds for the full standardization operator.\n2835: :::{prf:definition} Statistical Properties Measurement\n2836: :label: def-statistical-properties-measurement\n2837: Let $\\mathbf{v}_{\\mathcal{A}}$ be the vector of raw scalar values for the alive set $\\mathcal{A}_t$. Let $\\mu_{\\mathbf{v}} = M(\\mathcal{S}_t; \\mathbf{v}_{\\mathcal{A}})$ be the **Swarm Aggregation Measure** for these values. The **Statistical Properties Measurement** extracts the effective mean and a smoothed, regularized standard deviation from this measure:\n2838: *   **Mean:** $\\mu_{\\mathcal{A}} := \\mathbb{E}[\\mu_{\\mathbf{v}}]$\n2839: *   **Regularized Standard Deviation:** $\\sigma'_{\\mathcal{A}} := \\sigma'_{\\text{reg}}(\\operatorname{Var}[\\mu_{\\mathbf{v}}])$\n2840: where $\\sigma'_{\\text{reg}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$ is the **Regularized Standard Deviation**. This $C^\\infty$ replacement for the square-root prevents pathological sensitivity near zero variance while maintaining smooth behavior everywhere. It is defined as:\n2841: $$\n2842: \n2843: \\sigma'_{\\text{reg}}(V) := \\sqrt{V + \\sigma'^2_{\\min}}\n2844: \n2845: $$\n2846: where $\\sigma'_{\\min} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2} > 0$ is the **regularization parameter** combining the variance floor threshold $\\kappa_{\\text{var,min}} > 0$ and the numerical stability parameter $\\varepsilon_{\\text{std}} > 0$.\n2847: **Properties:**\n2848: 1. **C^∞ Regularity:** The function is infinitely differentiable on $[0, \\infty)$ as a composition of smooth functions.\n2849: 2. **Positive Lower Bound:** $\\sigma'_{\\text{reg}}(V) \\ge \\sigma'_{\\min} > 0$ for all $V \\ge 0$, preventing division by zero.\n2850: 3. **Asymptotic Behavior:** For large $V \\gg \\sigma'^2_{\\min}$, the regularized function closely approximates the natural square root: $\\sigma'_{\\text{reg}}(V) \\approx \\sqrt{V} + \\frac{\\sigma'^2_{\\min}}{2\\sqrt{V}}$.\n2851: 4. **Monotonicity:** The function is strictly increasing, with $\\sigma'_{\\text{reg}}(0) = \\sigma'_{\\min}$ and $\\lim_{V \\to \\infty} \\sigma'_{\\text{reg}}(V) = \\infty$.\n2852: \n2853: This regularized standardization operator is applied in {prf:ref}`02_euclidean_gas` for the patched standardization step that produces standardized reward and distance scores.\n2854: ::{prf:lemma} Derivative Bounds for Regularized Standard Deviation\n2855: :label: lem-sigma-reg-derivative-bounds\n2856: The regularized standard deviation $\\sigma'_{\text{reg}}(V) = \\sqrt{V + \\sigma'^2_{\\min}}$ has explicit derivative bounds for all orders. For the first three derivatives:\n2857: $$\n2858: \n2859: \\left|(\\sigma'_{\text{reg}})'(V)\n2860: ight| = \n2861: rac{1}{2\\sqrt{V + \\sigma'^2_{\\min}}} \\le \n2862: rac{1}{2\\sigma'_{\\min}} =: L_{\\sigma'_{\text{reg}}}\n2863: \n2864: $$\n2865: $$\n2866: \\left|(\\sigma'_{\text{reg}})''(V)\n2867: ight| = \n2868: rac{1}{4(V + \\sigma'^2_{\\min})^{3/2}} \\le \n2869: rac{1}{4\\sigma'^3_{\\min}} =: L_{\\sigma''_{\text{reg}}}\n2870: $$\n2871: \n2872: $$\n2873: \\left|(\\sigma'_{\text{reg}})'''(V)\n2874: ight| = \n2875: rac{3}{8(V + \\sigma'^2_{\\min})^{5/2}} \\le \n2876: rac{3}{8\\sigma'^5_{\\min}} =: L_{\\sigma'''_{\text{reg}}}\n2877: $$\n2878: General form: For the $n$-th derivative with $n \\ge 1$,\n2879: \n2880: $$\n2881: \\left|(\\sigma'_{\text{reg}})^{(n)}(V)",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 12,
        "chapter_file": "chapter_12.json",
        "section_id": "## 12. Standardization pipeline"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-value-error-coefficients",
      "title": "Value Error Coefficients",
      "start_line": 3261,
      "end_line": 3291,
      "header_lines": [
        3262
      ],
      "content_start": 3264,
      "content_end": 3290,
      "content": "3264: The squared norm is $\\|z_2\\|_2^2 \\cdot (\\sigma'_2 - \\sigma'_1)^2 / (\\sigma'_1)^2$. We bound each term:\n3265: - From [](#thm-z-score-norm-bound), $\\|z_2\\|_2^2 \\leq k\\,(2V_{\\max}/\\sigma'_{\\min,\\text{bound}})^2$.\n3266: - From [](#lem-stats-value-continuity), $(\\sigma'_2 - \\sigma'_1)^2 \\leq (L_{\\sigma',M}(S))^2 \\|v_1 - v_2\\|_2^2$.\n3267: - The term $1/(\\sigma'_1)^2$ is bounded by $1/(\\sigma'_{\\min,\\text{bound}})^2$.\n3268: Combining these three bounds yields the final result.\n3269: **Q.E.D.**\n3270: :::\n3271: ##### 11.2.2.5. Definition: Value Error Coefficients\n3272: :::{prf:definition} Value Error Coefficients\n3273: :label: def-value-error-coefficients\n3274: \n3275: Let $\\mathcal{S}$ be a fixed swarm state with alive set $\\mathcal{A}$ of size **k**, and let **M** be the chosen **Swarm Aggregation Operator**. The coefficients for the value error bounds are defined as follows:\n3276: \n3277: 1.  **The Direct Shift Coefficient ($C_V,direct$):**\n3278: \n3279: $$\n3280: C_{V,\\text{direct}} := \\frac{1}{\\sigma'^2_{\\min,\\text{bound}}}\n3281: $$\n3282: \n3283: 2.  **The Mean Shift Coefficient ($C_V,\\mu(S)$):**\n3284: \n3285: $$\n3286: C_{V,\\mu}(\\mathcal{S}) := \\frac{k \\cdot (L_{\\mu,M}(\\mathcal{S}))^2}{\\sigma'^2_{\\min,\\text{bound}}}\n3287: $$\n3288: \n3289: 3.  **The Statistical Fluctuation Coefficient ($C_V,\\sigma(S)$):**\n3290: ",
      "metadata": {
        "label": "def-value-error-coefficients"
      },
      "section": "## 12. Standardization pipeline",
      "references": [],
      "raw_directive": "3261: :::{prf:proof}\n3262: :label: proof-lem-sub-statistical-fluctuation-bound\n3263: **Proof.**\n3264: The squared norm is $\\|z_2\\|_2^2 \\cdot (\\sigma'_2 - \\sigma'_1)^2 / (\\sigma'_1)^2$. We bound each term:\n3265: - From [](#thm-z-score-norm-bound), $\\|z_2\\|_2^2 \\leq k\\,(2V_{\\max}/\\sigma'_{\\min,\\text{bound}})^2$.\n3266: - From [](#lem-stats-value-continuity), $(\\sigma'_2 - \\sigma'_1)^2 \\leq (L_{\\sigma',M}(S))^2 \\|v_1 - v_2\\|_2^2$.\n3267: - The term $1/(\\sigma'_1)^2$ is bounded by $1/(\\sigma'_{\\min,\\text{bound}})^2$.\n3268: Combining these three bounds yields the final result.\n3269: **Q.E.D.**\n3270: :::\n3271: ##### 11.2.2.5. Definition: Value Error Coefficients\n3272: :::{prf:definition} Value Error Coefficients\n3273: :label: def-value-error-coefficients\n3274: \n3275: Let $\\mathcal{S}$ be a fixed swarm state with alive set $\\mathcal{A}$ of size **k**, and let **M** be the chosen **Swarm Aggregation Operator**. The coefficients for the value error bounds are defined as follows:\n3276: \n3277: 1.  **The Direct Shift Coefficient ($C_V,direct$):**\n3278: \n3279: $$\n3280: C_{V,\\text{direct}} := \\frac{1}{\\sigma'^2_{\\min,\\text{bound}}}\n3281: $$\n3282: \n3283: 2.  **The Mean Shift Coefficient ($C_V,\\mu(S)$):**\n3284: \n3285: $$\n3286: C_{V,\\mu}(\\mathcal{S}) := \\frac{k \\cdot (L_{\\mu,M}(\\mathcal{S}))^2}{\\sigma'^2_{\\min,\\text{bound}}}\n3287: $$\n3288: \n3289: 3.  **The Statistical Fluctuation Coefficient ($C_V,\\sigma(S)$):**\n3290: \n3291: $$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 12,
        "chapter_file": "chapter_12.json",
        "section_id": "## 12. Standardization pipeline"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-lipschitz-value-error-coefficients",
      "title": "Value Error Coefficients",
      "start_line": 3613,
      "end_line": 3651,
      "header_lines": [
        3614
      ],
      "content_start": 3615,
      "content_end": 3650,
      "content": "3615:     *   From the proven value continuity of the smoothed standard deviation ([](#lem-stats-value-continuity)), $(\\sigma'_2 - \\sigma'_1)^2 \\leq (L_{\\sigma',M}(S))^2 \\|v_1 - v_2\\|_2^2$.\n3616:     *   The term $1/(\\sigma'_1)^2$ is bounded by $1/\\sigma'^2_{\\min\\,\\text{bound}}$.\n3617:     Combining these gives a bound of the form $C \\cdot \\|v_1 - v_2\\|_2^2$ for this component as well.\n3618: 4.  **Combine the Bounds:**\n3619:     Substituting the bounds for each of the three components into the inequality from [](#sub-lem-lipschitz-value-error-decomposition) ($\\|\\Deltaz\\|_2^2 \\leq 3(\\|\\Delta_{\\text{direct}}\\|_2^2 + ...)$), and factoring out the common term $\\|v_1 - v_2\\|_2^2$, yields the final result. The sum of the coefficients for each component, multiplied by 3, constitutes the **Total Value Error Coefficient**, $C_{V,total}(S)$. Since all constituent parts are finite for a given state **S**, $C_{V,total}(S)$ is a finite constant.\n3620: **Q.E.D.**\n3621: :::\n3622: #### 11.3.4 Definition: Value Error Coefficients\n3623: To formalize the result of the preceding theorem and provide modular components for the final proof, we explicitly define the coefficients used in the bound for the Squared Value Error. These coefficients are deterministic functions of a fixed swarm state **S**.\n3624: :::{prf:definition} Value Error Coefficients\n3625: :label: def-lipschitz-value-error-coefficients\n3626: Let **S** be a fixed swarm state with alive set **A** of size **k**, and let **M** be the chosen **Swarm Aggregation Operator**. Let\n3627: $$\n3628: \n3629: \\sigma'_{\\min\\,\\text{bound}} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2}\n3630: \n3631: $$\n3632: be the uniform lower bound on the regularized standard deviation. The coefficients for the value error bounds are defined as follows:\n3633: 1.  **The Direct Shift Coefficient ($C_V,direct$):**\n3634: $$\n3635: \n3636:     C_{V,\\text{direct}} := \\frac{1}{\\sigma'^2_{\\min\\,\\text{bound}}}\n3637: \n3638: \n3639: $$\n3640: 2.  **The Mean Shift Coefficient ($C_V,\\mu(S)$):**\n3641: $$\n3642: \n3643:     C_{V,\\mu}(\\mathcal{S}) := \\frac{k \\cdot (L_{\\mu,M}(\\mathcal{S}))^2}{\\sigma'^2_{\\min\\,\\text{bound}}}\n3644: \n3645: \n3646: $$\n3647: 3.  **The Denominator Shift Coefficient ($C_V,\\sigma(S)$):**\n3648: $$\n3649: \n3650:     C_{V,\\sigma}(\\mathcal{S}) := k \\left( \\frac{2V_{\\max}}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2 \\left( \\frac{L_{\\sigma',M}(\\mathcal{S})}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2",
      "metadata": {
        "label": "def-lipschitz-value-error-coefficients"
      },
      "section": "## 12. Standardization pipeline",
      "references": [],
      "raw_directive": "3613:     The squared norm is $\\|z_2\\|_2^2 \\cdot (\\sigma'_2 - \\sigma'_1)^2 / (\\sigma'_1)^2$. We bound each term:\n3614:     *   From [](#thm-z-score-norm-bound), $\\|z_2\\|_2^2 \\leq k\\big(2V_{\\max}/\\sigma'_{\\min\\,\\text{bound}}\\big)^2$.\n3615:     *   From the proven value continuity of the smoothed standard deviation ([](#lem-stats-value-continuity)), $(\\sigma'_2 - \\sigma'_1)^2 \\leq (L_{\\sigma',M}(S))^2 \\|v_1 - v_2\\|_2^2$.\n3616:     *   The term $1/(\\sigma'_1)^2$ is bounded by $1/\\sigma'^2_{\\min\\,\\text{bound}}$.\n3617:     Combining these gives a bound of the form $C \\cdot \\|v_1 - v_2\\|_2^2$ for this component as well.\n3618: 4.  **Combine the Bounds:**\n3619:     Substituting the bounds for each of the three components into the inequality from [](#sub-lem-lipschitz-value-error-decomposition) ($\\|\\Deltaz\\|_2^2 \\leq 3(\\|\\Delta_{\\text{direct}}\\|_2^2 + ...)$), and factoring out the common term $\\|v_1 - v_2\\|_2^2$, yields the final result. The sum of the coefficients for each component, multiplied by 3, constitutes the **Total Value Error Coefficient**, $C_{V,total}(S)$. Since all constituent parts are finite for a given state **S**, $C_{V,total}(S)$ is a finite constant.\n3620: **Q.E.D.**\n3621: :::\n3622: #### 11.3.4 Definition: Value Error Coefficients\n3623: To formalize the result of the preceding theorem and provide modular components for the final proof, we explicitly define the coefficients used in the bound for the Squared Value Error. These coefficients are deterministic functions of a fixed swarm state **S**.\n3624: :::{prf:definition} Value Error Coefficients\n3625: :label: def-lipschitz-value-error-coefficients\n3626: Let **S** be a fixed swarm state with alive set **A** of size **k**, and let **M** be the chosen **Swarm Aggregation Operator**. Let\n3627: $$\n3628: \n3629: \\sigma'_{\\min\\,\\text{bound}} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2}\n3630: \n3631: $$\n3632: be the uniform lower bound on the regularized standard deviation. The coefficients for the value error bounds are defined as follows:\n3633: 1.  **The Direct Shift Coefficient ($C_V,direct$):**\n3634: $$\n3635: \n3636:     C_{V,\\text{direct}} := \\frac{1}{\\sigma'^2_{\\min\\,\\text{bound}}}\n3637: \n3638: \n3639: $$\n3640: 2.  **The Mean Shift Coefficient ($C_V,\\mu(S)$):**\n3641: $$\n3642: \n3643:     C_{V,\\mu}(\\mathcal{S}) := \\frac{k \\cdot (L_{\\mu,M}(\\mathcal{S}))^2}{\\sigma'^2_{\\min\\,\\text{bound}}}\n3644: \n3645: \n3646: $$\n3647: 3.  **The Denominator Shift Coefficient ($C_V,\\sigma(S)$):**\n3648: $$\n3649: \n3650:     C_{V,\\sigma}(\\mathcal{S}) := k \\left( \\frac{2V_{\\max}}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2 \\left( \\frac{L_{\\sigma',M}(\\mathcal{S})}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2\n3651: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 12,
        "chapter_file": "chapter_12.json",
        "section_id": "## 12. Standardization pipeline"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-lipschitz-structural-error-coefficients",
      "title": "Structural Error Coefficients",
      "start_line": 3696,
      "end_line": 3720,
      "header_lines": [
        3697
      ],
      "content_start": 3698,
      "content_end": 3719,
      "content": "3698:     *   The mean shift error is bounded by $2k_{\\text{stable}} \\cdot ((\\mu_1 - \\mu_2)/\\sigma'_1)^2$. Using the structural continuity of the mean ($|\\mu_1-\\mu_2|^2 \\leq (L_{\\mu,S})^2 (n_c)^2$), this term is bounded by an expression proportional to $n_c^2$.\n3699:     *   The denominator shift error is bounded by $2\\|z_1\\|^2((\\sigma'_1-\\sigma'_2)/\\sigma'_2)^2$. Using the structural continuity of $\\sigma'$ ($|\\sigma'_1-\\sigma'_2|^2 \\leq (L_{\\sigma',S})^2 (n_c)^2$), this term is also bounded by an expression proportional to $n_c^2$.\n3700:     The sum of these two terms gives a total bound for the indirect error that is quadratic in $n_c$.\n3701: 4.  **Combine the Bounds:**\n3702:     Summing the bounds for the direct (linear in $n_c$) and indirect (quadratic in $n_c$) components gives the final bound as stated in the theorem.\n3703: **Q.E.D.**\n3704: :::\n3705: #### 11.3.6 Definition: Structural Error Coefficients\n3706: To formalize the result of the preceding theorem, we explicitly define the coefficients used in the bound for the Squared Structural Error. These coefficients are deterministic functions of the two swarm states, $\\mathcal{S}_1$ and $\\mathcal{S}_2$.\n3707: :::{prf:definition} Structural Error Coefficients\n3708: :label: def-lipschitz-structural-error-coefficients\n3709: Let $\\mathcal{S}_1$ and $\\mathcal{S}_2$ be two swarm states with alive sets $\\mathcal{A}_1$ and $\\mathcal{A}_2$, of sizes $k_1:=|\\mathcal{A}_1|$ and $k_2:=|\\mathcal{A}_2|$. Let $k_{\\text{stable}}:=|\\mathcal{A}_1\\cap\\mathcal{A}_2|$. Let\n3710: $$\n3711: \n3712: \\sigma'_{\\min\\,\\text{bound}} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2}\n3713: \n3714: $$\n3715: be a uniform lower bound on the regularized standard deviation. The coefficients for the structural error bounds are defined as follows:\n3716: 1.  **The Direct Structural Error Coefficient ($C_{S,\\text{direct}}$):** The coefficient of the term linear in $n_c$.\n3717: $$\n3718: \n3719:     C_{S,\\text{direct}} := \\left( \\frac{2V_{\\max}}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2",
      "metadata": {
        "label": "def-lipschitz-structural-error-coefficients"
      },
      "section": "## 12. Standardization pipeline",
      "references": [],
      "raw_directive": "3696: 3.  **Bound the Indirect Error Component ($\\Delta_{\\text{indirect}}$):**\n3697:     For the $k_{\\text{stable}}$ walkers that are alive in both swarms, the error $z_{1,i} - z_{2,i}$ is decomposed into a mean-shift part and a denominator-shift part. Using $\\|a+b\\|^2 \\leq 2(\\|a\\|^2 + \\|b\\|^2)$, we bound the sum of these errors over all stable walkers.\n3698:     *   The mean shift error is bounded by $2k_{\\text{stable}} \\cdot ((\\mu_1 - \\mu_2)/\\sigma'_1)^2$. Using the structural continuity of the mean ($|\\mu_1-\\mu_2|^2 \\leq (L_{\\mu,S})^2 (n_c)^2$), this term is bounded by an expression proportional to $n_c^2$.\n3699:     *   The denominator shift error is bounded by $2\\|z_1\\|^2((\\sigma'_1-\\sigma'_2)/\\sigma'_2)^2$. Using the structural continuity of $\\sigma'$ ($|\\sigma'_1-\\sigma'_2|^2 \\leq (L_{\\sigma',S})^2 (n_c)^2$), this term is also bounded by an expression proportional to $n_c^2$.\n3700:     The sum of these two terms gives a total bound for the indirect error that is quadratic in $n_c$.\n3701: 4.  **Combine the Bounds:**\n3702:     Summing the bounds for the direct (linear in $n_c$) and indirect (quadratic in $n_c$) components gives the final bound as stated in the theorem.\n3703: **Q.E.D.**\n3704: :::\n3705: #### 11.3.6 Definition: Structural Error Coefficients\n3706: To formalize the result of the preceding theorem, we explicitly define the coefficients used in the bound for the Squared Structural Error. These coefficients are deterministic functions of the two swarm states, $\\mathcal{S}_1$ and $\\mathcal{S}_2$.\n3707: :::{prf:definition} Structural Error Coefficients\n3708: :label: def-lipschitz-structural-error-coefficients\n3709: Let $\\mathcal{S}_1$ and $\\mathcal{S}_2$ be two swarm states with alive sets $\\mathcal{A}_1$ and $\\mathcal{A}_2$, of sizes $k_1:=|\\mathcal{A}_1|$ and $k_2:=|\\mathcal{A}_2|$. Let $k_{\\text{stable}}:=|\\mathcal{A}_1\\cap\\mathcal{A}_2|$. Let\n3710: $$\n3711: \n3712: \\sigma'_{\\min\\,\\text{bound}} := \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\text{std}}^2}\n3713: \n3714: $$\n3715: be a uniform lower bound on the regularized standard deviation. The coefficients for the structural error bounds are defined as follows:\n3716: 1.  **The Direct Structural Error Coefficient ($C_{S,\\text{direct}}$):** The coefficient of the term linear in $n_c$.\n3717: $$\n3718: \n3719:     C_{S,\\text{direct}} := \\left( \\frac{2V_{\\max}}{\\sigma'_{\\min\\,\\text{bound}}} \\right)^2\n3720: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 12,
        "chapter_file": "chapter_12.json",
        "section_id": "## 12. Standardization pipeline"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-alive-set-potential-operator",
      "title": "Rescaled Potential Operator for the Alive Set",
      "start_line": 3765,
      "end_line": 3791,
      "header_lines": [
        3766
      ],
      "content_start": 3767,
      "content_end": 3790,
      "content": "3767: \n3768: \n3769: $$\n3770: 4.  **Combine the Bounds:** Substituting the bounds from steps 2 and 3 into the decomposition from step 1 yields the final inequality as stated in the theorem. This provides a complete, deterministic, worst-case bound on the operator's output error.\n3771: **Q.E.D.**\n3772: :::\n3773: ## 13. Fitness potential operator\n3774: This section defines the sequence of deterministic operators that transform the raw measurement vectors (rewards and distances) into a final, N-dimensional fitness potential vector. These operators are executed after the stochastic measurement stage and are fixed for the remainder of the cloning decision process.\n3775: ### 12.1 Rescaled Potential Operator for the Alive Set\n3776: :::{prf:definition} Rescaled Potential Operator for the Alive Set\n3777: :label: def-alive-set-potential-operator\n3778: The **Rescaled Potential Operator for the Alive Set**, denoted $V_{\\text{op},\\mathcal{A}}$, is a deterministic function that maps the raw reward and distance vectors of an alive set of size $k=|\\mathcal{A}_t|$ to a vector of fitness potentials for that same set.\n3779: **Signature:** $V_{\\text{op},\\mathcal{A}}: \\Sigma_N \\times \\mathbb{R}^k \\times \\mathbb{R}^k \\to \\mathbb{R}^k$\n3780: **Inputs:**\n3781: *   The current swarm state, $\\mathcal{S}_t$ (used for the aggregation operators).\n3782: *   The raw reward vector for the alive set, $\\mathbf{r} = (r_j)_{j \\in \\mathcal{A}_t}$.\n3783: *   The raw distance vector for the alive set, $\\mathbf{d} = (d_j)_{j \\in \\mathcal{A}_t}$.\n3784: *   All relevant algorithmic parameters ($\\eta, \\varepsilon_{\\mathrm{std}}, z_{\\max}, R_{agg}, M_D, \\alpha, \\beta$).\n3785: **Operation:**\n3786: The operator computes the output vector $\\mathbf{V}_{\\mathcal{A}} = (V_i)_{i \\in \\mathcal{A}_t}$ as follows:\n3787: 1.  **Standardize Raw Values (patched z‑score):** The **N-Dimensional Standardization Operator** (Def. 11.1.1) is applied independently to each raw vector using the regularized standard deviation $\\sigma\\'_{\\text{reg}}$.\n3788:     *   Compute reward Z‑scores: $\\mathbf{z_r} := z(\\mathcal{S}_t, \\mathbf{r}, R_{agg}, \\varepsilon_{\\mathrm{std}})$.\n3789:     *   Compute distance Z-scores: $\\mathbf{z_d} := z(\\mathcal{S}_t, \\mathbf{d}, M_D, \\varepsilon_{\\mathrm{std}})$.\n3790: 2.  **Compute Potentials:** For each walker $i \\in \\mathcal{A}_t$:",
      "metadata": {
        "label": "def-alive-set-potential-operator"
      },
      "section": "## 13. Fitness potential operator",
      "references": [],
      "raw_directive": "3765: \n3766:     E_{S}^2(\\mathcal{S}_1, \\mathcal{S}_2; \\mathbf{v}_2) \\le C_{S,\\text{direct}} \\cdot n_c(\\mathcal{S}_1, \\mathcal{S}_2) + C_{S,\\text{indirect}}(\\mathcal{S}_1, \\mathcal{S}_2) \\cdot n_c(\\mathcal{S}_1, \\mathcal{S}_2)^2\n3767: \n3768: \n3769: $$\n3770: 4.  **Combine the Bounds:** Substituting the bounds from steps 2 and 3 into the decomposition from step 1 yields the final inequality as stated in the theorem. This provides a complete, deterministic, worst-case bound on the operator's output error.\n3771: **Q.E.D.**\n3772: :::\n3773: ## 13. Fitness potential operator\n3774: This section defines the sequence of deterministic operators that transform the raw measurement vectors (rewards and distances) into a final, N-dimensional fitness potential vector. These operators are executed after the stochastic measurement stage and are fixed for the remainder of the cloning decision process.\n3775: ### 12.1 Rescaled Potential Operator for the Alive Set\n3776: :::{prf:definition} Rescaled Potential Operator for the Alive Set\n3777: :label: def-alive-set-potential-operator\n3778: The **Rescaled Potential Operator for the Alive Set**, denoted $V_{\\text{op},\\mathcal{A}}$, is a deterministic function that maps the raw reward and distance vectors of an alive set of size $k=|\\mathcal{A}_t|$ to a vector of fitness potentials for that same set.\n3779: **Signature:** $V_{\\text{op},\\mathcal{A}}: \\Sigma_N \\times \\mathbb{R}^k \\times \\mathbb{R}^k \\to \\mathbb{R}^k$\n3780: **Inputs:**\n3781: *   The current swarm state, $\\mathcal{S}_t$ (used for the aggregation operators).\n3782: *   The raw reward vector for the alive set, $\\mathbf{r} = (r_j)_{j \\in \\mathcal{A}_t}$.\n3783: *   The raw distance vector for the alive set, $\\mathbf{d} = (d_j)_{j \\in \\mathcal{A}_t}$.\n3784: *   All relevant algorithmic parameters ($\\eta, \\varepsilon_{\\mathrm{std}}, z_{\\max}, R_{agg}, M_D, \\alpha, \\beta$).\n3785: **Operation:**\n3786: The operator computes the output vector $\\mathbf{V}_{\\mathcal{A}} = (V_i)_{i \\in \\mathcal{A}_t}$ as follows:\n3787: 1.  **Standardize Raw Values (patched z‑score):** The **N-Dimensional Standardization Operator** (Def. 11.1.1) is applied independently to each raw vector using the regularized standard deviation $\\sigma\\'_{\\text{reg}}$.\n3788:     *   Compute reward Z‑scores: $\\mathbf{z_r} := z(\\mathcal{S}_t, \\mathbf{r}, R_{agg}, \\varepsilon_{\\mathrm{std}})$.\n3789:     *   Compute distance Z-scores: $\\mathbf{z_d} := z(\\mathcal{S}_t, \\mathbf{d}, M_D, \\varepsilon_{\\mathrm{std}})$.\n3790: 2.  **Compute Potentials:** For each walker $i \\in \\mathcal{A}_t$:\n3791:     a.  Apply the **Smooth Piecewise Rescale Function** ($g_A$) and add the lower bound $\\eta$ to create the rescaled components from the Z-scores $z_{i,r}$ and $z_{i,d}$:",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 13,
        "chapter_file": "chapter_13.json",
        "section_id": "## 13. Fitness potential operator"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-swarm-potential-assembly-operator",
      "title": "Swarm Potential Assembly Operator",
      "start_line": 3792,
      "end_line": 3806,
      "header_lines": [
        3793
      ],
      "content_start": 3794,
      "content_end": 3805,
      "content": "3794:     b.  Combine the components to get the final fitness potential for that walker:\n3795: $$\n3796: \n3797:     V_i := (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} \\quad \\text{for } i \\in \\mathcal{A}_t\n3798: \n3799: \n3800: $$\n3801: **Output:** The operator returns the $k$-dimensional vector $\\mathbf{V}_{\\mathcal{A}} = (V_i)_{i \\in \\mathcal{A}_t}$.\n3802: :::\n3803: :::{prf:definition} Swarm Potential Assembly Operator\n3804: :label: def-swarm-potential-assembly-operator\n3805: The **Swarm Potential Assembly Operator**, denoted $A_{\\text{pot}}$, is a deterministic function that maps the potential vector of the alive set to the full N-dimensional fitness potential vector for the entire swarm.",
      "metadata": {
        "label": "def-swarm-potential-assembly-operator"
      },
      "section": "## 13. Fitness potential operator",
      "references": [],
      "raw_directive": "3792:         *   $r'_i := g_A(z_{i,r}) + \\eta$\n3793:         *   $d'_i := g_A(z_{i,d}) + \\eta$\n3794:     b.  Combine the components to get the final fitness potential for that walker:\n3795: $$\n3796: \n3797:     V_i := (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} \\quad \\text{for } i \\in \\mathcal{A}_t\n3798: \n3799: \n3800: $$\n3801: **Output:** The operator returns the $k$-dimensional vector $\\mathbf{V}_{\\mathcal{A}} = (V_i)_{i \\in \\mathcal{A}_t}$.\n3802: :::\n3803: :::{prf:definition} Swarm Potential Assembly Operator\n3804: :label: def-swarm-potential-assembly-operator\n3805: The **Swarm Potential Assembly Operator**, denoted $A_{\\text{pot}}$, is a deterministic function that maps the potential vector of the alive set to the full N-dimensional fitness potential vector for the entire swarm.\n3806: **Signature:** $A_{\\text{pot}}: \\Sigma_N \\times \\mathbb{R}^{|\\mathcal{A}_t|} \\to \\mathbb{R}^N$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 13,
        "chapter_file": "chapter_13.json",
        "section_id": "## 13. Fitness potential operator"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-perturbation-operator",
      "title": "Perturbation Operator",
      "start_line": 4031,
      "end_line": 4044,
      "header_lines": [
        4032
      ],
      "content_start": 4033,
      "content_end": 4043,
      "content": "4033: F_{\\text{pot,det}}(\\mathcal{S}_1, \\mathcal{S}_2, \\mathbf{v}_{r1}, \\mathbf{v}_{r2}, \\mathbf{v}_{d1}, \\mathbf{v}_{d2})\n4034: \\;\\xrightarrow[(d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2),\\,\\|\\Delta\\mathbf{v}_r\\|,\\,\\|\\Delta\\mathbf{v}_d\\|)\\to 0]{}\\;0.\n4035: \n4036: $$\n4037: Moreover, for $d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2)^2\\le r_{\\mathrm{status}}$ we have $n_c=0$ and the unstable term vanishes exactly; the remaining terms are controlled by the deterministic continuity of the patched standardization operator and the Lipschitz continuity of the potential map $F$.\n4038: :::\n4039: ## 14. The Perturbation Operator\n4040: The perturbation stage applies a random displacement to each walker in the swarm, representing an exploration step. This is a purely stochastic operator that only affects walker positions.\n4041: ### 13.1 Definition: Perturbation Operator\n4042: :::{prf:definition} Perturbation Operator\n4043: :label: def-perturbation-operator",
      "metadata": {
        "label": "def-perturbation-operator"
      },
      "section": "## 14. The Perturbation Operator",
      "references": [],
      "raw_directive": "4031: $$\n4032: \n4033: F_{\\text{pot,det}}(\\mathcal{S}_1, \\mathcal{S}_2, \\mathbf{v}_{r1}, \\mathbf{v}_{r2}, \\mathbf{v}_{d1}, \\mathbf{v}_{d2})\n4034: \\;\\xrightarrow[(d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2),\\,\\|\\Delta\\mathbf{v}_r\\|,\\,\\|\\Delta\\mathbf{v}_d\\|)\\to 0]{}\\;0.\n4035: \n4036: $$\n4037: Moreover, for $d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1,\\mathcal{S}_2)^2\\le r_{\\mathrm{status}}$ we have $n_c=0$ and the unstable term vanishes exactly; the remaining terms are controlled by the deterministic continuity of the patched standardization operator and the Lipschitz continuity of the potential map $F$.\n4038: :::\n4039: ## 14. The Perturbation Operator\n4040: The perturbation stage applies a random displacement to each walker in the swarm, representing an exploration step. This is a purely stochastic operator that only affects walker positions.\n4041: ### 13.1 Definition: Perturbation Operator\n4042: :::{prf:definition} Perturbation Operator\n4043: :label: def-perturbation-operator\n4044: The **Perturbation Operator**, denoted $\\Psi_{\\text{pert}}: \\Sigma_N \\to \\mathcal{P}(\\Sigma_N)$, maps an input swarm $\\mathcal{S}_{\\text{in}}$ to a distribution over swarms where only the positions have been updated.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 14,
        "chapter_file": "chapter_14.json",
        "section_id": "## 14. The Perturbation Operator"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-perturbation-fluctuation-bounds-reproof",
      "title": "Perturbation Fluctuation Bounds",
      "start_line": 4161,
      "end_line": 4179,
      "header_lines": [
        4162
      ],
      "content_start": 4163,
      "content_end": 4178,
      "content": "4163: $$\n4164: Setting the failure probability to $\\delta'$ and solving for $t$ gives the stochastic fluctuation bound for the average,\n4165:     $\\displaystyle B_{S,\\text{avg}}(N,\\delta') = D_{\\mathcal{Y}}^2 \\sqrt{\\tfrac{1}{2N}\\ln\\!(\\tfrac{2}{\\delta'})}$. Multiplying back by $N$ recovers the bound for $\\Delta_{\\text{pert}}^2$ used below.\n4166: 4.  **Combine with Axiomatic Mean Bound.**\n4167:     The expected total displacement $E[\\Delta_pert^2]$ is bounded by the **Mean Displacement Bound**, $B_M(N)$. Combining these gives the final high-probability bound.\n4168: **Q.E.D.**\n4169: :::\n4170: #### 13.2.4. Definition: Perturbation Fluctuation Bounds\n4171: This section formally defines the two components that bound the total random displacement introduced by the Perturbation Operator. These terms are direct consequences of the preceding analysis and are functions of the foundational parameters of the system.\n4172: :::{prf:definition} Perturbation Fluctuation Bounds\n4173: :label: def-perturbation-fluctuation-bounds-reproof\n4174: The total random displacement introduced by the Perturbation Operator is bounded by the sum of two components: a deterministic bound on its mean and a probabilistic bound on its fluctuations.\n4175: 1.  **The Mean Displacement Bound ($B_M(N)$):** A deterministic upper bound on the total expected squared displacement for a swarm of size N. It is derived from the **Axiom of Bounded Second Moment of Perturbation** ([](#def-axiom-bounded-second-moment-perturbation)).\n4176: $$\n4177: \n4178:     B_M(N) := N \\cdot M_{\\text{pert}}^2",
      "metadata": {
        "label": "def-perturbation-fluctuation-bounds-reproof"
      },
      "section": "## 14. The Perturbation Operator",
      "references": [],
      "raw_directive": "4161: \n4162: \n4163: $$\n4164: Setting the failure probability to $\\delta'$ and solving for $t$ gives the stochastic fluctuation bound for the average,\n4165:     $\\displaystyle B_{S,\\text{avg}}(N,\\delta') = D_{\\mathcal{Y}}^2 \\sqrt{\\tfrac{1}{2N}\\ln\\!(\\tfrac{2}{\\delta'})}$. Multiplying back by $N$ recovers the bound for $\\Delta_{\\text{pert}}^2$ used below.\n4166: 4.  **Combine with Axiomatic Mean Bound.**\n4167:     The expected total displacement $E[\\Delta_pert^2]$ is bounded by the **Mean Displacement Bound**, $B_M(N)$. Combining these gives the final high-probability bound.\n4168: **Q.E.D.**\n4169: :::\n4170: #### 13.2.4. Definition: Perturbation Fluctuation Bounds\n4171: This section formally defines the two components that bound the total random displacement introduced by the Perturbation Operator. These terms are direct consequences of the preceding analysis and are functions of the foundational parameters of the system.\n4172: :::{prf:definition} Perturbation Fluctuation Bounds\n4173: :label: def-perturbation-fluctuation-bounds-reproof\n4174: The total random displacement introduced by the Perturbation Operator is bounded by the sum of two components: a deterministic bound on its mean and a probabilistic bound on its fluctuations.\n4175: 1.  **The Mean Displacement Bound ($B_M(N)$):** A deterministic upper bound on the total expected squared displacement for a swarm of size N. It is derived from the **Axiom of Bounded Second Moment of Perturbation** ([](#def-axiom-bounded-second-moment-perturbation)).\n4176: $$\n4177: \n4178:     B_M(N) := N \\cdot M_{\\text{pert}}^2\n4179: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 14,
        "chapter_file": "chapter_14.json",
        "section_id": "## 14. The Perturbation Operator"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-status-update-operator",
      "title": "Status Update Operator",
      "start_line": 4221,
      "end_line": 4234,
      "header_lines": [
        4222
      ],
      "content_start": 4223,
      "content_end": 4233,
      "content": "4223: **Q.E.D.**\n4224: :::\n4225: :::{admonition} Scope and assumptions\n4226: :class: note\n4227: This concentration bound relies on Assumption A (in‑step independence) and on the with‑replacement sampling policy in §7.1.1. Implementations that use within‑step dependence (e.g., systematic resampling with a shared uniform) violate these assumptions; in that case use a dependent bounded‑differences inequality (see Appendix) instead of McDiarmid.\n4228: :::\n4229: ## 15. The Status Update Operator\n4230: After any change in position (either from cloning or perturbation), a walker's status must be re-evaluated. This operator performs that check deterministically.\n4231: ### 14.1 Definition: Status Update Operator\n4232: :::{prf:definition} Status Update Operator\n4233: :label: def-status-update-operator",
      "metadata": {
        "label": "def-status-update-operator"
      },
      "section": "## 15. The Status Update Operator",
      "references": [],
      "raw_directive": "4221: 4.  **Combine All Bounds.**\n4222:     Substituting the deterministic bound for the status component and the high-probability bound for the positional component back into the metric definition gives the final result as stated in the theorem.\n4223: **Q.E.D.**\n4224: :::\n4225: :::{admonition} Scope and assumptions\n4226: :class: note\n4227: This concentration bound relies on Assumption A (in‑step independence) and on the with‑replacement sampling policy in §7.1.1. Implementations that use within‑step dependence (e.g., systematic resampling with a shared uniform) violate these assumptions; in that case use a dependent bounded‑differences inequality (see Appendix) instead of McDiarmid.\n4228: :::\n4229: ## 15. The Status Update Operator\n4230: After any change in position (either from cloning or perturbation), a walker's status must be re-evaluated. This operator performs that check deterministically.\n4231: ### 14.1 Definition: Status Update Operator\n4232: :::{prf:definition} Status Update Operator\n4233: :label: def-status-update-operator\n4234: The **Status Update Operator**, denoted $\\Psi_{\\text{status}}: \\Sigma_N \\to \\Sigma_N$, is a deterministic function that maps an input swarm to an output swarm where only the aliveness statuses have been updated to reflect their current positions.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 15,
        "chapter_file": "chapter_15.json",
        "section_id": "## 15. The Status Update Operator"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-stochastic-threshold-cloning",
      "title": "Cloning Score Function",
      "start_line": 4319,
      "end_line": 4368,
      "header_lines": [
        4320,
        4332
      ],
      "content_start": 4321,
      "content_end": 4367,
      "content": "4321:     *   **Hölder Term:** The bound on the squared difference of means is identical for all $N$ walkers. Summing this bound $N$ times gives $N L_{\\text{death}}^2 \\left( d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2) \\right)^{2\\alpha_B}$.\n4322:     Combining these two bounds yields the final inequality as stated in the theorem.\n4323: **Q.E.D.**\n4324: :::\n4325: ## 16. The Cloning Transition Measure\n4326: The final step in the measurement pipeline is to convert the N-dimensional fitness potential vector into a probabilistic cloning decision for each walker. This process is governed by a score function and the resulting $Cloning Bernoulli Measure$.\n4327: ### 15.1 Definition: Cloning Transition Measure\n4328: #### 15.1.1 The Cloning Score Function\n4329: The core arithmetic of the cloning decision is encapsulated in a deterministic function that compares a walker's potential to that of its companion.\n4330: :::{prf:definition} Cloning Score Function\n4331: :label: def-cloning-score-function\n4332: The **Cloning Score Function**, $S: \\mathbb{R}_{\\ge 0} \\times \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}$, takes the fitness potential of a companion walker ($v_c$) and a primary walker ($v_i$) and computes a raw score.\n4333: $$\n4334: \n4335: S(v_c, v_i) := \\frac{v_c - v_i}{v_i + \\varepsilon}\n4336: \n4337: $$\n4338: where $\\varepsilon > 0$ is the cloning denominator regularizer.\n4339: ::::\n4340: #### 15.1.2 Stochastic Threshold Cloning\n4341: This procedure defines the cloning action for each walker. It replaces a probabilistic model with a deterministic comparison between the walker's score and a randomly sampled threshold.\n4342: :::{prf:definition} Stochastic Threshold Cloning\n4343: :label: def-stochastic-threshold-cloning\n4344: For each walker $i \\in \\{1, \\dots, N\\}$, the cloning action $a_i \\in \\{\\text{Clone}, \\text{Persist}\\}$ is determined by the following procedure, which depends on the full fitness potential vector of the swarm and an independent random choice of a companion.\n4345: **Inputs:**\n4346: *   The full N-dimensional fitness potential vector, $\\mathbf{V}_{\\text{fit}}$.\n4347: *   The walker's index, $i$.\n4348: *   The **Companion Selection Measure** for that walker, $\\mathbb{C}_i$.\n4349: *   The **Clone Threshold Scale** parameter, $p_{\\max}$.\n4350: **Operation:**\n4351: The action is determined as follows:\n4352: 1.  **Sample Cloning Companion:** An independent cloning companion index, $c_{\\text{clone}}(i)$, is sampled from the companion measure: $c_{\\text{clone}}(i) \\sim \\mathbb{C}_i(\\cdot)$.\n4353: 2.  **Compute Score:** The walker's potential, $v_i = V_{\\text{fit},i}$, and its companion's potential, $v_c = V_{\\text{fit},c_{\\text{clone}}(i)}$, are used to compute the cloning score using the [](#def-cloning-score-function):\n4354: $$\n4355: \n4356:     S_i := S(v_c, v_i)\n4357: \n4358: \n4359: $$\n4360: 3.  **Sample Cloning Threshold:** A random threshold, $T_{\\text{clone}}$, is drawn from a uniform distribution over the interval defined by the Clone Threshold Scale:\n4361: $$\n4362: \n4363:     T_{\\text{clone}} \\sim \\text{Uniform}(0, p_{\\max})\n4364: \n4365: \n4366: $$\n4367: 4.  **Determine Action:** The action is determined by comparing the score to the threshold. A walker is cloned only if its score exceeds the randomly drawn threshold.",
      "metadata": {
        "label": "def-stochastic-threshold-cloning"
      },
      "section": "## 16. The Cloning Transition Measure",
      "references": [],
      "raw_directive": "4319: 4.  **Finalize the Bound:**\n4320:     *   **Variance Term:** The variance of a Bernoulli random variable is $\\operatorname{Var}(X) = p(1-p)$, which is always bounded above by $1/4$. Therefore, the sum of all variance terms is bounded by a constant: $\\sum_{i=1}^N (\\operatorname{Var}[s'_{1,i}] + \\operatorname{Var}[s'_{2,i}]) \\le \\sum_{i=1}^N (\\frac{1}{4} + \\frac{1}{4}) = \\frac{N}{2}$.\n4321:     *   **Hölder Term:** The bound on the squared difference of means is identical for all $N$ walkers. Summing this bound $N$ times gives $N L_{\\text{death}}^2 \\left( d_{\\text{Disp},\\mathcal{Y}}(\\mathcal{S}_1, \\mathcal{S}_2) \\right)^{2\\alpha_B}$.\n4322:     Combining these two bounds yields the final inequality as stated in the theorem.\n4323: **Q.E.D.**\n4324: :::\n4325: ## 16. The Cloning Transition Measure\n4326: The final step in the measurement pipeline is to convert the N-dimensional fitness potential vector into a probabilistic cloning decision for each walker. This process is governed by a score function and the resulting $Cloning Bernoulli Measure$.\n4327: ### 15.1 Definition: Cloning Transition Measure\n4328: #### 15.1.1 The Cloning Score Function\n4329: The core arithmetic of the cloning decision is encapsulated in a deterministic function that compares a walker's potential to that of its companion.\n4330: :::{prf:definition} Cloning Score Function\n4331: :label: def-cloning-score-function\n4332: The **Cloning Score Function**, $S: \\mathbb{R}_{\\ge 0} \\times \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}$, takes the fitness potential of a companion walker ($v_c$) and a primary walker ($v_i$) and computes a raw score.\n4333: $$\n4334: \n4335: S(v_c, v_i) := \\frac{v_c - v_i}{v_i + \\varepsilon}\n4336: \n4337: $$\n4338: where $\\varepsilon > 0$ is the cloning denominator regularizer.\n4339: ::::\n4340: #### 15.1.2 Stochastic Threshold Cloning\n4341: This procedure defines the cloning action for each walker. It replaces a probabilistic model with a deterministic comparison between the walker's score and a randomly sampled threshold.\n4342: :::{prf:definition} Stochastic Threshold Cloning\n4343: :label: def-stochastic-threshold-cloning\n4344: For each walker $i \\in \\{1, \\dots, N\\}$, the cloning action $a_i \\in \\{\\text{Clone}, \\text{Persist}\\}$ is determined by the following procedure, which depends on the full fitness potential vector of the swarm and an independent random choice of a companion.\n4345: **Inputs:**\n4346: *   The full N-dimensional fitness potential vector, $\\mathbf{V}_{\\text{fit}}$.\n4347: *   The walker's index, $i$.\n4348: *   The **Companion Selection Measure** for that walker, $\\mathbb{C}_i$.\n4349: *   The **Clone Threshold Scale** parameter, $p_{\\max}$.\n4350: **Operation:**\n4351: The action is determined as follows:\n4352: 1.  **Sample Cloning Companion:** An independent cloning companion index, $c_{\\text{clone}}(i)$, is sampled from the companion measure: $c_{\\text{clone}}(i) \\sim \\mathbb{C}_i(\\cdot)$.\n4353: 2.  **Compute Score:** The walker's potential, $v_i = V_{\\text{fit},i}$, and its companion's potential, $v_c = V_{\\text{fit},c_{\\text{clone}}(i)}$, are used to compute the cloning score using the [](#def-cloning-score-function):\n4354: $$\n4355: \n4356:     S_i := S(v_c, v_i)\n4357: \n4358: \n4359: $$\n4360: 3.  **Sample Cloning Threshold:** A random threshold, $T_{\\text{clone}}$, is drawn from a uniform distribution over the interval defined by the Clone Threshold Scale:\n4361: $$\n4362: \n4363:     T_{\\text{clone}} \\sim \\text{Uniform}(0, p_{\\max})\n4364: \n4365: \n4366: $$\n4367: 4.  **Determine Action:** The action is determined by comparing the score to the threshold. A walker is cloned only if its score exceeds the randomly drawn threshold.\n4368: $$",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 16,
        "chapter_file": "chapter_16.json",
        "section_id": "## 16. The Cloning Transition Measure"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-total-expected-cloning-action",
      "title": "Total Expected Cloning Action",
      "start_line": 4385,
      "end_line": 4395,
      "header_lines": [
        4386
      ],
      "content_start": 4387,
      "content_end": 4394,
      "content": "4387: The Cloning Transition is a composite stochastic operator that determines the intermediate swarm state based on the calculated fitness potentials. Its continuity analysis is critical, as it governs how sensitively the cloning and revival mechanisms react to small changes in the swarm state. A discontinuous transition would imply chaotic behavior where small measurement fluctuations could lead to drastically different swarm configurations.\n4388: This section proves that the operator is probabilistically continuous. The analysis is centered on the key insight that the continuity of the overall transition depends on the continuity of the **total probability** of cloning. We first define this total probability, which averages over all stochasticity in the measurement pipeline, and then prove that it is a continuous function of the input swarm state. This result is the foundation for proving the continuity of the full operator.\n4389: :::{prf:remark} Cloning Scope and Companion Convention\n4390: :label: rem-cloning-scope-companion-convention\n4391: \n4392: All bounds in §15.2.4–§15.2.8 are stated for the regime $k_1=|\\mathcal A(\\mathcal S_1)|\\ge 2$ (at least two alive walkers), with the \"no self‑companion\" convention (an alive walker samples companions from $\\mathcal A\\setminus\\{i\\}$). The edge case $k=1$ is handled separately in §15 (single‑survivor revival), after which analysis resumes with $k\\ge 2$. Where intermediate formulas feature denominators $k_1-1$, they are interpreted under this precondition; if a generic statement is needed, replace $k_1-1$ by $\\max(1, k_1-1)$ and invoke the $k=1$ section.\n4393: :::\n4394: #### 15.2.1. The Total Expected Cloning Action",
      "metadata": {
        "label": "def-total-expected-cloning-action"
      },
      "section": "## 16. The Cloning Transition Measure",
      "references": [],
      "raw_directive": "4385: :::\n4386: ### 15.2. Continuity of the Cloning Transition Measure\n4387: The Cloning Transition is a composite stochastic operator that determines the intermediate swarm state based on the calculated fitness potentials. Its continuity analysis is critical, as it governs how sensitively the cloning and revival mechanisms react to small changes in the swarm state. A discontinuous transition would imply chaotic behavior where small measurement fluctuations could lead to drastically different swarm configurations.\n4388: This section proves that the operator is probabilistically continuous. The analysis is centered on the key insight that the continuity of the overall transition depends on the continuity of the **total probability** of cloning. We first define this total probability, which averages over all stochasticity in the measurement pipeline, and then prove that it is a continuous function of the input swarm state. This result is the foundation for proving the continuity of the full operator.\n4389: :::{prf:remark} Cloning Scope and Companion Convention\n4390: :label: rem-cloning-scope-companion-convention\n4391: \n4392: All bounds in §15.2.4–§15.2.8 are stated for the regime $k_1=|\\mathcal A(\\mathcal S_1)|\\ge 2$ (at least two alive walkers), with the \"no self‑companion\" convention (an alive walker samples companions from $\\mathcal A\\setminus\\{i\\}$). The edge case $k=1$ is handled separately in §15 (single‑survivor revival), after which analysis resumes with $k\\ge 2$. Where intermediate formulas feature denominators $k_1-1$, they are interpreted under this precondition; if a generic statement is needed, replace $k_1-1$ by $\\max(1, k_1-1)$ and invoke the $k=1$ section.\n4393: :::\n4394: #### 15.2.1. The Total Expected Cloning Action\n4395: The ultimate probability of a \"Clone\" action for a walker depends on the outcome of the stochastic distance measurement and the random companion choice. To analyze the operator's continuity as a function of the input swarm state, we must average over all sources of randomness.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 16,
        "chapter_file": "chapter_16.json",
        "section_id": "## 16. The Cloning Transition Measure"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-cloning-probability-function",
      "title": "The Conditional Cloning Probability Function",
      "start_line": 4398,
      "end_line": 4408,
      "header_lines": [
        4399
      ],
      "content_start": 4400,
      "content_end": 4407,
      "content": "4400: $$\n4401: \n4402: \\overline{P}_{\\text{clone}}(\\mathcal{S})_i := \\mathbb{E}_{\\mathbf{d} \\sim \\mathbf{d}(\\mathcal{S})} \\left[ P_{\\text{clone}}(\\mathcal{S}, \\mathbf{V}(\\mathbf{r}(\\mathcal{S}), \\mathbf{d}))_i \\right]\n4403: \n4404: $$\n4405: This quantity is a deterministic function of the input swarm state $\\mathcal{S}$ and is the central object for the continuity analysis of the cloning stage.\n4406: :::\n4407: #### 15.2.2. The Conditional Cloning Probability Function and its Continuity",
      "metadata": {
        "label": "def-cloning-probability-function"
      },
      "section": "## 16. The Cloning Transition Measure",
      "references": [],
      "raw_directive": "4398: The **Total Expected Cloning Action** for a walker $i$, denoted $\\overline{P}_{\\text{clone}}(\\mathcal{S})_i$, is the probability that walker $i$ will be assigned the \"Clone\" action, given the swarm state $\\mathcal{S}$. It is the expectation of the **Conditional Expected Cloning Action** (Def. 15.2.3) taken over the probability distribution of the raw distance vector $\\mathbf{d} \\sim \\mathbf{d}(\\mathcal{S})$.\n4399: Let $\\mathbf{r}(\\mathcal{S})$ be the deterministic raw reward vector for state $\\mathcal{S}$, and let $\\mathbf{V}(\\mathbf{r}, \\mathbf{d})$ be the fitness potential vector generated from a specific realization of the raw measurement vectors. The total expected action is:\n4400: $$\n4401: \n4402: \\overline{P}_{\\text{clone}}(\\mathcal{S})_i := \\mathbb{E}_{\\mathbf{d} \\sim \\mathbf{d}(\\mathcal{S})} \\left[ P_{\\text{clone}}(\\mathcal{S}, \\mathbf{V}(\\mathbf{r}(\\mathcal{S}), \\mathbf{d}))_i \\right]\n4403: \n4404: $$\n4405: This quantity is a deterministic function of the input swarm state $\\mathcal{S}$ and is the central object for the continuity analysis of the cloning stage.\n4406: :::\n4407: #### 15.2.2. The Conditional Cloning Probability Function and its Continuity\n4408: The probability of a \"Clone\" action for a walker **i** with a specific companion **c** can be expressed as a deterministic function of their respective fitness potentials. This represents the probability *conditional* on a specific realization of the potential vector.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 16,
        "chapter_file": "chapter_16.json",
        "section_id": "## 16. The Cloning Transition Measure"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-expected-cloning-action",
      "title": "Conditional Expected Cloning Action",
      "start_line": 4443,
      "end_line": 4451,
      "header_lines": [
        4444
      ],
      "content_start": 4445,
      "content_end": 4450,
      "content": "4445: **Proof.**\n4446: The proof proceeds by finding the Lipschitz constant of the composition of the **clip** function and the normalized score function, $S(v_c, v_i)/p_{\\max}$. The **clip** function (min(1, max(0, x))) has a Lipschitz constant of 1. Therefore, the Lipschitz constant of $\\pi$ is bounded by the Lipschitz constant of the normalized score. We find this by bounding the partial derivatives of the score function $S(v_c, v_i)$.\n4447: 1.  **Partial Derivative with respect to $v_c$:** $\\partial S/\\partial v_c = 1/(v_i + \\varepsilon_{\\text{clone}})$. For alive walkers, [](#lem-potential-boundedness) gives $v_i\\ge V_{\\text{pot,min}}$, hence the bound $1/(V_{\\text{pot,min}} + \\varepsilon_{\\text{clone}})$. For a dead walker ($v_i=0$), the bound is $1/\\varepsilon_{\\text{clone}}$. The worst case is the dead‑walker value $1/\\varepsilon_{\\text{clone}}$.\n4448: 2.  **Partial Derivative with respect to $v_i$:** $\\partial S/\\partial v_i = (-\\varepsilon_{\\text{clone}} - v_c)/(v_i + \\varepsilon_{\\text{clone}})^2$. In magnitude, this is $\\le (V_{\\text{pot,max}} + \\varepsilon_{\\text{clone}})/(v_i + \\varepsilon_{\\text{clone}})^2$. For alive walkers, use $v_i\\ge V_{\\text{pot,min}}$; for a dead walker, $v_i=0$ yields the worst‑case bound $(V_{\\text{pot,max}} + \\varepsilon_{\\text{clone}})/\\varepsilon_{\\text{clone}}^2$.\n4449: 3.  **Combine:** Divide the worst‑case partial‑derivative bounds by $p_{\\max}$ to obtain the stated uniform Lipschitz constants $L_{\\pi,c}$ and $L_{\\pi,i}$ that cover both alive and dead cases.\n4450: **Q.E.D.**",
      "metadata": {
        "label": "def-expected-cloning-action"
      },
      "section": "## 16. The Cloning Transition Measure",
      "references": [],
      "raw_directive": "4443: :label: proof-lem-cloning-probability-lipschitz\n4444: \n4445: **Proof.**\n4446: The proof proceeds by finding the Lipschitz constant of the composition of the **clip** function and the normalized score function, $S(v_c, v_i)/p_{\\max}$. The **clip** function (min(1, max(0, x))) has a Lipschitz constant of 1. Therefore, the Lipschitz constant of $\\pi$ is bounded by the Lipschitz constant of the normalized score. We find this by bounding the partial derivatives of the score function $S(v_c, v_i)$.\n4447: 1.  **Partial Derivative with respect to $v_c$:** $\\partial S/\\partial v_c = 1/(v_i + \\varepsilon_{\\text{clone}})$. For alive walkers, [](#lem-potential-boundedness) gives $v_i\\ge V_{\\text{pot,min}}$, hence the bound $1/(V_{\\text{pot,min}} + \\varepsilon_{\\text{clone}})$. For a dead walker ($v_i=0$), the bound is $1/\\varepsilon_{\\text{clone}}$. The worst case is the dead‑walker value $1/\\varepsilon_{\\text{clone}}$.\n4448: 2.  **Partial Derivative with respect to $v_i$:** $\\partial S/\\partial v_i = (-\\varepsilon_{\\text{clone}} - v_c)/(v_i + \\varepsilon_{\\text{clone}})^2$. In magnitude, this is $\\le (V_{\\text{pot,max}} + \\varepsilon_{\\text{clone}})/(v_i + \\varepsilon_{\\text{clone}})^2$. For alive walkers, use $v_i\\ge V_{\\text{pot,min}}$; for a dead walker, $v_i=0$ yields the worst‑case bound $(V_{\\text{pot,max}} + \\varepsilon_{\\text{clone}})/\\varepsilon_{\\text{clone}}^2$.\n4449: 3.  **Combine:** Divide the worst‑case partial‑derivative bounds by $p_{\\max}$ to obtain the stated uniform Lipschitz constants $L_{\\pi,c}$ and $L_{\\pi,i}$ that cover both alive and dead cases.\n4450: **Q.E.D.**\n4451: :::",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 16,
        "chapter_file": "chapter_16.json",
        "section_id": "## 16. The Cloning Transition Measure"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-swarm-update-procedure",
      "title": "Swarm Update Procedure",
      "start_line": 4755,
      "end_line": 4813,
      "header_lines": [
        4756
      ],
      "content_start": 4757,
      "content_end": 4812,
      "content": "4757:     *   **Conclusion:** The score $S_i$ is guaranteed to be greater than any possible sampled threshold $T_{\\text{clone}}$. Walker $i$ is assigned the \"Clone\" action with probability 1. Its intermediate position is sampled from $\\mathcal{Q}_\\delta(x_j^{(t)}, \\cdot)$. This proves the second property for all $N-1$ dead walkers.\n4758: 3.  **Proof of Swarm Revival and Failure Condition:**\n4759:     *   From (1) and (2), all $N$ walkers persist or are cloned. As per the **Swarm Update Procedure**, all walkers in the intermediate swarm $\\mathcal{S}_{t+0.5}$ are assigned a status of alive. Thus, $|\\mathcal{A}(\\mathcal{S}_{t+0.5})| = N$ is guaranteed.\n4760:     *   The final state $\\mathcal{S}_{t+1}$ is determined by applying the **Perturbation Operator** and **Status Update Operator** to $\\mathcal{S}_{t+0.5}$. The only way for the swarm to become extinct is if every walker $i \\in \\{1, \\dots, N\\}$ has its new position $x_i^{(t+1)}$ fall within the invalid domain.\n4761:     *   Since the perturbations are independent for each walker, the probability of total swarm failure is the product of the individual probabilities of failure. This isolates the extinction risk to a single, quantifiable event, contingent entirely on the outcomes of the **N** post-revival random walks. This proves the third property.\n4762: **Q.E.D.**\n4763: :::\n4764: ## 18. Swarm Update Operator: A Composition of Measures\n4765: ### 17.1 Definition: Swarm Update Operator\n4766: :::{prf:definition} Swarm Update Procedure\n4767: :label: def-swarm-update-procedure\n4768: The **swarm update operator** $\\Psi: \\Sigma_N \\to \\mathcal{P}(\\Sigma_N)$ defines the one-step transition measure of the Markov process, evolving a swarm state $\\mathcal{S}_t$ to a probability distribution over the subsequent state $\\mathcal{S}_{t+1}$. A single realization $\\mathcal{S}_{t+1} \\sim \\Psi(\\mathcal{S}_t, \\cdot)$ is generated by the sequential application of the following operators.\n4769: 1.  **Stage 1: Cemetery State Absorption**\n4770:     *   If the input swarm is in the absorbing cemetery state, $|\\mathcal{A}(\\mathcal{S}_t)|=0$, the process terminates. The operator returns a Dirac measure on the input state: $\\Psi(\\mathcal{S}_t, \\cdot) = \\delta_{\\mathcal{S}_t}(\\cdot)$, such that $\\mathcal{S}_{t+1} = \\mathcal{S}_t$. Otherwise, the transition is defined by the composition of the following stages.\n4771: 2.  **Stage 2: Stochastic Measurement and Potential Calculation**\n4772:     This stage maps the input swarm state $\\mathcal{S}_t$ to a single, fixed N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$, which is then used as a deterministic parameter for the remainder of the timestep.\n4773:     *   **a. Raw Measurement (Stochastic):**\n4774:         *   The raw reward vector for the alive set, $\\mathbf{r}_{\\mathcal{A}}$, is generated deterministically: $\\mathbf{r}_{\\mathcal{A}} := (R(x_i))_{i \\in \\mathcal{A}_t}$.\n4775:         *   The raw distance vector, $\\mathbf{d}_{\\mathcal{A}}$, is generated stochastically by first sampling a *potential companion* $c_{\\text{pot}}(i) \\sim \\mathbb{C}_i(\\mathcal{S}_t)$ for each alive walker $i \\in \\mathcal{A}_t$ (from Def. 7.1), then computing: $\\mathbf{d}_{\\mathcal{A}} := (d_{\\text{alg}}(x_i, x_{c_{\\text{pot}}(i)}))_{i \\in \\mathcal{A}_t}$.\n4776:     *   **b. Potential Vector Calculation (Deterministic):**\n4777:         *   Using the single realization of the raw vectors $(\\mathbf{r}_{\\mathcal{A}}, \\mathbf{d}_{\\mathcal{A}})$ from the previous step, the potential vector for the alive set is computed by applying the deterministic **Rescaled Potential Operator for the Alive Set** ([](#def-alive-set-potential-operator)):\n4778: $$\n4779: \n4780:             \\mathbf{V}_{\\mathcal{A}} \\leftarrow V_{\\text{op},\\mathcal{A}}(\\mathcal{S}_t, \\mathbf{r}_{\\mathcal{A}}, \\mathbf{d}_{\\mathcal{A}})\n4781: \n4782: \n4783: $$\n4784: *   The full N-dimensional fitness potential vector is then assembled using the deterministic **Swarm Potential Assembly Operator** ([](#def-swarm-potential-assembly-operator)):\n4785: $$\n4786: \n4787:             \\mathbf{V}_{\\text{fit}} \\leftarrow A_{\\text{pot}}(\\mathcal{S}_t, \\mathbf{V}_{\\mathcal{A}})\n4788: \n4789: \n4790: $$\n4791: 3.  **Stage 3: Cloning Transition**\n4792:     This stage maps the input swarm $\\mathcal{S}_t$ and the fixed potential vector $\\mathbf{V}_{\\text{fit}}$ to a distribution over an intermediate swarm state $\\mathcal{S}_{t+0.5}$. The process is defined as a product measure over the N walkers. For each walker $i \\in \\{1, \\dots, N\\}$:\n4793:     *   **a. Sample Cloning Companion:** An independent *cloning companion* index, $c_{\\text{clone}}(i)$, is sampled from the **Companion Selection Measure** $\\mathbb{C}_i(\\mathcal{S}_t)$.\n4794:     *   **b. Determine Action:** An action $a_i \\in \\{\\text{Clone}, \\text{Persist}\\}$ is determined via the **Stochastic Threshold Cloning** procedure (Def. 15.2), which compares the walker's score against a random threshold sampled from $[0, p_{\\max}]$.\n4795:     *   **c. Sample Intermediate Position:** A **Conditional Intermediate Position Measure** $\\mathbb{M}_i$ on $\\mathcal{X}$ is defined based on the determined action:\n4796: $$\n4797: \n4798:         \\mathbb{M}_i(\\cdot | a_i) :=\n4799:         \\begin{cases}\n4800:         \\mathcal{Q}_\\delta(x_{c_{\\text{clone}}(i)}^{(t)}, \\cdot) & \\text{if } a_i = \\text{Clone} \\\\\n4801:         \\delta_{x_i^{(t)}}(\\cdot) & \\text{if } a_i = \\text{Persist}\n4802:         \\end{cases}\n4803: \n4804: \n4805: $$\n4806: where $\\mathcal{Q}_\\delta$ is the **Cloning Measure** ([](#def-cloning-measure)) and $\\delta_{x}$ is the Dirac delta measure. The intermediate position is then sampled: $x_i^{(t+0.5)} \\sim \\mathbb{M}_i(\\cdot | a_i)$.\n4807:     *   **d. Form Intermediate Walker:** The intermediate status is set deterministically to alive, $s_i^{(t+0.5)} \\leftarrow 1$, yielding the intermediate walker $w_i^{(t+0.5)} = (x_i^{(t+0.5)}, s_i^{(t+0.5)})$. The intermediate swarm is $\\mathcal{S}_{t+0.5} = (w_i^{(t+0.5)})_{i=1}^N$.\n4808: 4.  **Stage 4: Perturbation and Final Status Update**\n4809:     The final swarm state $\\mathcal{S}_{t+1}$ is generated by the composition of the final two operators.\n4810:     *   **a. Perturbation:** The positions of the intermediate swarm are updated by sampling from the measure defined by the **Perturbation Operator** ([](#def-perturbation-operator)), resulting in a new swarm $\\mathcal{S}_{\\text{pert}}$:\n4811: $$\n4812: ",
      "metadata": {
        "label": "def-swarm-update-procedure"
      },
      "section": "## 18. Swarm Update Operator: A Composition of Measures",
      "references": [],
      "raw_directive": "4755: $$\n4756: Therefore, we have the following guaranteed inequality: $S_i \\ge \\frac{\\eta^{\\alpha+\\beta}}{\\varepsilon_{\\text{clone}}} > p_{\\max} \\ge T_{\\text{clone}}$.\n4757:     *   **Conclusion:** The score $S_i$ is guaranteed to be greater than any possible sampled threshold $T_{\\text{clone}}$. Walker $i$ is assigned the \"Clone\" action with probability 1. Its intermediate position is sampled from $\\mathcal{Q}_\\delta(x_j^{(t)}, \\cdot)$. This proves the second property for all $N-1$ dead walkers.\n4758: 3.  **Proof of Swarm Revival and Failure Condition:**\n4759:     *   From (1) and (2), all $N$ walkers persist or are cloned. As per the **Swarm Update Procedure**, all walkers in the intermediate swarm $\\mathcal{S}_{t+0.5}$ are assigned a status of alive. Thus, $|\\mathcal{A}(\\mathcal{S}_{t+0.5})| = N$ is guaranteed.\n4760:     *   The final state $\\mathcal{S}_{t+1}$ is determined by applying the **Perturbation Operator** and **Status Update Operator** to $\\mathcal{S}_{t+0.5}$. The only way for the swarm to become extinct is if every walker $i \\in \\{1, \\dots, N\\}$ has its new position $x_i^{(t+1)}$ fall within the invalid domain.\n4761:     *   Since the perturbations are independent for each walker, the probability of total swarm failure is the product of the individual probabilities of failure. This isolates the extinction risk to a single, quantifiable event, contingent entirely on the outcomes of the **N** post-revival random walks. This proves the third property.\n4762: **Q.E.D.**\n4763: :::\n4764: ## 18. Swarm Update Operator: A Composition of Measures\n4765: ### 17.1 Definition: Swarm Update Operator\n4766: :::{prf:definition} Swarm Update Procedure\n4767: :label: def-swarm-update-procedure\n4768: The **swarm update operator** $\\Psi: \\Sigma_N \\to \\mathcal{P}(\\Sigma_N)$ defines the one-step transition measure of the Markov process, evolving a swarm state $\\mathcal{S}_t$ to a probability distribution over the subsequent state $\\mathcal{S}_{t+1}$. A single realization $\\mathcal{S}_{t+1} \\sim \\Psi(\\mathcal{S}_t, \\cdot)$ is generated by the sequential application of the following operators.\n4769: 1.  **Stage 1: Cemetery State Absorption**\n4770:     *   If the input swarm is in the absorbing cemetery state, $|\\mathcal{A}(\\mathcal{S}_t)|=0$, the process terminates. The operator returns a Dirac measure on the input state: $\\Psi(\\mathcal{S}_t, \\cdot) = \\delta_{\\mathcal{S}_t}(\\cdot)$, such that $\\mathcal{S}_{t+1} = \\mathcal{S}_t$. Otherwise, the transition is defined by the composition of the following stages.\n4771: 2.  **Stage 2: Stochastic Measurement and Potential Calculation**\n4772:     This stage maps the input swarm state $\\mathcal{S}_t$ to a single, fixed N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$, which is then used as a deterministic parameter for the remainder of the timestep.\n4773:     *   **a. Raw Measurement (Stochastic):**\n4774:         *   The raw reward vector for the alive set, $\\mathbf{r}_{\\mathcal{A}}$, is generated deterministically: $\\mathbf{r}_{\\mathcal{A}} := (R(x_i))_{i \\in \\mathcal{A}_t}$.\n4775:         *   The raw distance vector, $\\mathbf{d}_{\\mathcal{A}}$, is generated stochastically by first sampling a *potential companion* $c_{\\text{pot}}(i) \\sim \\mathbb{C}_i(\\mathcal{S}_t)$ for each alive walker $i \\in \\mathcal{A}_t$ (from Def. 7.1), then computing: $\\mathbf{d}_{\\mathcal{A}} := (d_{\\text{alg}}(x_i, x_{c_{\\text{pot}}(i)}))_{i \\in \\mathcal{A}_t}$.\n4776:     *   **b. Potential Vector Calculation (Deterministic):**\n4777:         *   Using the single realization of the raw vectors $(\\mathbf{r}_{\\mathcal{A}}, \\mathbf{d}_{\\mathcal{A}})$ from the previous step, the potential vector for the alive set is computed by applying the deterministic **Rescaled Potential Operator for the Alive Set** ([](#def-alive-set-potential-operator)):\n4778: $$\n4779: \n4780:             \\mathbf{V}_{\\mathcal{A}} \\leftarrow V_{\\text{op},\\mathcal{A}}(\\mathcal{S}_t, \\mathbf{r}_{\\mathcal{A}}, \\mathbf{d}_{\\mathcal{A}})\n4781: \n4782: \n4783: $$\n4784: *   The full N-dimensional fitness potential vector is then assembled using the deterministic **Swarm Potential Assembly Operator** ([](#def-swarm-potential-assembly-operator)):\n4785: $$\n4786: \n4787:             \\mathbf{V}_{\\text{fit}} \\leftarrow A_{\\text{pot}}(\\mathcal{S}_t, \\mathbf{V}_{\\mathcal{A}})\n4788: \n4789: \n4790: $$\n4791: 3.  **Stage 3: Cloning Transition**\n4792:     This stage maps the input swarm $\\mathcal{S}_t$ and the fixed potential vector $\\mathbf{V}_{\\text{fit}}$ to a distribution over an intermediate swarm state $\\mathcal{S}_{t+0.5}$. The process is defined as a product measure over the N walkers. For each walker $i \\in \\{1, \\dots, N\\}$:\n4793:     *   **a. Sample Cloning Companion:** An independent *cloning companion* index, $c_{\\text{clone}}(i)$, is sampled from the **Companion Selection Measure** $\\mathbb{C}_i(\\mathcal{S}_t)$.\n4794:     *   **b. Determine Action:** An action $a_i \\in \\{\\text{Clone}, \\text{Persist}\\}$ is determined via the **Stochastic Threshold Cloning** procedure (Def. 15.2), which compares the walker's score against a random threshold sampled from $[0, p_{\\max}]$.\n4795:     *   **c. Sample Intermediate Position:** A **Conditional Intermediate Position Measure** $\\mathbb{M}_i$ on $\\mathcal{X}$ is defined based on the determined action:\n4796: $$\n4797: \n4798:         \\mathbb{M}_i(\\cdot | a_i) :=\n4799:         \\begin{cases}\n4800:         \\mathcal{Q}_\\delta(x_{c_{\\text{clone}}(i)}^{(t)}, \\cdot) & \\text{if } a_i = \\text{Clone} \\\\\n4801:         \\delta_{x_i^{(t)}}(\\cdot) & \\text{if } a_i = \\text{Persist}\n4802:         \\end{cases}\n4803: \n4804: \n4805: $$\n4806: where $\\mathcal{Q}_\\delta$ is the **Cloning Measure** ([](#def-cloning-measure)) and $\\delta_{x}$ is the Dirac delta measure. The intermediate position is then sampled: $x_i^{(t+0.5)} \\sim \\mathbb{M}_i(\\cdot | a_i)$.\n4807:     *   **d. Form Intermediate Walker:** The intermediate status is set deterministically to alive, $s_i^{(t+0.5)} \\leftarrow 1$, yielding the intermediate walker $w_i^{(t+0.5)} = (x_i^{(t+0.5)}, s_i^{(t+0.5)})$. The intermediate swarm is $\\mathcal{S}_{t+0.5} = (w_i^{(t+0.5)})_{i=1}^N$.\n4808: 4.  **Stage 4: Perturbation and Final Status Update**\n4809:     The final swarm state $\\mathcal{S}_{t+1}$ is generated by the composition of the final two operators.\n4810:     *   **a. Perturbation:** The positions of the intermediate swarm are updated by sampling from the measure defined by the **Perturbation Operator** ([](#def-perturbation-operator)), resulting in a new swarm $\\mathcal{S}_{\\text{pert}}$:\n4811: $$\n4812: \n4813:         \\mathcal{S}_{\\text{pert}} \\sim \\Psi_{\\text{pert}}(\\mathcal{S}_{t+0.5}, \\cdot)",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 18,
        "chapter_file": "chapter_18.json",
        "section_id": "## 18. Swarm Update Operator: A Composition of Measures"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-w2-output-metric",
      "title": "Wasserstein-2 on the output space (quotient)",
      "start_line": 5114,
      "end_line": 5123,
      "header_lines": [
        5115
      ],
      "content_start": 5116,
      "content_end": 5122,
      "content": "5116: **Q.E.D.**\n5117: :::\n5118: :::{prf:remark}\n5119: :label: rem-remark-context-4997\n5120: Local vs global: for $V\\in[0,1]$ all sub-linear powers are $\\le 1$ and can be absorbed in a constant; for $V\\ge 1$ every sub-linear term is bounded above by the term with exponent $p_{\\max}$. This is the only global (uniform in $V\\ge 0$) way to replace a sum of distinct powers by a single power, and it justifies using $\\alpha_H^{\\mathrm{global}}=\\max(\\tfrac12,\\alpha_B)$ when aggregating sub-linear exponents.\n5121: :::\n5122: ##### 17.2.4.4. W2 Coupling: Removing Constant Offsets",
      "metadata": {
        "label": "def-w2-output-metric"
      },
      "section": "## 18. Swarm Update Operator: A Composition of Measures",
      "references": [],
      "raw_directive": "5114: $$\n5115: Combining the two cases gives the stated global bound. This is sharp in the sense that no uniform inequality of the form $\\sum_k A_k V^{p_k} \\le C\\,V^{q}+K$ can hold with $q<p_{\\max}$ for all $V\\ge 0$.\n5116: **Q.E.D.**\n5117: :::\n5118: :::{prf:remark}\n5119: :label: rem-remark-context-4997\n5120: Local vs global: for $V\\in[0,1]$ all sub-linear powers are $\\le 1$ and can be absorbed in a constant; for $V\\ge 1$ every sub-linear term is bounded above by the term with exponent $p_{\\max}$. This is the only global (uniform in $V\\ge 0$) way to replace a sum of distinct powers by a single power, and it justifies using $\\alpha_H^{\\mathrm{global}}=\\max(\\tfrac12,\\alpha_B)$ when aggregating sub-linear exponents.\n5121: :::\n5122: ##### 17.2.4.4. W2 Coupling: Removing Constant Offsets\n5123: :label: subsec-w2-coupling-offset-removal",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 18,
        "chapter_file": "chapter_18.json",
        "section_id": "## 18. Swarm Update Operator: A Composition of Measures"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-fragile-swarm-instantiation",
      "title": "Fragile Swarm Instantiation",
      "start_line": 5232,
      "end_line": 5242,
      "header_lines": [
        5233
      ],
      "content_start": 5234,
      "content_end": 5241,
      "content": "5234: :::{admonition} Analytical coupling vs. in‑run independence\n5235: :class: note\n5236: We compare two runs via synchronous coupling (same noise seeds) to control $W_2$ distances. This is a proof device only. Within a single run and timestep, per‑walker random inputs remain independent (Assumption A). The $W_2$‑optimized bound and the expectation‑based bound are distinct results proved with different couplings; the former eliminates additive offsets at zero input distance.\n5237: :::\n5238: :::\n5239: ## 19. Fragile Gas: The Algorithm's Execution\n5240: The preceding sections have defined all the necessary mathematical objects, operators, and axiomatic constraints that constitute the Fragile framework. This final section formally defines the algorithm's execution, describing how the one-step **Swarm Update Operator** is used to evolve a swarm over time.\n5241: ### 18.1 The Fragile Swarm Instantiation",
      "metadata": {
        "label": "def-fragile-swarm-instantiation"
      },
      "section": "## 19. Fragile Gas: The Algorithm's Execution",
      "references": [
        "02_euclidean_gas"
      ],
      "raw_directive": "5232: All selection, cloning and aggregation maps are Borel on $\\Sigma_N$, being built from basic Borel operations (finite products, CDF inversion, order statistics, and continuous compositions).\n5233: :::\n5234: :::{admonition} Analytical coupling vs. in‑run independence\n5235: :class: note\n5236: We compare two runs via synchronous coupling (same noise seeds) to control $W_2$ distances. This is a proof device only. Within a single run and timestep, per‑walker random inputs remain independent (Assumption A). The $W_2$‑optimized bound and the expectation‑based bound are distinct results proved with different couplings; the former eliminates additive offsets at zero input distance.\n5237: :::\n5238: :::\n5239: ## 19. Fragile Gas: The Algorithm's Execution\n5240: The preceding sections have defined all the necessary mathematical objects, operators, and axiomatic constraints that constitute the Fragile framework. This final section formally defines the algorithm's execution, describing how the one-step **Swarm Update Operator** is used to evolve a swarm over time.\n5241: ### 18.1 The Fragile Swarm Instantiation\n5242: To distinguish the general analytical framework from a specific, runnable instance of the algorithm, we define a **Fragile Swarm**. This object is a complete instantiation of the system, where all user-selectable parameters, functions, and measures have been fixed.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 19,
        "chapter_file": "chapter_19.json",
        "section_id": "## 19. Fragile Gas: The Algorithm's Execution"
      }
    },
    {
      "directive_type": "definition",
      "label": "def-fragile-gas-algorithm",
      "title": "The Fragile Gas Algorithm",
      "start_line": 5245,
      "end_line": 5265,
      "header_lines": [
        5246
      ],
      "content_start": 5247,
      "content_end": 5264,
      "content": "5247: 2.  **The Core Algorithmic Parameters:** A specific, fixed set of all tunable values, including the number of walkers $N$, dynamics weights $(\\alpha, \\beta)$, noise scales $(\\sigma, \\delta)$, and all regulation and threshold parameters $(p_{\\max}, \\eta, \\varepsilon_{\\text{std}}, z_{\\max}, \\varepsilon_{\\text{clone}})$.\n5248: 3.  **The Concrete Operator Choices:** The specific, user-chosen functions for the **Reward Aggregation Operator** ($R_{agg}$) and the **Distance Aggregation Operator** ($M_D$).\n5249: 4.  **The Concrete Noise Measure Choices:** The specific, user-chosen probability measures for the **Perturbation Measure** ($\\mathcal{P}_\\sigma$) and the **Cloning Measure** ($\\mathcal{Q}_\\delta$).\n5250: A Fragile Swarm instantiation must satisfy all axioms defined in Section 2 for the analytical framework to apply. It represents a single, well-defined point in the algorithm's vast parameter space.\n5251: \n5252: The concrete instantiation for the Euclidean Gas is provided in {prf:ref}`02_euclidean_gas`, where all parameters and operators are specified with explicit values.\n5253: :::\n5254: ### 18.2 The Fragile Gas Algorithm\n5255: The **Fragile Gas** is the algorithm that describes the temporal evolution of a swarm of N walkers. It generates a trajectory of swarm states by repeatedly applying the Swarm Update Operator, which is fully parameterized by a specific Fragile Swarm instantiation.\n5256: :::{prf:definition} The Fragile Gas Algorithm\n5257: :label: def-fragile-gas-algorithm\n5258: The **Fragile Gas Algorithm** generates a sequence of swarm states (a trajectory) by evolving an initial swarm over a discrete number of timesteps.\n5259: **Inputs:**\n5260: *   A **Fragile Swarm Instantiation**, $\\mathcal{F}$, which fixes all parameters and operators.\n5261: *   An **initial swarm state**, $\\mathcal{S}_0 \\in \\Sigma_N$.\n5262: *   A total number of **timesteps**, $T \\in \\mathbb{N}$.\n5263: **Process:**\n5264: The algorithm generates a trajectory of swarm states, $(\\mathcal{S}_t)_{t=0}^T$, as a realization of a time-homogeneous Markov chain on the state space $\\Sigma_N$.",
      "metadata": {
        "label": "def-fragile-gas-algorithm"
      },
      "section": "## 19. Fragile Gas: The Algorithm's Execution",
      "references": [
        "02_euclidean_gas"
      ],
      "raw_directive": "5245: A **Fragile Swarm**, denoted $\\mathcal{F}$, is a tuple that encapsulates a complete and fixed configuration of the algorithm. It contains:\n5246: 1.  **The Foundational & Environmental Parameters:** The full set of environmental structures, including the State Space $(\\mathcal{X}, d_{\\mathcal{X}})$, Valid Domain $\\mathcal{X}_{\\mathrm{valid}}$, Reward Function $R$, Algorithmic Space $(\\mathcal{Y}, d_{\\mathcal{Y}})$, and Projection Map $\\varphi$.\n5247: 2.  **The Core Algorithmic Parameters:** A specific, fixed set of all tunable values, including the number of walkers $N$, dynamics weights $(\\alpha, \\beta)$, noise scales $(\\sigma, \\delta)$, and all regulation and threshold parameters $(p_{\\max}, \\eta, \\varepsilon_{\\text{std}}, z_{\\max}, \\varepsilon_{\\text{clone}})$.\n5248: 3.  **The Concrete Operator Choices:** The specific, user-chosen functions for the **Reward Aggregation Operator** ($R_{agg}$) and the **Distance Aggregation Operator** ($M_D$).\n5249: 4.  **The Concrete Noise Measure Choices:** The specific, user-chosen probability measures for the **Perturbation Measure** ($\\mathcal{P}_\\sigma$) and the **Cloning Measure** ($\\mathcal{Q}_\\delta$).\n5250: A Fragile Swarm instantiation must satisfy all axioms defined in Section 2 for the analytical framework to apply. It represents a single, well-defined point in the algorithm's vast parameter space.\n5251: \n5252: The concrete instantiation for the Euclidean Gas is provided in {prf:ref}`02_euclidean_gas`, where all parameters and operators are specified with explicit values.\n5253: :::\n5254: ### 18.2 The Fragile Gas Algorithm\n5255: The **Fragile Gas** is the algorithm that describes the temporal evolution of a swarm of N walkers. It generates a trajectory of swarm states by repeatedly applying the Swarm Update Operator, which is fully parameterized by a specific Fragile Swarm instantiation.\n5256: :::{prf:definition} The Fragile Gas Algorithm\n5257: :label: def-fragile-gas-algorithm\n5258: The **Fragile Gas Algorithm** generates a sequence of swarm states (a trajectory) by evolving an initial swarm over a discrete number of timesteps.\n5259: **Inputs:**\n5260: *   A **Fragile Swarm Instantiation**, $\\mathcal{F}$, which fixes all parameters and operators.\n5261: *   An **initial swarm state**, $\\mathcal{S}_0 \\in \\Sigma_N$.\n5262: *   A total number of **timesteps**, $T \\in \\mathbb{N}$.\n5263: **Process:**\n5264: The algorithm generates a trajectory of swarm states, $(\\mathcal{S}_t)_{t=0}^T$, as a realization of a time-homogeneous Markov chain on the state space $\\Sigma_N$.\n5265: Let $\\Psi_{\\mathcal{F}}$ be the **Swarm Update Operator** ([](#def-swarm-update-procedure)) fully parameterized by the choices fixed in the Fragile Swarm $\\mathcal{F}$.",
      "_registry_context": {
        "stage": "directives",
        "document_id": "01_fragile_gas_framework",
        "chapter_index": 19,
        "chapter_file": "chapter_19.json",
        "section_id": "## 19. Fragile Gas: The Algorithm's Execution"
      }
    }
  ]
}