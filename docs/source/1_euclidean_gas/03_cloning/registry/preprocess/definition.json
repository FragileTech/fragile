[
  {
    "label": "def-single-swarm-space",
    "type": "definition",
    "title": "Single-Walker and Swarm State Spaces",
    "term": "Single-Walker and Swarm State Spaces",
    "object_type": "state space",
    "nl_definition": "A walker is a tuple combining position (and velocity in the Euclidean Gas) with survival status; a swarm is an N-tuple of such walker states, and the single-swarm state space is the Cartesian product of individual walker state spaces.",
    "content_markdown": ":label: def-single-swarm-space\n\n1.  A **walker** is a tuple $(x, s)$, where $x \\in \\mathcal{X}$ is its position in a state space and $s \\in \\{0, 1\\}$ is its survival status. For the Euclidean Gas, this is extended to include a velocity component, making the **full state** of a single walker a tuple $(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}$. We refer to $(x,v)$ as the **kinematic state**.\n\n2.  A **swarm configuration**, $S$, is an N-tuple of walker states:\n\n\n\n$$\nS := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)\n$$\n\n3.  The **single-swarm state space**, denoted $\\Sigma_N$, is the Cartesian product of the per-walker state spaces:\n\n\n\n$$\n\\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N.",
    "raw_directive": "106: The fundamental unit of the system is the walker, and a collection of these walkers constitutes a swarm. We begin by defining their state spaces abstractly, in a manner consistent with the Fragile Gas framework.\n107: \n108: :::{prf:definition} Single-Walker and Swarm State Spaces\n109: :label: def-single-swarm-space\n110: \n111: 1.  A **walker** is a tuple $(x, s)$, where $x \\in \\mathcal{X}$ is its position in a state space and $s \\in \\{0, 1\\}$ is its survival status. For the Euclidean Gas, this is extended to include a velocity component, making the **full state** of a single walker a tuple $(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}$. We refer to $(x,v)$ as the **kinematic state**.\n112: \n113: 2.  A **swarm configuration**, $S$, is an N-tuple of walker states:\n114: \n115: \n116: \n117: $$\n118: S := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)\n119: $$\n120: \n121: 3.  The **single-swarm state space**, denoted $\\Sigma_N$, is the Cartesian product of the per-walker state spaces:\n122: \n123: \n124: \n125: $$\n126: \\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N.\n127: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "A walker is a tuple (x, s) where x \u2208 \\mathcal{X} is position and s \u2208 {0, 1} is survival status.",
        "latex": "(x, s),\\ x \\in \\mathcal{X},\\ s \\in \\{0, 1\\}"
      },
      {
        "type": null,
        "text": "In the Euclidean Gas, the full state is (x, v, s) \u2208 \u211d^d \u00d7 \u211d^d \u00d7 {0, 1}, with kinematic state (x, v).",
        "latex": "(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}"
      },
      {
        "type": null,
        "text": "A swarm configuration S is an N-tuple of walker states.",
        "latex": "S := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)"
      },
      {
        "type": null,
        "text": "The single-swarm state space \u03a3_N is the Cartesian product.",
        "latex": "\\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N"
      }
    ],
    "properties": [
      {
        "name": "Cartesian product structure",
        "description": "The swarm state space is the product of individual walker state spaces, allowing independent variation of each walker's state."
      },
      {
        "name": "Finite dimensionality",
        "description": "For fixed N and d, \u03a3_N is a finite-dimensional space with 2^N possible survival configurations."
      }
    ],
    "parameters": [
      {
        "symbol": "N",
        "name": "number of walkers",
        "description": "The number of walkers in the swarm configuration",
        "constraints": [
          "N is a positive integer"
        ],
        "tags": [
          "swarm size"
        ]
      },
      {
        "symbol": "d",
        "name": "spatial dimension",
        "description": "The dimension of the position and velocity spaces in the Euclidean Gas",
        "constraints": [
          "d is a positive integer"
        ],
        "tags": [
          "dimension"
        ]
      },
      {
        "symbol": "\\mathcal{X}",
        "name": "position space",
        "description": "General state space for walker position in the abstract Fragile Gas",
        "constraints": [
          "\\mathcal{X} is a measurable space"
        ],
        "tags": [
          "position",
          "abstract"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "The definition is abstract for the Fragile Gas framework using general \\mathcal{X}, but specialized to Euclidean Gas with velocity in \u211d^d."
      },
      {
        "type": "extension",
        "text": "The kinematic state (x, v) captures position and velocity, relevant for motion dynamics in the Euclidean case."
      }
    ],
    "related_refs": [],
    "tags": [
      "walker",
      "swarm",
      "state space",
      "survival status",
      "kinematic state",
      "Euclidean Gas",
      "Fragile Gas"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 106,
      "end_line": 127,
      "content_start": 109,
      "content_end": 126,
      "header_lines": [
        107
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-single-swarm-space"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-coupled-state-space",
    "type": "definition",
    "title": "The Coupled State Space",
    "term": "coupled state space",
    "object_type": "set",
    "nl_definition": "The Cartesian product of the state space \u03a3_N with itself, consisting of ordered pairs (S\u2081, S\u2082) where each S_i is a configuration of N particles with positions, velocities, and spins.",
    "content_markdown": ":label: def-coupled-state-space\n\nThe **coupled state space** for the Euclidean Gas is the Cartesian product $\\Sigma_N \\times \\Sigma_N$, where $\\Sigma_N$ is defined in {prf:ref}`def-single-swarm-space`. An element of this space is an ordered pair of swarm configurations, $(S_1, S_2)$, where:\n\n$$\nS_1 = \\left( (x_{1,1}, v_{1,1}, s_{1,1}), \\dots, (x_{1,N}, v_{1,N}, s_{1,N}) \\right) \\in \\Sigma_N,\n$$\n\n$$\nS_2 = \\left( (x_{2,1}, v_{2,1}, s_{2,1}), \\dots, (x_{2,N}, v_{2,N}, s_{2,N}) \\right) \\in \\Sigma_N.\n$$",
    "raw_directive": "144: This synchronous coupling is chosen because it is designed to minimize the distance between the two trajectories, making it the most suitable choice for proving a contraction. All expectations $\\mathbb{E}[\\cdot]$ in the subsequent analysis are taken with respect to this single, shared source of randomness.\n145: \n146: :::{prf:definition} The Coupled State Space\n147: :label: def-coupled-state-space\n148: \n149: The **coupled state space** for the Euclidean Gas is the Cartesian product $\\Sigma_N \\times \\Sigma_N$, where $\\Sigma_N$ is defined in {prf:ref}`def-single-swarm-space`. An element of this space is an ordered pair of swarm configurations, $(S_1, S_2)$, where:\n150: \n151: $$\n152: S_1 = \\left( (x_{1,1}, v_{1,1}, s_{1,1}), \\dots, (x_{1,N}, v_{1,N}, s_{1,N}) \\right) \\in \\Sigma_N,\n153: $$\n154: \n155: $$\n156: S_2 = \\left( (x_{2,1}, v_{2,1}, s_{2,1}), \\dots, (x_{2,N}, v_{2,N}, s_{2,N}) \\right) \\in \\Sigma_N.\n157: $$\n158: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "S\u2081 \u2208 \u03a3_N and S\u2082 \u2208 \u03a3_N",
        "latex": "S_1 \\in \\Sigma_N, \\; S_2 \\in \\Sigma_N"
      },
      {
        "type": null,
        "text": "Each S_i = ((x_{i,1}, v_{i,1}, s_{i,1}), \u2026, (x_{i,N}, v_{i,N}, s_{i,N}))",
        "latex": "S_i = \\left( (x_{i,1}, v_{i,1}, s_{i,1}), \\dots, (x_{i,N}, v_{i,N}, s_{i,N}) \\right) \\in \\Sigma_N \\; (i=1,2)"
      }
    ],
    "properties": [
      {
        "name": "product structure",
        "description": "Direct product of two identical state spaces for comparing trajectories"
      },
      {
        "name": "element composition",
        "description": "Pairs of N-tuples, each tuple containing position x, velocity v, and spin s for particles"
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "Used in synchronous coupling to minimize distance between trajectories; expectations taken w.r.t. shared randomness"
      }
    ],
    "related_refs": [],
    "tags": [
      "coupled state space",
      "Euclidean gas",
      "Cartesian product",
      "swarm configuration",
      "synchronous coupling"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 144,
      "end_line": 158,
      "content_start": 147,
      "content_end": 157,
      "header_lines": [
        145
      ]
    },
    "references": [
      "def-single-swarm-space"
    ],
    "metadata": {
      "label": "def-coupled-state-space"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-state-difference-vectors",
    "type": "definition",
    "title": "State Difference Vectors",
    "term": "state difference vectors",
    "object_type": "vectors",
    "nl_definition": "For a pair of swarm states (S\u2081, S\u2082) in \u03a3_N \u00d7 \u03a3_N, the state difference vectors consist of the position difference \u0394x_i = x_{1,i} - x_{2,i} and velocity difference \u0394v_i = v_{1,i} - v_{2,i} for each walker i from 1 to N, each in \u211d^d.",
    "content_markdown": ":label: def-state-difference-vectors\n\nFor any element $(S_1, S_2) \\in \\Sigma_N \\times \\Sigma_N$, we define the **state difference vectors** for each walker index $i \\in \\{1, \\ldots, N\\}$ as follows:\n\n1.  The **position difference vector** for walker $i$ is:\n\n\n\n$$\n\\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d\n$$\n\n2.  The **velocity difference vector** for walker $i$ is:\n\n\n\n$$\n\\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d\n$$",
    "raw_directive": "164: The core of the hypocoercive analysis is not the absolute state of the swarms, but the *difference* between them (measured element-wise). We formally define the vectors that capture this relative configuration.\n165: \n166: :::{prf:definition} State Difference Vectors\n167: :label: def-state-difference-vectors\n168: \n169: For any element $(S_1, S_2) \\in \\Sigma_N \\times \\Sigma_N$, we define the **state difference vectors** for each walker index $i \\in \\{1, \\ldots, N\\}$ as follows:\n170: \n171: 1.  The **position difference vector** for walker $i$ is:\n172: \n173: \n174: \n175: $$\n176: \\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d\n177: $$\n178: \n179: 2.  The **velocity difference vector** for walker $i$ is:\n180: \n181: \n182: \n183: $$\n184: \\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d\n185: $$\n186: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Position difference vector",
        "latex": "\\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d"
      },
      {
        "type": null,
        "text": "Velocity difference vector",
        "latex": "\\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Index of the walker in the swarm",
        "constraints": [
          "i \u2208 {1, \u2026, N}"
        ],
        "tags": [
          "index",
          "walker"
        ]
      },
      {
        "symbol": "N",
        "name": "number of walkers",
        "description": "Total number of walkers in each swarm",
        "constraints": [
          "N \u2265 1"
        ],
        "tags": [
          "dimension",
          "size"
        ]
      },
      {
        "symbol": "d",
        "name": "spatial dimension",
        "description": "Dimension of the position and velocity spaces",
        "constraints": [
          "d \u2265 1"
        ],
        "tags": [
          "dimension",
          "space"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "state difference",
      "position difference",
      "velocity difference",
      "swarm",
      "walker",
      "hypocoercivity"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 164,
      "end_line": 186,
      "content_start": 167,
      "content_end": 185,
      "header_lines": [
        165
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-state-difference-vectors"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-barycentres-and-centered-vectors",
    "type": "definition",
    "title": "Barycentres and Centered Vectors (Alive Walkers Only)",
    "term": "barycentres and centered vectors",
    "object_type": "centers and deviations",
    "nl_definition": "For each swarm in a coupled state, the barycentres are the average positions and velocities computed only over alive walkers, and the centered vectors are the individual alive walkers' positions and velocities relative to these swarm barycentres.",
    "content_markdown": ":label: def-barycentres-and-centered-vectors\n\nFor each swarm $k \\in \\{1, 2\\}$ (see {prf:ref}`def-single-swarm-space`) in a coupled state $(S_1, S_2)$, let $\\mathcal{A}(S_k)$ denote the set of alive walker indices and let $k_{\\text{alive}} := |\\mathcal{A}(S_k)|$ denote the number of alive walkers in swarm $k$. We define:\n\n1.  The **positional center of mass** (barycentre) **computed over alive walkers only**:\n\n\n\n$$\n\\mu_{x,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}\n$$\n\n2.  The **velocity center of mass** **computed over alive walkers only**:\n\n\n\n$$\n\\mu_{v,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}\n$$\n\nThe **centered vectors** represent the state of each **alive** walker relative to its swarm's center of mass:\n\n1.  The **centered position vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n\n\n\n$$\n\\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}\n$$\n\n2.  The **centered velocity vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n\n\n\n$$\n\\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}\n$$\n\n**Convention**: Dead walkers ($i \\notin \\mathcal{A}(S_k)$) do not contribute to barycentres, variances, or any statistical quantities. By construction, the centered vectors for alive walkers in any swarm sum to zero: $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0$ and $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0$.\n\n:::{admonition} Rationale for Alive-Walker-Only Statistics\n:class: important\n\nDead walkers retain their last known position $(x_i, v_i)$ but have status $s_i = 0$. Including them in statistical calculations would distort the geometric properties:\n\n1. **Physical Interpretation**: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution.\n\n2. **Cloning Operator Target**: The cloning operator $\\Psi_{\\text{clone}}$ acts on the fitness and geometric distribution of **alive** walkers. The variance it contracts is specifically the variance of the alive population.",
    "raw_directive": "364: We begin by formally defining the mathematical objects required for this decomposition.\n365: \n366: :::{prf:definition} Barycentres and Centered Vectors (Alive Walkers Only)\n367: :label: def-barycentres-and-centered-vectors\n368: \n369: For each swarm $k \\in \\{1, 2\\}$ (see {prf:ref}`def-single-swarm-space`) in a coupled state $(S_1, S_2)$, let $\\mathcal{A}(S_k)$ denote the set of alive walker indices and let $k_{\\text{alive}} := |\\mathcal{A}(S_k)|$ denote the number of alive walkers in swarm $k$. We define:\n370: \n371: 1.  The **positional center of mass** (barycentre) **computed over alive walkers only**:\n372: \n373: \n374: \n375: $$\n376: \\mu_{x,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}\n377: $$\n378: \n379: 2.  The **velocity center of mass** **computed over alive walkers only**:\n380: \n381: \n382: \n383: $$\n384: \\mu_{v,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}\n385: $$\n386: \n387: The **centered vectors** represent the state of each **alive** walker relative to its swarm's center of mass:\n388: \n389: 1.  The **centered position vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n390: \n391: \n392: \n393: $$\n394: \\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}\n395: $$\n396: \n397: 2.  The **centered velocity vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n398: \n399: \n400: \n401: $$\n402: \\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}\n403: $$\n404: \n405: **Convention**: Dead walkers ($i \\notin \\mathcal{A}(S_k)$) do not contribute to barycentres, variances, or any statistical quantities. By construction, the centered vectors for alive walkers in any swarm sum to zero: $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0$ and $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0$.\n406: \n407: :::{admonition} Rationale for Alive-Walker-Only Statistics\n408: :class: important\n409: \n410: Dead walkers retain their last known position $(x_i, v_i)$ but have status $s_i = 0$. Including them in statistical calculations would distort the geometric properties:\n411: \n412: 1. **Physical Interpretation**: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution.\n413: \n414: 2. **Cloning Operator Target**: The cloning operator $\\Psi_{\\text{clone}}$ acts on the fitness and geometric distribution of **alive** walkers. The variance it contracts is specifically the variance of the alive population.\n415: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\mu_{x,k} := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\mu_{v,k} := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}"
      }
    ],
    "properties": [
      {
        "name": "Sum to zero",
        "description": "By construction, the centered vectors for alive walkers in any swarm sum to zero: \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0 and \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0."
      },
      {
        "name": "Alive walkers only",
        "description": "Dead walkers do not contribute to the barycentres, variances, or any statistical quantities."
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "convention",
        "text": "Dead walkers (i \\notin \\mathcal{A}(S_k)) do not contribute to barycentres, variances, or any statistical quantities."
      },
      {
        "type": "important",
        "text": "Dead walkers retain their last known position (x_i, v_i) but have status s_i = 0. Including them in statistical calculations would distort the geometric properties: (1) Physical Interpretation: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution. (2) Cloning Operator Target: The cloning operator \\Psi_{\\text{clone}} acts on the fitness and geometric distribution of alive walkers. The variance it contracts is specifically the variance of the alive population."
      }
    ],
    "related_refs": [],
    "tags": [
      "barycentre",
      "centered vectors",
      "alive walkers",
      "center of mass",
      "swarm statistics",
      "deviations"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 364,
      "end_line": 415,
      "content_start": 367,
      "content_end": 414,
      "header_lines": [
        365,
        406
      ]
    },
    "references": [
      "def-single-swarm-space"
    ],
    "metadata": {
      "label": "def-barycentres-and-centered-vectors",
      "class": "important"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-location-error-component",
    "type": "definition",
    "title": "The Location Error Component ($V_{\\text{loc}}$)",
    "term": "location error component",
    "object_type": "quadratic form",
    "nl_definition": "For any pair of swarm configurations with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$, the location error component $V_{\\text{loc}}$ measures the hypocoercive quadratic error between the differences $\\Delta\\mu_x = \\mu_{x,1} - \\mu_{x,2}$ and $\\Delta\\mu_v = \\mu_{v,1} - \\mu_{v,2}$.",
    "content_markdown": ":label: def-location-error-component\n\nFor any pair of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$ (derived from {prf:ref}`def-state-difference-vectors`), the **location error component** is defined as:\n\n$$\nV_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle\n$$",
    "raw_directive": "426: The distance between the swarms' centers of mass is an intrinsically permutation-invariant quantity. We define the location error as the hypocoercive quadratic form applied to the difference between the barycenters of the two swarms.\n427: \n428: :::{prf:definition} The Location Error Component ($V_{\\text{loc}}$)\n429: :label: def-location-error-component\n430: \n431: For any pair of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$ (derived from {prf:ref}`def-state-difference-vectors`), the **location error component** is defined as:\n432: \n433: $$\n434: V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle\n435: $$\n436: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Defined for pairs of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$",
        "latex": null
      },
      {
        "type": null,
        "text": "$V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v \\|\\Delta\\mu_v\\|^2 + b \\langle \\Delta\\mu_x, \\Delta\\mu_v \\rangle$ where $\\Delta\\mu_x = \\mu_{x,1} - \\mu_{x,2}$ and $\\Delta\\mu_v = \\mu_{v,1} - \\mu_{v,2}$",
        "latex": "V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle"
      }
    ],
    "properties": [
      {
        "name": "permutation-invariant",
        "description": "Invariant under permutations of particles within each swarm, as it depends only on the centers of mass."
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "The distance between the swarms' centers of mass is an intrinsically permutation-invariant quantity. We define the location error as the hypocoercive quadratic form applied to the difference between the barycenters of the two swarms."
      }
    ],
    "related_refs": [],
    "tags": [
      "location error",
      "barycenter",
      "swarm configuration",
      "quadratic form",
      "hypocoercive",
      "permutation invariant",
      "energy component"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 426,
      "end_line": 436,
      "content_start": 429,
      "content_end": 435,
      "header_lines": [
        427
      ]
    },
    "references": [
      "def-state-difference-vectors"
    ],
    "metadata": {
      "label": "def-location-error-component"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-structural-error-component",
    "type": "definition",
    "title": "The Structural Error Component ($V_{\\text{struct}}$)",
    "term": "structural error component",
    "object_type": "error measure",
    "nl_definition": "The structural error component $V_{\\text{struct}}$ is the squared hypocoercive Wasserstein distance between the centered empirical measures $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ of two swarms $S_1$ and $S_2$, computed over alive walkers only.",
    "content_markdown": ":label: def-structural-error-component\n\nLet $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ be the centered empirical measures of swarms $S_1$ and $S_2$ **computed over alive walkers only**:\n\n$$\n\\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\n$$\n\nwhere $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ is the number of alive walkers in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n\nThe **structural error component** $V_{\\text{struct}}$ is defined as the squared hypocoercive Wasserstein distance between these centered measures:\n\n$$\nV_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})\n$$",
    "raw_directive": "442: The structural error measures the mismatch between the \"shapes\" of the two swarms. The shape of a swarm is described by the set of its centered vectors, $\\{\\delta_{z,k,i}\\}$. To compare these shapes in a permutation-invariant way, we find the **optimal matching** between the centered vectors of the two swarms and measure the residual error of that matching. This is equivalent to the hypocoercive Wasserstein distance between the *centered empirical measures*.\n443: \n444: :::{prf:definition} The Structural Error Component ($V_{\\text{struct}}$)\n445: :label: def-structural-error-component\n446: \n447: Let $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ be the centered empirical measures of swarms $S_1$ and $S_2$ **computed over alive walkers only**:\n448: \n449: $$\n450: \\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\n451: $$\n452: \n453: where $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ is the number of alive walkers in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n454: \n455: The **structural error component** $V_{\\text{struct}}$ is defined as the squared hypocoercive Wasserstein distance between these centered measures:\n456: \n457: $$\n458: V_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})\n459: $$\n460: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\\quad k_{\\text{alive}} = |\\mathcal{A}(S_k)|"
      },
      {
        "type": null,
        "text": null,
        "latex": "V_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})"
      }
    ],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "The structural error measures the mismatch between the \"shapes\" of the two swarms. The shape of a swarm is described by the set of its centered vectors, $\\{\\delta_{z,k,i}\\}$. To compare these shapes in a permutation-invariant way, we find the optimal matching between the centered vectors of the two swarms and measure the residual error of that matching. This is equivalent to the hypocoercive Wasserstein distance between the centered empirical measures."
      }
    ],
    "related_refs": [
      "def-barycentres-and-centered-vectors"
    ],
    "tags": [
      "structural error",
      "wasserstein distance",
      "hypocoercive",
      "swarms",
      "centered measures",
      "empirical measures",
      "optimal matching"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 442,
      "end_line": 460,
      "content_start": 445,
      "content_end": 459,
      "header_lines": [
        443
      ]
    },
    "references": [
      "def-barycentres-and-centered-vectors"
    ],
    "metadata": {
      "label": "def-structural-error-component"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-full-synergistic-lyapunov-function",
    "type": "definition",
    "title": "The Full Synergistic Hypocoercive Lyapunov Function",
    "term": "total synergistic Lyapunov function",
    "object_type": "Lyapunov function",
    "nl_definition": "A permutation-invariant function measuring the combined inter-swarm distance, intra-swarm dispersion in position and velocity (over alive walkers, normalized by total swarm size N), and boundary proximity penalty for alive walkers in paired swarm configurations.",
    "content_markdown": ":label: def-full-synergistic-lyapunov-function\n\nFor any pair of swarm configurations $(S_1, S_2)$ with corresponding empirical measures $(\\mu_1, \\mu_2)$, the **total synergistic Lyapunov function** is defined as:\n\n$$\nV_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)\n$$\n\nwhere the intra-swarm variance term explicitly decomposes into positional and velocity components **summed over alive walkers only, but normalized by the total swarm size $N$**:\n\n$$\nV_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)\n$$\n\nwith:\n\n$$\n\\begin{align*}\nV_{Var,x}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2 \\\\\nV_{Var,v}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2\n\\end{align*}\n$$\n\nwhere $N$ is the total swarm size, $\\mathcal{A}(S_k)$ is the set of alive walker indices in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n\nThe function is a sum of three components:\n\n1.  **The Inter-Swarm Error ($W_h^2$):** The squared hypocoercive 2-Wasserstein distance between the swarms' full empirical measures. This term quantifies the total permutation-invariant distance between the two swarms in phase space. As established in {prf:ref}`lem-wasserstein-decomposition`, this component can be exactly decomposed into:\n    *   A **Location Component ($V_{\\text{loc}}$)**, measuring the error between the swarm centers of mass.\n    *   A **Structural Component ($V_{\\text{struct}}$)**, measuring the mismatch in swarm shapes.\n\n2.  **The Intra-Swarm Error ($V_{\\text{Var}}$):** The sum of the internal hypocoercive variances of each swarm. This term quantifies the internal dispersion or \"shape error\" *within* each individual swarm in phase space, measuring their lack of internal convergence in both position and velocity. This component is the primary target of the **synergistic dissipation framework**:\n    *   The **cloning operator** ($\\Psi_{\\text{clone}}$, analyzed in this document) provides powerful contraction of the positional variance component $V_{Var,x}$ but causes bounded expansion of the velocity variance component $V_{Var,v}$ through the velocity reset mechanism.\n    *   The **kinetic operator** ($\\Psi_{\\text{kin}}$, analyzed in the companion document) provides contraction of the velocity variance component $V_{Var,v}$ through Langevin dissipation but causes bounded expansion of the positional variance component $V_{Var,x}$ through diffusion.\n    *   When properly balanced, these two operators achieve **net contraction** of the total $V_{Var}$, enabling the system to converge in both position and velocity simultaneously.\n\n3.  **The Boundary Potential ($W_b$):** A term that penalizes **alive** walkers approaching the boundary, constructed from the smooth barrier function $\\varphi_{\\text{barrier}}(x)$ defined in {prf:ref}`prop-barrier-existence`.\n\n\n$$\nW_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n$$\n\n    where $N$ is the total swarm size and $\\mathcal{A}(S_k)$ denotes the set of alive walker indices in swarm $k$. Note that dead walkers do not contribute to the boundary potential.\n\nThe parameters $b$ and $\\lambda_v > 0$ are the **hypocoercive parameters**. The constants $c_V > 0$ and $c_B > 0$ are small, positive **coupling constants** used in the analysis to balance the contributions of the different error components in the final drift inequality.\n\n:::{admonition} Normalization by $N$ vs. $k_{\\text{alive}}$ in the Lyapunov Function\n:class: important\n\nThe Lyapunov function components $V_{\\text{Var}}$ and $W_b$ are normalized by the **total swarm size $N$**, not by the number of alive walkers $k_{\\text{alive}}$. This design choice is critical for mathematical tractability and deserves careful explanation:\n\n**Why This Choice Differs from Algorithm Internals:**\n\nThe algorithm's internal fitness calculations (z-scores, variance measurements used for cloning decisions) correctly use $k_{\\text{alive}}$-normalization to compute statistics over the current active population. This is the physically and statistically correct choice for **decision-making**, as it accurately characterizes the distribution of alive walkers at each step.\n\nHowever, the Lyapunov function serves a different purpose: it is an **analytical tool** designed to prove long-term stability through drift analysis. For this purpose, $N$-normalization is mathematically necessary.\n\n**The Mathematical Necessity:**\n\nConsider the one-step change in the variance component:\n\n$$\n\\Delta V_{\\text{Var}} = V_{\\text{Var}}(S_{t+1}) - V_{\\text{Var}}(S_t)\n$$\n\nIf $V_{\\text{Var}}$ were normalized by $k_{\\text{alive}}$, the drift calculation would become:\n\n$$\n\\mathbb{E}[\\Delta V_{\\text{Var}}] = \\mathbb{E}\\left[\\frac{1}{k_{t+1}} \\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\frac{1}{k_t} \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n$$\n\nThis expression involves the **ratio of correlated random variables**: both the sum of squares and the number of alive walkers change stochastically at each step, and these changes are strongly coupled (e.g., if a high-variance walker dies, both the numerator and denominator change). The expectation of such a ratio cannot be simplified, making rigorous drift bounds essentially impossible to derive.\n\nWith $N$-normalization, the constant factor $1/N$ factors out of the expectation:\n\n$$\n\\mathbb{E}[\\Delta V_{\\text{Var}}] = \\frac{1}{N} \\mathbb{E}\\left[\\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n$$\n\nThis allows the analysis to focus entirely on $\\mathbb{E}[\\Delta \\text{SumOfSquares}]$, which is the direct effect of the cloning and kinetic operators on the swarm's kinematic state. This is precisely what the Keystone Principle and the hypocoercive analysis are designed to bound.\n\n**The Mean-Field Interpretation:**\n\nThe $N$-normalized variance can be interpreted as:\n\n$$\nV_{\\text{Var},x}(S_k) = \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_{\\text{alive}}(S_k)\n$$\n\nThis represents the **mean-field contribution to system disorder per walker slot**. It scales with the fraction of alive walkers, which is exactly the correct behavior: if only a small fraction of walkers remain alive, the system's total disorder (as measured by the Lyapunov function) should reflect this reduced active mass.\n\n**The Viability Requirement:**\n\nThis normalization implicitly assumes that the swarm remains viable, meaning $k_{\\text{alive}}/N$ is bounded away from zero. This is guaranteed by the framework's design:\n- The Safe Harbor Axiom ensures existence of a desirable region away from boundaries\n- The contractive properties of the cloning operator (Keystone Principle) and the confining potential prevent swarm collapse\n- The Lyapunov analysis operates in the regime where the swarm is stable, with extinction probability exponentially small\n\n**Conclusion:**",
    "raw_directive": "745: With the permutation-invariant decomposition of the inter-swarm error established, we now define the full Lyapunov function. This **synergistic** function is constructed as a weighted sum of three distinct error components (see {prf:ref}`prop-lyapunov-necessity` for why this structure is mathematically necessary). It is designed to capture not only the distance *between* the swarms, but also the internal disorder *within* each swarm, which is the primary target of the cloning operator.\n746: \n747: :::{prf:definition} The Full Synergistic Hypocoercive Lyapunov Function\n748: :label: def-full-synergistic-lyapunov-function\n749: \n750: For any pair of swarm configurations $(S_1, S_2)$ with corresponding empirical measures $(\\mu_1, \\mu_2)$, the **total synergistic Lyapunov function** is defined as:\n751: \n752: $$\n753: V_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)\n754: $$\n755: \n756: where the intra-swarm variance term explicitly decomposes into positional and velocity components **summed over alive walkers only, but normalized by the total swarm size $N$**:\n757: \n758: $$\n759: V_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)\n760: $$\n761: \n762: with:\n763: \n764: $$\n765: \\begin{align*}\n766: V_{Var,x}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2 \\\\\n767: V_{Var,v}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2\n768: \\end{align*}\n769: $$\n770: \n771: where $N$ is the total swarm size, $\\mathcal{A}(S_k)$ is the set of alive walker indices in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n772: \n773: The function is a sum of three components:\n774: \n775: 1.  **The Inter-Swarm Error ($W_h^2$):** The squared hypocoercive 2-Wasserstein distance between the swarms' full empirical measures. This term quantifies the total permutation-invariant distance between the two swarms in phase space. As established in {prf:ref}`lem-wasserstein-decomposition`, this component can be exactly decomposed into:\n776:     *   A **Location Component ($V_{\\text{loc}}$)**, measuring the error between the swarm centers of mass.\n777:     *   A **Structural Component ($V_{\\text{struct}}$)**, measuring the mismatch in swarm shapes.\n778: \n779: 2.  **The Intra-Swarm Error ($V_{\\text{Var}}$):** The sum of the internal hypocoercive variances of each swarm. This term quantifies the internal dispersion or \"shape error\" *within* each individual swarm in phase space, measuring their lack of internal convergence in both position and velocity. This component is the primary target of the **synergistic dissipation framework**:\n780:     *   The **cloning operator** ($\\Psi_{\\text{clone}}$, analyzed in this document) provides powerful contraction of the positional variance component $V_{Var,x}$ but causes bounded expansion of the velocity variance component $V_{Var,v}$ through the velocity reset mechanism.\n781:     *   The **kinetic operator** ($\\Psi_{\\text{kin}}$, analyzed in the companion document) provides contraction of the velocity variance component $V_{Var,v}$ through Langevin dissipation but causes bounded expansion of the positional variance component $V_{Var,x}$ through diffusion.\n782:     *   When properly balanced, these two operators achieve **net contraction** of the total $V_{Var}$, enabling the system to converge in both position and velocity simultaneously.\n783: \n784: 3.  **The Boundary Potential ($W_b$):** A term that penalizes **alive** walkers approaching the boundary, constructed from the smooth barrier function $\\varphi_{\\text{barrier}}(x)$ defined in {prf:ref}`prop-barrier-existence`.\n785: \n786: \n787: $$\n788: W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n789: $$\n790: \n791:     where $N$ is the total swarm size and $\\mathcal{A}(S_k)$ denotes the set of alive walker indices in swarm $k$. Note that dead walkers do not contribute to the boundary potential.\n792: \n793: The parameters $b$ and $\\lambda_v > 0$ are the **hypocoercive parameters**. The constants $c_V > 0$ and $c_B > 0$ are small, positive **coupling constants** used in the analysis to balance the contributions of the different error components in the final drift inequality.\n794: \n795: :::{admonition} Normalization by $N$ vs. $k_{\\text{alive}}$ in the Lyapunov Function\n796: :class: important\n797: \n798: The Lyapunov function components $V_{\\text{Var}}$ and $W_b$ are normalized by the **total swarm size $N$**, not by the number of alive walkers $k_{\\text{alive}}$. This design choice is critical for mathematical tractability and deserves careful explanation:\n799: \n800: **Why This Choice Differs from Algorithm Internals:**\n801: \n802: The algorithm's internal fitness calculations (z-scores, variance measurements used for cloning decisions) correctly use $k_{\\text{alive}}$-normalization to compute statistics over the current active population. This is the physically and statistically correct choice for **decision-making**, as it accurately characterizes the distribution of alive walkers at each step.\n803: \n804: However, the Lyapunov function serves a different purpose: it is an **analytical tool** designed to prove long-term stability through drift analysis. For this purpose, $N$-normalization is mathematically necessary.\n805: \n806: **The Mathematical Necessity:**\n807: \n808: Consider the one-step change in the variance component:\n809: \n810: $$\n811: \\Delta V_{\\text{Var}} = V_{\\text{Var}}(S_{t+1}) - V_{\\text{Var}}(S_t)\n812: $$\n813: \n814: If $V_{\\text{Var}}$ were normalized by $k_{\\text{alive}}$, the drift calculation would become:\n815: \n816: $$\n817: \\mathbb{E}[\\Delta V_{\\text{Var}}] = \\mathbb{E}\\left[\\frac{1}{k_{t+1}} \\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\frac{1}{k_t} \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n818: $$\n819: \n820: This expression involves the **ratio of correlated random variables**: both the sum of squares and the number of alive walkers change stochastically at each step, and these changes are strongly coupled (e.g., if a high-variance walker dies, both the numerator and denominator change). The expectation of such a ratio cannot be simplified, making rigorous drift bounds essentially impossible to derive.\n821: \n822: With $N$-normalization, the constant factor $1/N$ factors out of the expectation:\n823: \n824: $$\n825: \\mathbb{E}[\\Delta V_{\\text{Var}}] = \\frac{1}{N} \\mathbb{E}\\left[\\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n826: $$\n827: \n828: This allows the analysis to focus entirely on $\\mathbb{E}[\\Delta \\text{SumOfSquares}]$, which is the direct effect of the cloning and kinetic operators on the swarm's kinematic state. This is precisely what the Keystone Principle and the hypocoercive analysis are designed to bound.\n829: \n830: **The Mean-Field Interpretation:**\n831: \n832: The $N$-normalized variance can be interpreted as:\n833: \n834: $$\n835: V_{\\text{Var},x}(S_k) = \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_{\\text{alive}}(S_k)\n836: $$\n837: \n838: This represents the **mean-field contribution to system disorder per walker slot**. It scales with the fraction of alive walkers, which is exactly the correct behavior: if only a small fraction of walkers remain alive, the system's total disorder (as measured by the Lyapunov function) should reflect this reduced active mass.\n839: \n840: **The Viability Requirement:**\n841: \n842: This normalization implicitly assumes that the swarm remains viable, meaning $k_{\\text{alive}}/N$ is bounded away from zero. This is guaranteed by the framework's design:\n843: - The Safe Harbor Axiom ensures existence of a desirable region away from boundaries\n844: - The contractive properties of the cloning operator (Keystone Principle) and the confining potential prevent swarm collapse\n845: - The Lyapunov analysis operates in the regime where the swarm is stable, with extinction probability exponentially small\n846: \n847: **Conclusion:**\n848: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Defined for swarm configurations (S\u2081, S\u2082) with empirical measures (\u03bc\u2081, \u03bc\u2082)",
        "latex": null
      },
      {
        "type": null,
        "text": "V_total(S\u2081, S\u2082) = W_h\u00b2(\u03bc\u2081, \u03bc\u2082) + c_V V_Var(S\u2081, S\u2082) + c_B W_b(S\u2081, S\u2082)",
        "latex": "V_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)"
      },
      {
        "type": null,
        "text": "V_Var(S\u2081, S\u2082) = V_Var,x(S\u2081, S\u2082) + \u03bb_v V_Var,v(S\u2081, S\u2082)",
        "latex": "V_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)"
      },
      {
        "type": null,
        "text": "V_Var,x(S\u2081, S\u2082) = (1/N) \u2211_{i \u2208 A(S\u2081)} ||\u03b4_{x,1,i}||\u00b2 + (1/N) \u2211_{i \u2208 A(S\u2082)} ||\u03b4_{x,2,i}||\u00b2",
        "latex": "V_{Var,x}(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2"
      },
      {
        "type": null,
        "text": "V_Var,v(S\u2081, S\u2082) = (1/N) \u2211_{i \u2208 A(S\u2081)} ||\u03b4_{v,1,i}||\u00b2 + (1/N) \u2211_{i \u2208 A(S\u2082)} ||\u03b4_{v,2,i}||\u00b2",
        "latex": "V_{Var,v}(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2"
      },
      {
        "type": null,
        "text": "W_b(S\u2081, S\u2082) = (1/N) \u2211_{i \u2208 A(S\u2081)} \u03c6_barrier(x_{1,i}) + (1/N) \u2211_{i \u2208 A(S\u2082)} \u03c6_barrier(x_{2,i})",
        "latex": "W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})"
      }
    ],
    "properties": [
      {
        "name": "Inter-Swarm Error Component",
        "description": "Squared hypocoercive 2-Wasserstein distance W_h\u00b2(\u03bc\u2081, \u03bc\u2082), decomposable into location (V_loc) and structural (V_struct) errors measuring permutation-invariant phase-space distance between swarms."
      },
      {
        "name": "Intra-Swarm Error Component",
        "description": "Variance term V_Var capturing internal dispersion within each swarm, targeting synergistic contraction via cloning (positional) and kinetic (velocity) operators, summed over alive walkers and normalized by N."
      },
      {
        "name": "Boundary Potential Component",
        "description": "Penalty term W_b using barrier function \u03c6_barrier to discourage alive walkers from approaching boundaries, normalized by N and excluding dead walkers."
      },
      {
        "name": "Normalization",
        "description": "All variance and boundary terms normalized by total swarm size N for analytical tractability in drift analysis, scaling with alive fraction k_alive/N."
      }
    ],
    "parameters": [
      {
        "symbol": "\u03bb_v",
        "name": "velocity variance weight",
        "description": "Positive weighting factor for the velocity component in the intra-swarm variance.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "weight",
          "velocity"
        ]
      },
      {
        "symbol": "c_V",
        "name": "variance coupling constant",
        "description": "Positive constant balancing the intra-swarm variance term in the Lyapunov function.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "coupling",
          "variance"
        ]
      },
      {
        "symbol": "c_B",
        "name": "boundary coupling constant",
        "description": "Positive constant balancing the boundary potential term in the Lyapunov function.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "coupling",
          "boundary"
        ]
      },
      {
        "symbol": "b",
        "name": "hypocoercive parameter",
        "description": "Hypocoercive parameter used in the definition of the hypocoercive Wasserstein distance.",
        "constraints": [],
        "tags": [
          "hypocoercive",
          "parameter"
        ]
      },
      {
        "symbol": "N",
        "name": "total swarm size",
        "description": "Fixed total number of walkers in each swarm, used for normalization.",
        "constraints": [
          "> 0",
          "integer"
        ],
        "tags": [
          "swarm",
          "normalization"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "important",
        "text": "Normalization by N vs. k_alive: Uses total swarm size N for mathematical simplicity in expectations, avoiding ratios of random variables; interprets as mean-field disorder per walker slot, assuming viability with k_alive/N bounded away from zero via axioms and contractive properties."
      },
      {
        "type": "see-also",
        "text": "W_h\u00b2 decomposes per Lemma on Wasserstein decomposition; \u03b4 vectors from definition of barycenters and centered vectors; \u03c6_barrier from barrier existence proposition."
      },
      {
        "type": "analysis",
        "text": "Designed for hypocoercive drift analysis; parameters b, \u03bb_v for hypocoercivity; c_V, c_B as small coupling constants for balancing in inequalities."
      }
    ],
    "related_refs": [
      "def-barycentres-and-centered-vectors",
      "lem-wasserstein-decomposition",
      "prop-barrier-existence"
    ],
    "tags": [
      "lyapunov-function",
      "synergistic",
      "hypocoercive",
      "swarm-dynamics",
      "wasserstein-distance",
      "intra-swarm-variance",
      "boundary-potential"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 745,
      "end_line": 848,
      "content_start": 748,
      "content_end": 847,
      "header_lines": [
        746,
        794
      ]
    },
    "references": [
      "def-barycentres-and-centered-vectors",
      "lem-wasserstein-decomposition",
      "prop-barrier-existence"
    ],
    "metadata": {
      "label": "def-full-synergistic-lyapunov-function",
      "class": "important"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-variance-conversions",
    "type": "definition",
    "title": "Variance Notation Conversion Formulas",
    "term": "variance notation conversions",
    "object_type": "conversion formulas",
    "nl_definition": "Formulas defining and converting between three variance measures for a swarm k: the un-normalized sum of squared positional deviations S_k, the physical internal variance Var_k(x) normalized by the number of alive walkers, and the Lyapunov variance component V_{Var,x}(S_k) normalized by total walker slots N.",
    "content_markdown": ":label: def-variance-conversions\n\nFor a swarm $k$ with $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ alive walkers out of $N$ total walker slots:\n\n**1. Un-normalized Sum of Squared Deviations:**\n\n$$\nS_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2\n$$\n\nThis is the total positional variance without any normalization.\n\n**2. Physical Internal Variance ($k$-normalized):**\n\n$$\n\\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}\n$$\n\nThis is the average squared deviation per alive walker - the standard statistical variance.\n\n**3. Lyapunov Variance Component ($N$-normalized):**\n\n$$\nV_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}\n$$\n\nThis is the mean-field contribution to system disorder per walker slot.\n\n**Conversion Formulas:**\n\n$$\n\\begin{aligned}\nS_k &= k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k) \\\\\nV_{\\text{Var},x}(S_k) &= \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x) \\\\\n\\text{Var}_k(x) &= \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)\n\\end{aligned}\n$$\n\n**When converting between notations in proofs:**\n- From $S_k$ to $V_{\\text{Var},x}$: **divide by $N$**",
    "raw_directive": "855: To ensure clarity throughout the proofs, we explicitly state the relationships between the three variance concepts used in this document:\n856: \n857: :::{prf:definition} Variance Notation Conversion Formulas\n858: :label: def-variance-conversions\n859: \n860: For a swarm $k$ with $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ alive walkers out of $N$ total walker slots:\n861: \n862: **1. Un-normalized Sum of Squared Deviations:**\n863: \n864: $$\n865: S_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2\n866: $$\n867: \n868: This is the total positional variance without any normalization.\n869: \n870: **2. Physical Internal Variance ($k$-normalized):**\n871: \n872: $$\n873: \\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}\n874: $$\n875: \n876: This is the average squared deviation per alive walker - the standard statistical variance.\n877: \n878: **3. Lyapunov Variance Component ($N$-normalized):**\n879: \n880: $$\n881: V_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}\n882: $$\n883: \n884: This is the mean-field contribution to system disorder per walker slot.\n885: \n886: **Conversion Formulas:**\n887: \n888: $$\n889: \\begin{aligned}\n890: S_k &= k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k) \\\\\n891: V_{\\text{Var},x}(S_k) &= \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x) \\\\\n892: \\text{Var}_k(x) &= \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)\n893: \\end{aligned}\n894: $$\n895: \n896: **When converting between notations in proofs:**\n897: - From $S_k$ to $V_{\\text{Var},x}$: **divide by $N$**\n898: - From $\\text{Var}_k(x)$ to $V_{\\text{Var},x}$: **multiply by $\\frac{k_{\\text{alive}}}{N}$**",
    "formal_conditions": [
      {
        "type": null,
        "text": "Un-normalized Sum of Squared Deviations",
        "latex": "S_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2"
      },
      {
        "type": null,
        "text": "Physical Internal Variance (k-normalized)",
        "latex": "\\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}"
      },
      {
        "type": null,
        "text": "Lyapunov Variance Component (N-normalized)",
        "latex": "V_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}"
      },
      {
        "type": null,
        "text": "Basic Conversion",
        "latex": "S_k = k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k)"
      },
      {
        "type": null,
        "text": "From physical to Lyapunov",
        "latex": "V_{\\text{Var},x}(S_k) = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x)"
      },
      {
        "type": null,
        "text": "From Lyapunov to physical",
        "latex": "\\text{Var}_k(x) = \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)"
      }
    ],
    "properties": [
      {
        "name": "Un-normalized Sum of Squared Deviations",
        "description": "Total positional variance without any normalization."
      },
      {
        "name": "Physical Internal Variance",
        "description": "Average squared deviation per alive walker - the standard statistical variance."
      },
      {
        "name": "Lyapunov Variance Component",
        "description": "Mean-field contribution to system disorder per walker slot."
      }
    ],
    "parameters": [
      {
        "symbol": "N",
        "name": "Total walker slots",
        "description": "Total number of walker slots in the swarm",
        "constraints": [
          "positive integer"
        ],
        "tags": [
          "swarm",
          "total"
        ]
      },
      {
        "symbol": "k_alive",
        "name": "Number of alive walkers",
        "description": "Number of alive walkers in swarm k, equal to |A(S_k)|",
        "constraints": [
          "integer",
          "0 <= k_alive <= N"
        ],
        "tags": [
          "swarm",
          "alive"
        ]
      },
      {
        "symbol": "S_k",
        "name": "Un-normalized Sum of Squared Deviations",
        "description": "Total positional variance without normalization",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "unnormalized"
        ]
      },
      {
        "symbol": "Var_k(x)",
        "name": "Physical Internal Variance",
        "description": "k-normalized average squared deviation per alive walker",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "internal"
        ]
      },
      {
        "symbol": "V_{Var,x}(S_k)",
        "name": "Lyapunov Variance Component",
        "description": "N-normalized mean-field contribution to system disorder per walker slot",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "lyapunov"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "conversion guide",
        "text": "When converting between notations in proofs: - From S_k to V_{Var,x}(S_k): divide by N - From Var_k(x) to V_{Var,x}(S_k): multiply by k_alive / N"
      }
    ],
    "related_refs": [],
    "tags": [
      "variance",
      "notation",
      "conversion",
      "swarm",
      "normalization",
      "lyapunov",
      "walkers",
      "deviations"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 855,
      "end_line": 898,
      "content_start": 858,
      "content_end": 897,
      "header_lines": [
        856
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-variance-conversions"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-algorithmic-distance-metric",
    "type": "definition",
    "title": "Algorithmic Distance for Companion Selection",
    "term": "algorithmic distance",
    "object_type": "metric",
    "nl_definition": "The squared algorithmic distance between two walkers is the sum of the squared Euclidean norm of their position difference and a weighted squared Euclidean norm of their velocity difference.",
    "content_markdown": ":label: def-algorithmic-distance-metric\n\nFor any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$, the **algorithmic distance** between them is defined as:\n\n$$\nd_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2\n$$",
    "raw_directive": "1349: Before defining the measurement operators, we must first establish the fundamental metric that quantifies proximity between walkers. This metric is central to all intra-swarm measurements in the algorithm, including companion selection for diversity measurement and companion selection for cloning.\n1350: \n1351: :::{prf:definition} Algorithmic Distance for Companion Selection\n1352: :label: def-algorithmic-distance-metric\n1353: \n1354: For any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$, the **algorithmic distance** between them is defined as:\n1355: \n1356: $$\n1357: d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2\n1358: $$\n1359: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "For any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$",
        "latex": null
      },
      {
        "type": null,
        "text": null,
        "latex": "d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "\\lambda_{\\text{alg}}",
        "name": "lambda_alg",
        "description": "Weighting factor for the velocity difference component in the algorithmic distance metric.",
        "constraints": [],
        "tags": [
          "weight",
          "parameter",
          "velocity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This metric quantifies proximity between walkers and is central to intra-swarm measurements, including companion selection for diversity and cloning."
      }
    ],
    "related_refs": [],
    "tags": [
      "distance",
      "metric",
      "algorithmic",
      "companion-selection",
      "walkers",
      "position",
      "velocity",
      "euclidean"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1349,
      "end_line": 1359,
      "content_start": 1352,
      "content_end": 1358,
      "header_lines": [
        1350
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-algorithmic-distance-metric"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-spatial-pairing-operator-diversity",
    "type": "definition",
    "title": "Spatially-Aware Pairing Operator (Idealized Model)",
    "term": "Spatially-Aware Pairing Operator",
    "object_type": "operator",
    "nl_definition": "An operator that maps the alive set of walkers to a probability distribution over all possible perfect matchings, where probabilities are assigned based on the product of edge weights computed from exponential decay of squared algorithmic distances between paired walkers, normalized by the partition function.",
    "content_markdown": ":label: def-spatial-pairing-operator-diversity\n\nLet $\\mathcal{S}_t$ be the current swarm state with alive set $\\mathcal{A}_t$ of size $k = |\\mathcal{A}_t|$. The idealized **Spatially-Aware Pairing Operator**, denoted $\\mathbb{P}_{\\text{pair}}$, maps the alive set $\\mathcal{A}_t$ to a probability distribution over the set of all possible perfect matchings, $\\mathcal{M}_k$.\n\n**Inputs:**\n*   The alive set of walkers, $\\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\}$.\n*   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n\n**Operation:**\n1.  For every pair of distinct walkers $(w_i, w_j)$, an edge weight is assigned based on their phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n\n\n$$\nw_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n$$\n\n2.  The \"quality\" of a specific perfect matching `M` is the product of the weights of the edges it contains:\n\n\n$$\nW(M) := \\prod_{(i,j) \\in M} w_{ij}\n$$\n\n3.  The probability of selecting a specific matching `M` is given by its quality normalized by the sum of qualities over all possible matchings (the partition function):\n\n\n$$\nP(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}",
    "raw_directive": "1391: For the purposes of theoretical analysis, it is useful to model the pairing as a single, collective draw from a probability distribution over all possible perfect matchings of the alive set. This idealized model captures the physical intent of the operator\u2014to strongly favor pairings between walkers that are close in the algorithmic space.\n1392: \n1393: :::{prf:definition} Spatially-Aware Pairing Operator (Idealized Model)\n1394: :label: def-spatial-pairing-operator-diversity\n1395: \n1396: Let $\\mathcal{S}_t$ be the current swarm state with alive set $\\mathcal{A}_t$ of size $k = |\\mathcal{A}_t|$. The idealized **Spatially-Aware Pairing Operator**, denoted $\\mathbb{P}_{\\text{pair}}$, maps the alive set $\\mathcal{A}_t$ to a probability distribution over the set of all possible perfect matchings, $\\mathcal{M}_k$.\n1397: \n1398: **Inputs:**\n1399: *   The alive set of walkers, $\\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\}$.\n1400: *   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n1401: \n1402: **Operation:**\n1403: 1.  For every pair of distinct walkers $(w_i, w_j)$, an edge weight is assigned based on their phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n1404: \n1405: \n1406: $$\n1407: w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n1408: $$\n1409: \n1410: 2.  The \"quality\" of a specific perfect matching `M` is the product of the weights of the edges it contains:\n1411: \n1412: \n1413: $$\n1414: W(M) := \\prod_{(i,j) \\in M} w_{ij}\n1415: $$\n1416: \n1417: 3.  The probability of selecting a specific matching `M` is given by its quality normalized by the sum of qualities over all possible matchings (the partition function):\n1418: \n1419: \n1420: $$\n1421: P(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}\n1422: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Edge weight assignment",
        "latex": "w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)"
      },
      {
        "type": null,
        "text": "Quality of a matching M",
        "latex": "W(M) := \\prod_{(i,j) \\in M} w_{ij}"
      },
      {
        "type": null,
        "text": "Probability of selecting matching M",
        "latex": "P(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}"
      },
      {
        "type": null,
        "text": "Input alive set size",
        "latex": "k = |\\mathcal{A}_t|"
      },
      {
        "type": null,
        "text": "Domain",
        "latex": "\\mathbb{P}_{\\text{pair}}: \\mathcal{A}_t \\to \\text{Dist}(\\mathcal{M}_k)"
      }
    ],
    "properties": [
      {
        "name": "Inputs",
        "description": "The alive set of walkers \\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\} and \\varepsilon_d > 0 (Interaction Range for Diversity)."
      },
      {
        "name": "Output",
        "description": "A probability distribution over the set of all possible perfect matchings \\mathcal{M}_k."
      },
      {
        "name": "Weight Function",
        "description": "Gaussian-like weight based on algorithmic distance d_{\\text{alg}}(i,j)."
      },
      {
        "name": "Normalization",
        "description": "Probabilities sum to 1 via the partition function \\sum_{M' \\in \\mathcal{M}_k} W(M')."
      }
    ],
    "parameters": [
      {
        "symbol": "\\varepsilon_d",
        "name": "Interaction Range for Diversity",
        "description": "The Interaction Range for Diversity.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "diversity",
          "range",
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "For the purposes of theoretical analysis, it is useful to model the pairing as a single, collective draw from a probability distribution over all possible perfect matchings of the alive set. This idealized model captures the physical intent of the operator\u2014to strongly favor pairings between walkers that are close in the algorithmic space."
      }
    ],
    "related_refs": [],
    "tags": [
      "spatial",
      "pairing",
      "operator",
      "idealized",
      "diversity",
      "probability",
      "matching",
      "swarm",
      "walkers"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1391,
      "end_line": 1422,
      "content_start": 1394,
      "content_end": 1421,
      "header_lines": [
        1392
      ]
    },
    "references": [
      "def-algorithmic-distance-metric"
    ],
    "metadata": {
      "label": "def-spatial-pairing-operator-diversity"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-greedy-pairing-algorithm",
    "type": "definition",
    "title": "Sequential Stochastic Greedy Pairing Operator",
    "term": "Sequential Stochastic Greedy Pairing Operator",
    "object_type": "algorithm",
    "nl_definition": "An iterative stochastic algorithm that constructs a matching among alive walkers by sequentially selecting an unpaired walker, computing proximity-based probabilities over remaining unpaired walkers, sampling a companion, and updating the companion map until at most one walker remains unpaired.",
    "content_markdown": ":label: def-greedy-pairing-algorithm\n\nLet `A_t` be the set of `k` alive walkers at time `t`. The pairing operator generates a **Companion Map**, `c: A_t \u2192 A_t`, which is a perfect matching if `k` is even, or a maximal matching if `k` is odd.\n\n**Inputs:**\n*   The set of alive walkers, `A_t = {w_1, w_2, ..., w_k}`.\n*   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n\n**Operation:**\n1.  Initialize a set of unpaired walkers `U \u2190 A_t` and an empty companion map `c`.\n2.  While `|U| > 1`:\n    a. Select and remove an arbitrary walker `i` from `U`.\n    b. For each remaining walker $j \\in U$, calculate the selection weight based on phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n\n\n$$\nw_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n$$\n\n    c. Form a probability distribution over $j \\in U$ where $P(\\text{choose } j) = w_{ij} / (\\sum_{l \\in U} w_{il})$.\n    d. Sample a companion `c_i` for `i` from this distribution.\n    e. Remove `c_i` from `U`.\n    f. Set the pairing in the companion map: `c(i) \u2190 c_i` and `c(c_i) \u2190 i`.\n3.  Return the completed companion map `c`.",
    "raw_directive": "1430: This algorithm builds the matching iteratively. It selects an unpaired walker, computes a probability distribution over all other currently unpaired walkers based on proximity, samples a companion, and removes the new pair from the pool. This reduces the computational complexity from factorial to quadratic, making it practical for large swarms.\n1431: \n1432: :::{prf:definition} Sequential Stochastic Greedy Pairing Operator\n1433: :label: def-greedy-pairing-algorithm\n1434: \n1435: Let `A_t` be the set of `k` alive walkers at time `t`. The pairing operator generates a **Companion Map**, `c: A_t \u2192 A_t`, which is a perfect matching if `k` is even, or a maximal matching if `k` is odd.\n1436: \n1437: **Inputs:**\n1438: *   The set of alive walkers, `A_t = {w_1, w_2, ..., w_k}`.\n1439: *   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n1440: \n1441: **Operation:**\n1442: 1.  Initialize a set of unpaired walkers `U \u2190 A_t` and an empty companion map `c`.\n1443: 2.  While `|U| > 1`:\n1444:     a. Select and remove an arbitrary walker `i` from `U`.\n1445:     b. For each remaining walker $j \\in U$, calculate the selection weight based on phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n1446: \n1447: \n1448: $$\n1449: w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n1450: $$\n1451: \n1452:     c. Form a probability distribution over $j \\in U$ where $P(\\text{choose } j) = w_{ij} / (\\sum_{l \\in U} w_{il})$.\n1453:     d. Sample a companion `c_i` for `i` from this distribution.\n1454:     e. Remove `c_i` from `U`.\n1455:     f. Set the pairing in the companion map: `c(i) \u2190 c_i` and `c(c_i) \u2190 i`.\n1456: 3.  Return the completed companion map `c`.\n1457: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Initialize unpaired set U \u2190 A_t and empty companion map c.",
        "latex": null
      },
      {
        "type": null,
        "text": "While |U| > 1: Select arbitrary i from U and remove it.",
        "latex": null
      },
      {
        "type": null,
        "text": "For each j in U, compute weight w_{ij} = exp(-d_alg(i, j)^2 / (2 \u03b5_d^2)).",
        "latex": "w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)"
      },
      {
        "type": null,
        "text": "Form probability P(choose j) = w_{ij} / sum_{l in U} w_{il}.",
        "latex": null
      },
      {
        "type": null,
        "text": "Sample c_i from this distribution, remove c_i from U.",
        "latex": null
      },
      {
        "type": null,
        "text": "Set c(i) \u2190 c_i and c(c_i) \u2190 i.",
        "latex": null
      },
      {
        "type": null,
        "text": "Return companion map c.",
        "latex": null
      }
    ],
    "properties": [
      {
        "name": "Output",
        "description": "Generates a companion map c: A_t \u2192 A_t, a perfect matching if k even, or maximal matching if k odd."
      },
      {
        "name": "Complexity",
        "description": "Reduces computational complexity from factorial to quadratic by iterative greedy selection."
      },
      {
        "name": "Stochasticity",
        "description": "Companion selection is probabilistic based on proximity weights."
      }
    ],
    "parameters": [
      {
        "symbol": "A_t",
        "name": "Set of Alive Walkers",
        "description": "The set of k alive walkers at time t.",
        "constraints": [
          "finite set",
          "|A_t| = k"
        ],
        "tags": [
          "walkers",
          "set"
        ]
      },
      {
        "symbol": "\\varepsilon_d",
        "name": "Interaction Range for Diversity",
        "description": "Positive parameter controlling the scale of proximity in selection weights.",
        "constraints": [
          "\\varepsilon_d > 0"
        ],
        "tags": [
          "range",
          "diversity",
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "motivation",
        "text": "This algorithm builds the matching iteratively. It selects an unpaired walker, computes a probability distribution over all other currently unpaired walkers based on proximity, samples a companion, and removes the new pair from the pool. This reduces the computational complexity from factorial to quadratic, making it practical for large swarms."
      }
    ],
    "related_refs": [],
    "tags": [
      "greedy",
      "pairing",
      "stochastic",
      "sequential",
      "algorithm",
      "matching",
      "walkers",
      "proximity"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1430,
      "end_line": 1457,
      "content_start": 1433,
      "content_end": 1456,
      "header_lines": [
        1431
      ]
    },
    "references": [
      "def-algorithmic-distance-metric"
    ],
    "metadata": {
      "label": "def-greedy-pairing-algorithm"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-geometric-partition",
    "type": "definition",
    "title": "Geometric Partitioning of High-Variance Swarms",
    "term": "geometric partitioning",
    "object_type": "partition",
    "nl_definition": "A phase-space partitioning of a high-variance swarm (with Var(x) > R_var^2) into two non-empty N-uniform sets: a high-error set of kinematically isolated walkers and a low-error set forming dense local clusters, for a given interaction range \u03b5.",
    "content_markdown": ":label: def-geometric-partition\n\nFor a given interaction range $\\varepsilon$, we define a swarm's phase-space structure based on local and global properties. As will be proven in **{prf:ref}`cor-vvarx-to-high-error-fraction`**, any swarm with sufficiently high variance (`Var(x) > R^{2}_var`) can be partitioned into two non-empty, N-uniform sets:\n1.  A **high-error set** `H_k`, whose members are **kinematically isolated** in phase space. This implies the existence of a distance $D_H(\\varepsilon) > 0$ such that for any $i \\in H_k$, all other walkers `j` are at an algorithmic distance $d_alg(i, j) > D_H(\\varepsilon)$.\n2.  A **low-error set** `L_k`, whose members are part of dense clusters in phase space. For any $j \\in L_k$, there is a non-empty subset of other walkers `C_j \u2282 L_k` of size $|C_j| \\geq f_c k$ (for some N-uniform `f_c > 0`) located within an algorithmic radius $R_L(\\varepsilon) < D_H(\\varepsilon)$.",
    "raw_directive": "1516: First, we must formalize the geometric partitioning of the swarm that is guaranteed to exist in a high-variance state, a result that will be proven in full detail in Chapter 6.\n1517: \n1518: :::{prf:definition} Geometric Partitioning of High-Variance Swarms\n1519: :label: def-geometric-partition\n1520: \n1521: For a given interaction range $\\varepsilon$, we define a swarm's phase-space structure based on local and global properties. As will be proven in **{prf:ref}`cor-vvarx-to-high-error-fraction`**, any swarm with sufficiently high variance (`Var(x) > R^{2}_var`) can be partitioned into two non-empty, N-uniform sets:\n1522: 1.  A **high-error set** `H_k`, whose members are **kinematically isolated** in phase space. This implies the existence of a distance $D_H(\\varepsilon) > 0$ such that for any $i \\in H_k$, all other walkers `j` are at an algorithmic distance $d_alg(i, j) > D_H(\\varepsilon)$.\n1523: 2.  A **low-error set** `L_k`, whose members are part of dense clusters in phase space. For any $j \\in L_k$, there is a non-empty subset of other walkers `C_j \u2282 L_k` of size $|C_j| \\geq f_c k$ (for some N-uniform `f_c > 0`) located within an algorithmic radius $R_L(\\varepsilon) < D_H(\\varepsilon)$.\n1524: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "The swarm S satisfies Var(x) > R_var^2, where x denotes positions.",
        "latex": "\\operatorname{Var}(x) > R_{\\var}^2"
      },
      {
        "type": null,
        "text": "S is partitioned into non-empty, N-uniform sets H_k and L_k (disjoint union).",
        "latex": "S = H_k \\sqcup L_k, \\, |H_k| \\geq cN, \\, |L_k| \\geq cN \\, (c > 0 \\, N\\text{-uniform})"
      },
      {
        "type": null,
        "text": "For H_k (high-error): exists D_H(\u03b5) > 0 such that \u2200 i \u2208 H_k, \u2200 j \u2260 i, d_alg(i, j) > D_H(\u03b5) (kinematically isolated).",
        "latex": "\\exists D_H(\\varepsilon) > 0: \\, \\forall i \\in H_k, \\, \\forall j \\neq i, \\, d_{\\alg}(i,j) > D_H(\\varepsilon)"
      },
      {
        "type": null,
        "text": "For L_k (low-error): \u2200 j \u2208 L_k, \u2203 C_j \u2282 L_k non-empty with |C_j| \u2265 f_c k (f_c > 0 N-uniform) s.t. all in C_j within algorithmic radius R_L(\u03b5) < D_H(\u03b5) from j.",
        "latex": "\\forall j \\in L_k, \\, \\exists C_j \\subset L_k, \\, |C_j| \\geq f_c k \\, (f_c > 0 \\, N\\text{-uniform}), \\, \\forall i \\in C_j, \\, d_{\\alg}(i,j) \\leq R_L(\\varepsilon) < D_H(\\varepsilon)"
      }
    ],
    "properties": [
      {
        "name": "High-Error Set H_k",
        "description": "Consists of kinematically isolated walkers, separated from all others by at least D_H(\u03b5) in algorithmic distance."
      },
      {
        "name": "Low-Error Set L_k",
        "description": "Consists of walkers each belonging to a dense local cluster of at least f_c k others within R_L(\u03b5)."
      },
      {
        "name": "N-Uniformity",
        "description": "Both H_k and L_k are non-empty with sizes bounded below by a positive fraction of the total swarm size N."
      },
      {
        "name": "Phase-Space Basis",
        "description": "Defined using local (cluster isolation) and global (variance) properties for interaction range \u03b5."
      }
    ],
    "parameters": [
      {
        "symbol": "\\varepsilon",
        "name": "interaction range",
        "description": "The given interaction range defining the swarm's phase-space structure.",
        "constraints": [],
        "tags": [
          "range",
          "interaction"
        ]
      },
      {
        "symbol": "R_{\\var}^2",
        "name": "variance threshold",
        "description": "Threshold determining high-variance state: Var(x) > R_{\\var}^2.",
        "constraints": [
          "R_{\\var}^2 > 0"
        ],
        "tags": [
          "threshold",
          "variance"
        ]
      },
      {
        "symbol": "k",
        "name": "set index",
        "description": "Index parameterizing the partitioned sets H_k and L_k.",
        "constraints": [],
        "tags": [
          "index",
          "partition"
        ]
      },
      {
        "symbol": "f_c",
        "name": "cluster fraction",
        "description": "Positive N-uniform fraction bounding the minimum size of local clusters in L_k.",
        "constraints": [
          "f_c > 0",
          "N-uniform"
        ],
        "tags": [
          "fraction",
          "cluster"
        ]
      },
      {
        "symbol": "D_H(\\varepsilon)",
        "name": "isolation distance",
        "description": "Positive distance ensuring kinematic isolation for members of H_k.",
        "constraints": [
          "D_H(\\varepsilon) > 0"
        ],
        "tags": [
          "distance",
          "isolation"
        ]
      },
      {
        "symbol": "R_L(\\varepsilon)",
        "name": "cluster radius",
        "description": "Algorithmic radius for dense clusters in L_k, smaller than the isolation distance.",
        "constraints": [
          "R_L(\\varepsilon) < D_H(\\varepsilon)"
        ],
        "tags": [
          "radius",
          "cluster"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "proof-reference",
        "text": "Existence guaranteed by cor-vvarx-to-high-error-fraction."
      },
      {
        "type": "future-proof",
        "text": "Full detailed proof provided in Chapter 6."
      },
      {
        "type": "context",
        "text": "Applies to swarms in high-variance states based on phase-space structure."
      }
    ],
    "related_refs": [
      "cor-vvarx-to-high-error-fraction"
    ],
    "tags": [
      "geometric-partitioning",
      "high-variance-swarms",
      "phase-space-structure",
      "high-error-set",
      "low-error-set",
      "kinematic-isolation",
      "dense-clusters",
      "N-uniform"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1516,
      "end_line": 1524,
      "content_start": 1519,
      "content_end": 1523,
      "header_lines": [
        1517
      ]
    },
    "references": [
      "cor-vvarx-to-high-error-fraction"
    ],
    "metadata": {
      "label": "def-geometric-partition"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-raw-value-operators",
    "type": "definition",
    "title": "Raw Value Operators",
    "term": "Raw Value Operators",
    "object_type": "Operators",
    "nl_definition": "Operators that deterministically measure raw reward and paired distance for alive walkers after fixing the companion map.",
    "content_markdown": ":label: def-raw-value-operators\n\n1.  **The Reward Measurement Operator ($V_R$):** The raw reward for each alive walker `i` is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components:\n\n\n$$\nr_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v\\_reg} \\|v_i\\|^2\n$$\n\n    where $R_{\\text{pos}}(x_i)$ is the positional reward and $c_{v\\_reg} > 0$ is the velocity regularization coefficient from {prf:ref}`axiom-velocity-regularization`.\n\n2.  **The Paired Distance Measurement Operator ($V_D$):** Given the Companion Map `c(i)` generated by the pairing operator, the raw distance for each alive walker `i` is deterministically defined as the algorithmic distance to its assigned companion:\n\n\n$$\nd_i := d_{\\text{alg}}(i, c(i))\n$$",
    "raw_directive": "1741: Once the Companion Map `c(i)` is fixed for the timestep by the pairing operator, the measurement of raw values for each walker becomes a deterministic process.\n1742: \n1743: :::{prf:definition} Raw Value Operators\n1744: :label: def-raw-value-operators\n1745: \n1746: 1.  **The Reward Measurement Operator ($V_R$):** The raw reward for each alive walker `i` is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components:\n1747: \n1748: \n1749: $$\n1750: r_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v\\_reg} \\|v_i\\|^2\n1751: $$\n1752: \n1753:     where $R_{\\text{pos}}(x_i)$ is the positional reward and $c_{v\\_reg} > 0$ is the velocity regularization coefficient from {prf:ref}`axiom-velocity-regularization`.\n1754: \n1755: 2.  **The Paired Distance Measurement Operator ($V_D$):** Given the Companion Map `c(i)` generated by the pairing operator, the raw distance for each alive walker `i` is deterministically defined as the algorithmic distance to its assigned companion:\n1756: \n1757: \n1758: $$\n1759: d_i := d_{\\text{alg}}(i, c(i))\n1760: $$\n1761: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "The Reward Measurement Operator (V_R): The raw reward for each alive walker i is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components: r_i := R(x_i, v_i) = R_pos(x_i) - c_{v_reg} ||v_i||^2 where R_pos(x_i) is the positional reward and c_{v_reg} > 0 is the velocity regularization coefficient from Axiom EG-4.",
        "latex": "r_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v_{\\reg}} \\|v_i\\|^2"
      },
      {
        "type": null,
        "text": "The Paired Distance Measurement Operator (V_D): Given the Companion Map c(i) generated by the pairing operator, the raw distance for each alive walker i is deterministically defined as the algorithmic distance to its assigned companion: d_i := d_alg(i, c(i))",
        "latex": "d_i := d_{\\text{alg}}(i, c(i))"
      }
    ],
    "properties": [
      {
        "name": "Deterministic",
        "description": "Measurements are deterministic once the companion map is fixed by the pairing operator."
      },
      {
        "name": "Individual",
        "description": "Reward measurement is direct and individual for each walker, including position and velocity components."
      },
      {
        "name": "Paired",
        "description": "Distance measurement uses the assigned companion from the map."
      }
    ],
    "parameters": [
      {
        "symbol": "c_{v_reg}",
        "name": "velocity regularization coefficient",
        "description": "Positive coefficient penalizing walker velocity in reward function",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "regularization",
          "velocity",
          "coefficient"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "introductory",
        "text": "Once the Companion Map c(i) is fixed for the timestep by the pairing operator, the measurement of raw values for each walker becomes a deterministic process."
      }
    ],
    "related_refs": [],
    "tags": [
      "raw-value",
      "operators",
      "reward",
      "distance",
      "measurement",
      "walkers",
      "pairing"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1741,
      "end_line": 1761,
      "content_start": 1744,
      "content_end": 1760,
      "header_lines": [
        1742
      ]
    },
    "references": [
      "axiom-velocity-regularization"
    ],
    "metadata": {
      "label": "def-raw-value-operators"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-swarm-aggregation-operator",
    "type": "definition",
    "title": "Swarm Aggregation Operator",
    "term": "Swarm Aggregation Operator",
    "object_type": "operator",
    "nl_definition": "An operator that processes raw reward and distance vectors from the k alive walkers to compute summary statistics, specifically the mean and standard deviation, for subsequent standardization.",
    "content_markdown": ":label: def-swarm-aggregation-operator",
    "raw_directive": "1779: This stage distills the raw reward and distance vectors from the `k` alive walkers into the summary statistics (mean and standard deviation) required for standardization.\n1780: \n1781: :::{prf:definition} Swarm Aggregation Operator\n1782: :label: def-swarm-aggregation-operator\n1783: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [
      {
        "symbol": "k",
        "name": "k",
        "description": "The number of alive walkers providing the raw reward and distance vectors.",
        "constraints": [],
        "tags": [
          "walkers"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "swarm",
      "aggregation",
      "operator",
      "walkers",
      "reward",
      "distance",
      "standardization",
      "statistics"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1779,
      "end_line": 1783,
      "content_start": 1782,
      "content_end": 1782,
      "header_lines": [
        1780
      ]
    },
    "references": [
      "def-single-swarm-space"
    ],
    "metadata": {
      "label": "def-swarm-aggregation-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-patched-std-dev-function",
    "type": "definition",
    "title": "Patched Standard Deviation Function",
    "term": "\\sigma'_{\\text{patch}}",
    "object_type": "function",
    "nl_definition": "A C^1 smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero, defined piecewise in terms of the raw variance V.",
    "content_markdown": ":label: def-patched-std-dev-function\n\nThe **Patched Standard Deviation Function**, $\\sigma'_{\\text{patch}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$, is a $C^1$ smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero. It is defined piecewise in terms of the raw variance, $V := \\operatorname{Var}[\\mu_{\\mathbf{v}}]$:\n\n$$\n\\sigma'_{\\text{patch}}(V) :=\n\\begin{cases}\n\\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\mathrm{std}}^2}, & V \\le \\kappa_{\\text{var,min}} \\\\\nP(V), & \\kappa_{\\text{var,min}} < V < 2\\kappa_{\\text{var,min}} \\\\\n\\sqrt{V + \\varepsilon_{\\mathrm{std}}^2}, & V \\ge 2\\kappa_{\\text{var,min}}\n\\end{cases}\n$$",
    "raw_directive": "1792: A critical component of this stage is the use of a robust, smooth function (see {prf:ref}`def-patched-std-dev-function`) to compute the standard deviation, which is essential for the stability of the entire pipeline.\n1793: \n1794: :::{prf:definition} Patched Standard Deviation Function\n1795: :label: def-patched-std-dev-function\n1796: \n1797: The **Patched Standard Deviation Function**, $\\sigma'_{\\text{patch}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$, is a $C^1$ smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero. It is defined piecewise in terms of the raw variance, $V := \\operatorname{Var}[\\mu_{\\mathbf{v}}]$:\n1798: \n1799: $$\n1800: \\sigma'_{\\text{patch}}(V) :=\n1801: \\begin{cases}\n1802: \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\mathrm{std}}^2}, & V \\le \\kappa_{\\text{var,min}} \\\\\n1803: P(V), & \\kappa_{\\text{var,min}} < V < 2\\kappa_{\\text{var,min}} \\\\\n1804: \\sqrt{V + \\varepsilon_{\\mathrm{std}}^2}, & V \\ge 2\\kappa_{\\text{var,min}}\n1805: \\end{cases}\n1806: $$\n1807: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [
      {
        "symbol": "\\kappa_{\\text{var,min}}",
        "name": "minimum variance threshold",
        "description": "The lower bound threshold for variance to ensure stability.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "threshold",
          "variance",
          "minimum"
        ]
      },
      {
        "symbol": "\\varepsilon_{\\mathrm{std}}",
        "name": "standard deviation epsilon",
        "description": "Regularization parameter added to prevent zero or near-zero standard deviation.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "epsilon",
          "regularization",
          "stability"
        ]
      },
      {
        "symbol": "P",
        "name": "smoothing polynomial",
        "description": "A C^1 smooth polynomial used for interpolation in the transition region.",
        "constraints": [
          "C^1 smooth"
        ],
        "tags": [
          "polynomial",
          "interpolation",
          "smooth"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "standard-deviation",
      "patched",
      "smooth-function",
      "lipschitz",
      "variance"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1792,
      "end_line": 1807,
      "content_start": 1795,
      "content_end": 1806,
      "header_lines": [
        1793
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-patched-std-dev-function"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-standardization-operator",
    "type": "definition",
    "title": "N-Dimensional Standardization Operator",
    "term": "N-Dimensional Standardization Operator",
    "object_type": "operator",
    "nl_definition": "The N-Dimensional Standardization Operator, denoted z, maps a swarm state S, a raw value vector v, and an aggregation operator M to an N-dimensional vector of standardized Z-scores.",
    "content_markdown": ":label: def-standardization-operator\n\nThe **N-Dimensional Standardization Operator**, $z$, maps a swarm state `S`, a raw value vector `v`, and an aggregation operator `M` to an N-dimensional vector of Z-scores.\n\n**Operation:**\n1.  Aggregate the alive components `v_A` using operator M (see {prf:ref}`def-swarm-aggregation-operator`) to get a measure $\\mu_v = M(S, v_A)$.\n2.  Compute the mean $\\mu_A = \\mathbb{E}[\\mu_v]$ and the **patched** standard deviation $\\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])$ using the patching function (see {prf:ref}`lem-patching-properties`).",
    "raw_directive": "1818: This operator uses the robust statistics from the previous stage to convert the raw value vectors into standardized Z-scores.\n1819: \n1820: :::{prf:definition} N-Dimensional Standardization Operator\n1821: :label: def-standardization-operator\n1822: \n1823: The **N-Dimensional Standardization Operator**, $z$, maps a swarm state `S`, a raw value vector `v`, and an aggregation operator `M` to an N-dimensional vector of Z-scores.\n1824: \n1825: **Operation:**\n1826: 1.  Aggregate the alive components `v_A` using operator M (see {prf:ref}`def-swarm-aggregation-operator`) to get a measure $\\mu_v = M(S, v_A)$.\n1827: 2.  Compute the mean $\\mu_A = \\mathbb{E}[\\mu_v]$ and the **patched** standard deviation $\\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])$ using the patching function (see {prf:ref}`lem-patching-properties`).\n1828: 3.  For each alive walker `i`, compute its Z-score: $z_i = (v_i - \\mu_A) / \\sigma'_A$.",
    "formal_conditions": [
      {
        "type": null,
        "text": "Aggregate the alive components v_A to get a measure \u03bc_v = M(S, v_A).",
        "latex": "\\mu_v = M(S, v_A)"
      },
      {
        "type": null,
        "text": "Compute the mean \u03bc_A = E[\u03bc_v] and the patched standard deviation \u03c3'_A = \u03c3'_patch(Var[\u03bc_v]).",
        "latex": "\\mu_A = \\mathbb{E}[\\mu_v], \\quad \\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute its Z-score: z_i = (v_i - \u03bc_A) / \u03c3'_A.",
        "latex": "z_i = \\frac{v_i - \\mu_A}{\\sigma'_A}"
      }
    ],
    "properties": [
      {
        "name": "Input Dependencies",
        "description": "Relies on alive components from swarm state S and aggregation via M."
      },
      {
        "name": "Output Type",
        "description": "Produces N-dimensional vector of Z-scores for alive walkers."
      },
      {
        "name": "Robustness",
        "description": "Uses patched standard deviation for handling variance in robust statistics."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm state",
        "description": "The current state of the swarm, including information about alive components.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "v",
        "name": "raw value vector",
        "description": "The N-dimensional vector of raw values for the walkers.",
        "constraints": [],
        "tags": [
          "vector",
          "raw",
          "values"
        ]
      },
      {
        "symbol": "M",
        "name": "aggregation operator",
        "description": "The operator used to aggregate values from alive components.",
        "constraints": [],
        "tags": [
          "aggregation",
          "operator"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This operator uses the robust statistics from the previous stage to convert the raw value vectors into standardized Z-scores."
      }
    ],
    "related_refs": [],
    "tags": [
      "standardization",
      "z-score",
      "operator",
      "swarm-state",
      "aggregation",
      "robust-statistics",
      "normalization"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1818,
      "end_line": 1828,
      "content_start": 1821,
      "content_end": 1827,
      "header_lines": [
        1819
      ]
    },
    "references": [
      "def-swarm-aggregation-operator",
      "lem-patching-properties"
    ],
    "metadata": {
      "label": "def-standardization-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-logistic-rescale",
    "type": "definition",
    "title": "Canonical Logistic Rescale Function",
    "term": "Canonical Logistic Rescale Function",
    "object_type": "function",
    "nl_definition": "A function from the real numbers to the open interval (0, 2) given by the formula g_A(z) = 2 / (1 + e^{-z}).",
    "content_markdown": ":label: def-logistic-rescale\n\nThe **Canonical Logistic Rescale Function**, $g_A: \\mathbb{R} \\to (0, 2)$, is defined as:\n\n$$\ng_A(z) := \\frac{2}{1 + e^{-z}}",
    "raw_directive": "1844: :::\n1845: \n1846: :::{prf:definition} Canonical Logistic Rescale Function\n1847: :label: def-logistic-rescale\n1848: \n1849: The **Canonical Logistic Rescale Function**, $g_A: \\mathbb{R} \\to (0, 2)$, is defined as:\n1850: \n1851: $$\n1852: g_A(z) := \\frac{2}{1 + e^{-z}}\n1853: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "g_A(z) := \\frac{2}{1 + e^{-z}}"
      },
      {
        "type": null,
        "text": "Domain and codomain",
        "latex": "g_A: \\mathbb{R} \\to (0, 2)"
      }
    ],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "logistic",
      "rescale",
      "canonical",
      "sigmoid",
      "function",
      "exponential"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1844,
      "end_line": 1853,
      "content_start": 1847,
      "content_end": 1852,
      "header_lines": [
        1845
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-logistic-rescale"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-fitness-potential-operator",
    "type": "definition",
    "title": "Fitness Potential Operator",
    "term": "Fitness Potential Operator",
    "object_type": "operator",
    "nl_definition": "The Fitness Potential Operator \u03a6_pipeline maps a swarm state S and raw measurement vectors r and d to an N-dimensional fitness potential vector V_fit by computing Z-scores for rewards and diversity, rescaling them with a floor \u03b7, and combining via weighted powers using \u03b1 and \u03b2.",
    "content_markdown": ":label: def-fitness-potential-operator\n\nThe **Fitness Potential Operator**, $\\Phi_{\\text{pipeline}}$, maps a swarm state `S` and its raw measurement vectors `r` and `d` to the final N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$.\n\n**Operation:**\n1.  Compute reward Z-scores: $\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})$.\n2.  Compute distance Z-scores: $\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)$.\n3.  For each alive walker `i`, compute the rescaled components with the floor $\\eta$ using the Canonical Logistic Rescale Function (see {prf:ref}`lem-logistic-properties`):\n    *   $r'_i := g_A(z_{r,i}) + \\eta$\n    *   $d'_i := g_A(z_{d,i}) + \\eta$\n4.  Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n\n\n\n$$\nV_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha\n$$",
    "raw_directive": "1864: The final stage of the pipeline assembles the rescaled components from both the reward and diversity channels into the final fitness potential vector.\n1865: \n1866: :::{prf:definition} Fitness Potential Operator\n1867: :label: def-fitness-potential-operator\n1868: \n1869: The **Fitness Potential Operator**, $\\Phi_{\\text{pipeline}}$, maps a swarm state `S` and its raw measurement vectors `r` and `d` to the final N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$.\n1870: \n1871: **Operation:**\n1872: 1.  Compute reward Z-scores: $\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})$.\n1873: 2.  Compute distance Z-scores: $\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)$.\n1874: 3.  For each alive walker `i`, compute the rescaled components with the floor $\\eta$ using the Canonical Logistic Rescale Function (see {prf:ref}`lem-logistic-properties`):\n1875:     *   $r'_i := g_A(z_{r,i}) + \\eta$\n1876:     *   $d'_i := g_A(z_{d,i}) + \\eta$\n1877: 4.  Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n1878: \n1879: \n1880: \n1881: $$\n1882: V_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha\n1883: $$\n1884: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Compute reward Z-scores: z_r = z(S, r, R_agg)",
        "latex": "\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})"
      },
      {
        "type": null,
        "text": "Compute diversity Z-scores: z_d = z(S, d, M_D)",
        "latex": "\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute rescaled reward: r'_i := g_A(z_{r,i}) + \u03b7",
        "latex": "r'_i := g_A(z_{r,i}) + \\eta"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute rescaled diversity: d'_i := g_A(z_{d,i}) + \u03b7",
        "latex": "d'_i := g_A(z_{d,i}) + \\eta"
      },
      {
        "type": null,
        "text": "For each alive walker i, combine: V_i := (d'_i)^\u03b2 \u00b7 (r'_i)^\u03b1",
        "latex": "V_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha"
      }
    ],
    "properties": [
      {
        "name": "Input Dependencies",
        "description": "Depends on swarm state S for contextual Z-scoring and raw vectors r, d of dimension N."
      },
      {
        "name": "Output",
        "description": "N-dimensional vector V_fit, with components defined only for alive walkers."
      },
      {
        "name": "Positivity",
        "description": "Ensured by adding floor \u03b7 to rescaled components before exponentiation."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm State",
        "description": "The current state of the swarm, used in Z-score computations.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "r",
        "name": "Reward Vector",
        "description": "Raw N-dimensional reward measurement vector.",
        "constraints": [],
        "tags": [
          "reward",
          "vector"
        ]
      },
      {
        "symbol": "d",
        "name": "Diversity Vector",
        "description": "Raw N-dimensional diversity measurement vector.",
        "constraints": [],
        "tags": [
          "diversity",
          "vector"
        ]
      },
      {
        "symbol": "R_agg",
        "name": "Reward Aggregation",
        "description": "Aggregation parameter for reward Z-score computation.",
        "constraints": [],
        "tags": [
          "aggregation",
          "reward"
        ]
      },
      {
        "symbol": "M_D",
        "name": "Diversity Metric",
        "description": "Metric parameter for diversity Z-score computation.",
        "constraints": [],
        "tags": [
          "metric",
          "diversity"
        ]
      },
      {
        "symbol": "\u03b7",
        "name": "Floor Value",
        "description": "Minimum additive value for rescaled components to ensure positivity.",
        "constraints": [
          "\u03b7 \u2265 0"
        ],
        "tags": [
          "floor",
          "positivity"
        ]
      },
      {
        "symbol": "\u03b1",
        "name": "Reward Weight",
        "description": "Exponent weighting the reward component in the final combination.",
        "constraints": [],
        "tags": [
          "weight",
          "exponent",
          "reward"
        ]
      },
      {
        "symbol": "\u03b2",
        "name": "Diversity Weight",
        "description": "Exponent weighting the diversity component in the final combination.",
        "constraints": [],
        "tags": [
          "weight",
          "exponent",
          "diversity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "Computations are performed only for alive walkers in the swarm; dead walkers may have V_i = 0 or undefined."
      },
      {
        "type": "dependency",
        "text": "Relies on prior definitions of Z-score function z and rescaling function g_A."
      }
    ],
    "related_refs": [],
    "tags": [
      "fitness",
      "potential",
      "operator",
      "swarm",
      "z-score",
      "rescaling",
      "reward",
      "diversity",
      "pipeline"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1864,
      "end_line": 1884,
      "content_start": 1867,
      "content_end": 1883,
      "header_lines": [
        1865
      ]
    },
    "references": [
      "lem-logistic-properties"
    ],
    "metadata": {
      "label": "def-fitness-potential-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-companion-operator",
    "type": "definition",
    "title": "Companion Selection Operator for Cloning",
    "term": "Companion Selection Operator for Cloning",
    "object_type": "operator",
    "nl_definition": "An operator that, for each walker i in a swarm state S, defines a probability measure C_i(S) to sample a companion c_i independently, using phase-space-aware softmax selection for alive walkers or uniform selection over alive walkers for dead walkers, parameterized by interaction range \u03b5_c.",
    "content_markdown": ":label: def-cloning-companion-operator\n\nThe first step of the cloning action is to select a companion. The **Companion Selection Operator for Cloning** defines, for each walker `i`, a probability measure $\\mathcal{C}_i(S)$ from which a companion `c_i` is sampled independently. This is a hybrid operator that uses the best available information for each type of walker.\n\n**Inputs:**\n*   The swarm state `S`, which defines the set of alive walkers, $\\mathcal{A}_k$, and the set of dead walkers, $\\mathcal{D}_k$.\n*   The interaction range for cloning, $\\varepsilon_c > 0$.\n\n**Operation:**\nThe definition of the measure $\\mathcal{C}_i(S)$ depends on the status of walker `i`:\n\n1.  **If `i` is an ALIVE walker ($i \\in \\mathcal{A}_k$):**\n    The selection is phase-space-aware and restricted to other alive walkers. For any other alive walker $j \\in \\mathcal{A}_k \\setminus \\{i\\}$, the probability of selection is given by a softmax distribution based on algorithmic distance:\n\n\n$$\nP(c_i=j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}\n$$\n\n2.  **If `i` is a DEAD walker ($i \\in \\mathcal{D}_k$):**\n    The selection is a uniform random choice from the entire set of `k` alive walkers. For any alive walker $j \\in \\mathcal{A}_k$:\n\n\n$$\nP(c_i=j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}",
    "raw_directive": "1934: \n1935: #### 5.7.1 Companion Selection Operator for Cloning\n1936: :::{prf:definition} Companion Selection Operator for Cloning\n1937: :label: def-cloning-companion-operator\n1938: \n1939: The first step of the cloning action is to select a companion. The **Companion Selection Operator for Cloning** defines, for each walker `i`, a probability measure $\\mathcal{C}_i(S)$ from which a companion `c_i` is sampled independently. This is a hybrid operator that uses the best available information for each type of walker.\n1940: \n1941: **Inputs:**\n1942: *   The swarm state `S`, which defines the set of alive walkers, $\\mathcal{A}_k$, and the set of dead walkers, $\\mathcal{D}_k$.\n1943: *   The interaction range for cloning, $\\varepsilon_c > 0$.\n1944: \n1945: **Operation:**\n1946: The definition of the measure $\\mathcal{C}_i(S)$ depends on the status of walker `i`:\n1947: \n1948: 1.  **If `i` is an ALIVE walker ($i \\in \\mathcal{A}_k$):**\n1949:     The selection is phase-space-aware and restricted to other alive walkers. For any other alive walker $j \\in \\mathcal{A}_k \\setminus \\{i\\}$, the probability of selection is given by a softmax distribution based on algorithmic distance:\n1950: \n1951: \n1952: $$\n1953: P(c_i=j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}\n1954: $$\n1955: \n1956: 2.  **If `i` is a DEAD walker ($i \\in \\mathcal{D}_k$):**\n1957:     The selection is a uniform random choice from the entire set of `k` alive walkers. For any alive walker $j \\in \\mathcal{A}_k$:\n1958: \n1959: \n1960: $$\n1961: P(c_i=j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}\n1962: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "If i \\in \\mathcal{A}_k: P(c_i = j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}, \\quad \\forall j \\in \\mathcal{A}_k \\setminus \\{i\\}"
      },
      {
        "type": null,
        "text": null,
        "latex": "If i \\in \\mathcal{D}_k: P(c_i = j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}, \\quad \\forall j \\in \\mathcal{A}_k"
      }
    ],
    "properties": [
      {
        "name": "Inputs",
        "description": "Swarm state S (defining \\mathcal{A}_k and \\mathcal{D}_k) and interaction range \\varepsilon_c > 0."
      },
      {
        "name": "Operation for alive walkers",
        "description": "Phase-space-aware selection via softmax on algorithmic distances to other alive walkers."
      },
      {
        "name": "Operation for dead walkers",
        "description": "Uniform random selection from all k alive walkers."
      },
      {
        "name": "Independence",
        "description": "Companions c_i are sampled independently for each i."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm state",
        "description": "Current state of the swarm, defining alive and dead walkers.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "\u03b5_c",
        "name": "interaction range",
        "description": "Positive parameter controlling the cloning interaction range.",
        "constraints": [
          "\u03b5_c > 0"
        ],
        "tags": [
          "range",
          "cloning",
          "positive"
        ]
      },
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Index of the walker for which the companion is selected.",
        "constraints": [],
        "tags": [
          "walker",
          "index"
        ]
      },
      {
        "symbol": "k",
        "name": "number of alive walkers",
        "description": "Size of the set of alive walkers A_k.",
        "constraints": [
          "k \u2265 1"
        ],
        "tags": [
          "alive",
          "count"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "cloning",
      "companion",
      "selection",
      "operator",
      "probability",
      "measure",
      "softmax",
      "uniform",
      "alive",
      "dead"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1934,
      "end_line": 1962,
      "content_start": 1937,
      "content_end": 1961,
      "header_lines": [
        1935
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-cloning-companion-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-score",
    "type": "definition",
    "title": "The Canonical Cloning Score",
    "term": "Canonical Cloning Score",
    "object_type": "score function",
    "nl_definition": "Once a companion c_i has been selected for walker i, the Canonical Cloning Score S_i(c_i) is calculated as the normalized difference between the fitness of the companion and the walker, adjusted by a small epsilon term.",
    "content_markdown": ":label: def-cloning-score\n\nOnce a companion `c_i` has been selected for walker `i`, the **Canonical Cloning Score**, $S_i(c_i)$, is calculated as:\n\n$$\nS_i(c_i) := \\frac{V_{\\text{fit},{c_i}} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}\n$$",
    "raw_directive": "1965: \n1966: #### 5.7.2 Cloning Score\n1967: :::{prf:definition} The Canonical Cloning Score\n1968: :label: def-cloning-score\n1969: \n1970: Once a companion `c_i` has been selected for walker `i`, the **Canonical Cloning Score**, $S_i(c_i)$, is calculated as:\n1971: \n1972: $$\n1973: S_i(c_i) := \\frac{V_{\\text{fit},{c_i}} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}\n1974: $$\n1975: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Definition formula",
        "latex": "S_i(c_i) := \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "S_i(c_i)",
        "name": "cloning_score",
        "description": "The canonical cloning score for walker i and companion c_i",
        "constraints": [],
        "tags": [
          "score"
        ]
      },
      {
        "symbol": "V_{fit,c_i}",
        "name": "companion_fitness",
        "description": "Fitness value of the selected companion c_i",
        "constraints": [],
        "tags": [
          "fitness"
        ]
      },
      {
        "symbol": "V_{fit,i}",
        "name": "walker_fitness",
        "description": "Fitness value of walker i",
        "constraints": [],
        "tags": [
          "fitness"
        ]
      },
      {
        "symbol": "\\varepsilon_{clone}",
        "name": "clone_epsilon",
        "description": "Small epsilon parameter for cloning to avoid division by zero",
        "constraints": [],
        "tags": [
          "epsilon",
          "regularization"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "cloning score",
      "canonical",
      "fitness",
      "walker",
      "companion",
      "selection"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1965,
      "end_line": 1975,
      "content_start": 1968,
      "content_end": 1974,
      "header_lines": [
        1966
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-cloning-score"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-probability",
    "type": "definition",
    "title": "Total Cloning Probability",
    "term": "total cloning probability",
    "object_type": "probability",
    "nl_definition": "The total cloning probability p_i for a walker i is its unconditional probability of being marked for cloning, computed as the expectation over the random selection of companion c_i and threshold T_i.",
    "content_markdown": ":label: def-cloning-probability\n\nThe **total cloning probability**, $p_i$, for a walker `i` is its unconditional probability of being marked for cloning. This is the expectation of the cloning event taken over the random draws of both the companion `c_i` and the threshold `T_i`, where the score is defined by {prf:ref}`def-cloning-score`.\n\n$$\np_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]\n$$\n\nThe inner probability, for a fixed companion, evaluates to $\\min(1, \\max(0, S_i(c_i)/p_{\\max}))$. This gives the final expression for the total cloning probability as an expectation over the choice of companion:\n\n$$\np_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]\n$$",
    "raw_directive": "1977: :::\n1978: \n1979: :::{prf:definition} Total Cloning Probability\n1980: :label: def-cloning-probability\n1981: \n1982: The **total cloning probability**, $p_i$, for a walker `i` is its unconditional probability of being marked for cloning. This is the expectation of the cloning event taken over the random draws of both the companion `c_i` and the threshold `T_i`, where the score is defined by {prf:ref}`def-cloning-score`.\n1983: \n1984: $$\n1985: p_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]\n1986: $$\n1987: \n1988: The inner probability, for a fixed companion, evaluates to $\\min(1, \\max(0, S_i(c_i)/p_{\\max}))$. This gives the final expression for the total cloning probability as an expectation over the choice of companion:\n1989: \n1990: $$\n1991: p_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]\n1992: $$\n1993: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "p_i := E_{c_i ~ C_i(S)} [ P_{T_i ~ U(0, p_max)} ( S_i(c_i) > T_i ) ]",
        "latex": "p_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]"
      },
      {
        "type": null,
        "text": "p_i = E_{c_i ~ C_i(S)} [ min(1, max(0, S_i(c_i) / p_max )) ]",
        "latex": "p_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]"
      }
    ],
    "properties": [
      {
        "name": "unconditional probability",
        "description": "Marginalizes over companion selection and threshold randomness"
      },
      {
        "name": "bounded",
        "description": "Always satisfies 0 \u2264 p_i \u2264 1 due to min-max clipping"
      }
    ],
    "parameters": [
      {
        "symbol": "p_i",
        "name": "total cloning probability",
        "description": "Unconditional probability of walker i being marked for cloning",
        "constraints": [
          "0 \u2264 p_i \u2264 1"
        ],
        "tags": [
          "probability"
        ]
      },
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Identifier for the walker",
        "constraints": [],
        "tags": [
          "walker",
          "index"
        ]
      },
      {
        "symbol": "c_i",
        "name": "companion",
        "description": "Randomly selected companion for walker i",
        "constraints": [],
        "tags": [
          "companion"
        ]
      },
      {
        "symbol": "S_i(c_i)",
        "name": "score",
        "description": "Score of companion c_i for walker i",
        "constraints": [],
        "tags": [
          "score"
        ]
      },
      {
        "symbol": "T_i",
        "name": "threshold",
        "description": "Random threshold drawn from uniform distribution",
        "constraints": [
          "0 < T_i < p_max"
        ],
        "tags": [
          "threshold"
        ]
      },
      {
        "symbol": "p_max",
        "name": "maximum probability",
        "description": "Upper bound for the threshold distribution",
        "constraints": [
          "0 < p_max \u2264 1"
        ],
        "tags": [
          "maximum",
          "bound"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "simplification",
        "text": "The inner probability for a fixed companion evaluates to min(1, max(0, S_i(c_i)/p_max))"
      },
      {
        "type": "interpretation",
        "text": "Represents the expected cloning rate for walker i across possible companions and thresholds"
      }
    ],
    "related_refs": [],
    "tags": [
      "cloning",
      "probability",
      "expectation",
      "walker",
      "companion",
      "threshold",
      "score"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1977,
      "end_line": 1993,
      "content_start": 1980,
      "content_end": 1992,
      "header_lines": [
        1978
      ]
    },
    "references": [
      "def-cloning-score"
    ],
    "metadata": {
      "label": "def-cloning-probability"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-decision",
    "type": "definition",
    "title": "The Stochastic Cloning Decision",
    "term": "Stochastic Cloning Decision",
    "object_type": "decision process",
    "nl_definition": "A decision mechanism involving stochastic cloning, as introduced in section 5.7.3.",
    "content_markdown": ":label: def-cloning-decision",
    "raw_directive": "2005: #### 5.7.3  Cloning Decision\n2006: \n2007: :::{prf:definition} The Stochastic Cloning Decision\n2008: :label: def-cloning-decision\n2009: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "warning",
        "text": "The directive appears incomplete; no formal definition body is provided."
      }
    ],
    "related_refs": [],
    "tags": [
      "stochastic",
      "cloning",
      "decision",
      "probability",
      "reproduction"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 2005,
      "end_line": 2009,
      "content_start": 2008,
      "content_end": 2008,
      "header_lines": [
        2006
      ]
    },
    "references": [
      "def-cloning-score"
    ],
    "metadata": {
      "label": "def-cloning-decision"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-inelastic-collision-update",
    "type": "definition",
    "title": "The Inelastic Collision State Update",
    "term": "Inelastic Collision State Update",
    "object_type": "state update process",
    "nl_definition": "A simultaneous, momentum-conserving update for groups of cloners selecting the same companion, resetting cloner positions with jitter and applying an inelastic velocity collapse with tunable restitution to control kinetic energy dissipation.",
    "content_markdown": ":label: def-inelastic-collision-update\n\nLet the set of all walkers marked for cloning be `C_set`. For each cloner $i \\in C_set$, let `c_i` be its selected companion. The intermediate swarm state `S'` is constructed as follows.\n\nFirst, for each unique companion `c` in the swarm, we identify the set of all cloners that selected it:\n\n$$\nI_c := \\{j \\in C_{set} \\mid c_j = c\\}\n$$\n\nLet `M = |I_c|` be the number of walkers cloning from companion `c`. The update is then defined for each `(M+1)`-particle system consisting of the companion `c` and its set of cloners `I_c`.\n\n1.  **Position Updates:**\n    *   For each cloner $j \\in I_c$, its position is reset to that of its companion `c`, plus independent Gaussian jitter:\n\n\n$$\nx'_j := x_c + \\sigma_x \\zeta_j^x\n$$\n\n    *   The position of the companion `c` is unchanged by this interaction: `x'_c := x_c`.\n\n2.  **Velocity Updates (The Inelastic Collapse):**\n    The velocities of all `M+1` interacting walkers are updated simultaneously in a process that conserves the group's total momentum.\n\n    *   **a. Center-of-Mass Velocity:** First, compute the center-of-mass velocity of the `(M+1)`-particle interacting system. This quantity is conserved throughout the collision.\n\n\n$$\nV_{COM, c} := \\frac{1}{M+1} \\left( v_c + \\sum_{j \\in I_c} v_j \\right)\n$$\n\n    *   **b. Update Relative Velocities:** For each walker `k` in the system ($k \\in I_c \\cup {c}$), its velocity relative to the CoM is `u_k = v_k - V_{COM,c}`. The new relative velocities `u'_k` are defined by a random rotation and a frictional contraction.\n        Let $\\alpha_restitution \\in [0, 1]$ be a fixed algorithmic parameter representing the coefficient of restitution. For each `k`, let `R_k` be a random orthogonal transformation that isotropically rotates `u_k` (i.e., `R_k(u_k)` has the same magnitude as `u_k` but a uniformly random direction on the `(d-1)`-sphere). The new relative velocity is:\n\n\n$$\nu'_k := \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n$$\n\n    *   **c. Return to Lab Frame:** The final velocities for all interacting walkers are then reconstructed:\n\n\n$$\nv'_k := V_{COM, c} + u'_k\n$$\n\n3.  **Uninvolved Walkers:** Any walker `k` that is not a cloner and was not selected as a companion by any cloner has its state `(x_k, v_k)` unchanged.\n\n**Analysis of the Restitution Parameter $\\alpha_restitution$:**\n\nThis model introduces $\\alpha_restitution$ as a crucial hyperparameter that controls the velocity variance expansion caused by the velocity reset mechanism during cloning.\n\n*   If **$\\alpha_restitution = 1$**, the collision is **perfectly elastic**. The magnitudes of the relative velocities are preserved (`||u'_k|| = ||u_k||`), and the total kinetic energy of the interacting system is conserved. In this regime, cloning redistributes kinetic energy among walkers but does not directly dissipate it. However, the velocity reset mechanism still causes bounded expansion of $V_{\\text{Var},v}$ as walkers' velocities are reset based on their companions.\n\n*   If **$\\alpha_restitution = 0$**, the collision is **perfectly inelastic**. All new relative velocities are zero (`u'_k = 0`), meaning all `M+1` walkers emerge with the identical center-of-mass velocity, `v'_k = V_{COM,c}`. This corresponds to the **maximum possible dissipation** of the group's internal kinetic energy while still conserving total momentum. In this regime, the velocity variance expansion is minimized, as all walkers in a cloning group collapse to a single velocity.\n\n*   If **$\\alpha_restitution \\in (0, 1)$**, the cloning event has **intermediate dissipation**. The internal kinetic energy of the interacting group is reduced by a factor of $\\alpha_restitution^{2}$. This parameter provides a tunable mechanism for controlling the trade-off between maintaining kinetic diversity and bounding velocity variance expansion.",
    "raw_directive": "2017: This model handles the complex but common scenario where multiple \"cloners\" (either unfit alive walkers or dead walkers being revived) select the same high-fitness walker as their companion. Instead of a series of pairwise interactions, all cloners associated with a single companion are treated as a single interacting system that undergoes a simultaneous, momentum-conserving \"inelastic collapse.\" This process includes a tunable parameter for energy dissipation, allowing the cloning operator itself to act as a powerful mechanism for controlling the swarm's kinetic energy.\n2018: \n2019: :::{prf:definition} The Inelastic Collision State Update\n2020: :label: def-inelastic-collision-update\n2021: \n2022: Let the set of all walkers marked for cloning be `C_set`. For each cloner $i \\in C_set$, let `c_i` be its selected companion. The intermediate swarm state `S'` is constructed as follows.\n2023: \n2024: First, for each unique companion `c` in the swarm, we identify the set of all cloners that selected it:\n2025: \n2026: $$\n2027: I_c := \\{j \\in C_{set} \\mid c_j = c\\}\n2028: $$\n2029: \n2030: Let `M = |I_c|` be the number of walkers cloning from companion `c`. The update is then defined for each `(M+1)`-particle system consisting of the companion `c` and its set of cloners `I_c`.\n2031: \n2032: 1.  **Position Updates:**\n2033:     *   For each cloner $j \\in I_c$, its position is reset to that of its companion `c`, plus independent Gaussian jitter:\n2034: \n2035: \n2036: $$\n2037: x'_j := x_c + \\sigma_x \\zeta_j^x\n2038: $$\n2039: \n2040:     *   The position of the companion `c` is unchanged by this interaction: `x'_c := x_c`.\n2041: \n2042: 2.  **Velocity Updates (The Inelastic Collapse):**\n2043:     The velocities of all `M+1` interacting walkers are updated simultaneously in a process that conserves the group's total momentum.\n2044: \n2045:     *   **a. Center-of-Mass Velocity:** First, compute the center-of-mass velocity of the `(M+1)`-particle interacting system. This quantity is conserved throughout the collision.\n2046: \n2047: \n2048: $$\n2049: V_{COM, c} := \\frac{1}{M+1} \\left( v_c + \\sum_{j \\in I_c} v_j \\right)\n2050: $$\n2051: \n2052:     *   **b. Update Relative Velocities:** For each walker `k` in the system ($k \\in I_c \\cup {c}$), its velocity relative to the CoM is `u_k = v_k - V_{COM,c}`. The new relative velocities `u'_k` are defined by a random rotation and a frictional contraction.\n2053:         Let $\\alpha_restitution \\in [0, 1]$ be a fixed algorithmic parameter representing the coefficient of restitution. For each `k`, let `R_k` be a random orthogonal transformation that isotropically rotates `u_k` (i.e., `R_k(u_k)` has the same magnitude as `u_k` but a uniformly random direction on the `(d-1)`-sphere). The new relative velocity is:\n2054: \n2055: \n2056: $$\n2057: u'_k := \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n2058: $$\n2059: \n2060:     *   **c. Return to Lab Frame:** The final velocities for all interacting walkers are then reconstructed:\n2061: \n2062: \n2063: $$\n2064: v'_k := V_{COM, c} + u'_k\n2065: $$\n2066: \n2067: 3.  **Uninvolved Walkers:** Any walker `k` that is not a cloner and was not selected as a companion by any cloner has its state `(x_k, v_k)` unchanged.\n2068: \n2069: **Analysis of the Restitution Parameter $\\alpha_restitution$:**\n2070: \n2071: This model introduces $\\alpha_restitution$ as a crucial hyperparameter that controls the velocity variance expansion caused by the velocity reset mechanism during cloning.\n2072: \n2073: *   If **$\\alpha_restitution = 1$**, the collision is **perfectly elastic**. The magnitudes of the relative velocities are preserved (`||u'_k|| = ||u_k||`), and the total kinetic energy of the interacting system is conserved. In this regime, cloning redistributes kinetic energy among walkers but does not directly dissipate it. However, the velocity reset mechanism still causes bounded expansion of $V_{\\text{Var},v}$ as walkers' velocities are reset based on their companions.\n2074: \n2075: *   If **$\\alpha_restitution = 0$**, the collision is **perfectly inelastic**. All new relative velocities are zero (`u'_k = 0`), meaning all `M+1` walkers emerge with the identical center-of-mass velocity, `v'_k = V_{COM,c}`. This corresponds to the **maximum possible dissipation** of the group's internal kinetic energy while still conserving total momentum. In this regime, the velocity variance expansion is minimized, as all walkers in a cloning group collapse to a single velocity.\n2076: \n2077: *   If **$\\alpha_restitution \\in (0, 1)$**, the cloning event has **intermediate dissipation**. The internal kinetic energy of the interacting group is reduced by a factor of $\\alpha_restitution^{2}$. This parameter provides a tunable mechanism for controlling the trade-off between maintaining kinetic diversity and bounding velocity variance expansion.\n2078: ",
    "formal_conditions": [],
    "properties": [
      {
        "name": "Momentum Conservation",
        "description": "The total momentum of the (M+1)-particle interacting system is conserved through the center-of-mass velocity."
      },
      {
        "name": "Position Jitter",
        "description": "Cloners' positions are reset to the companion's position plus independent Gaussian noise."
      },
      {
        "name": "Tunable Dissipation",
        "description": "Internal kinetic energy reduced by factor \u03b1_restitution\u00b2, allowing control over velocity variance expansion."
      },
      {
        "name": "Uninvolved Walkers",
        "description": "Walkers not participating in cloning remain unchanged."
      }
    ],
    "parameters": [
      {
        "symbol": "\u03b1_restitution",
        "name": "coefficient of restitution",
        "description": "Fixed algorithmic parameter in [0,1] representing the coefficient of restitution, controlling energy dissipation in the inelastic collapse.",
        "constraints": [
          "\u2208 [0,1]"
        ],
        "tags": [
          "restitution",
          "dissipation",
          "hyperparameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "analysis",
        "text": "If \u03b1_restitution = 1, perfectly elastic collision: magnitudes of relative velocities preserved, kinetic energy conserved, but velocity reset causes bounded variance expansion."
      },
      {
        "type": "analysis",
        "text": "If \u03b1_restitution = 0, perfectly inelastic: all walkers in group get identical V_{COM,c} velocity, maximizing dissipation of internal kinetic energy."
      },
      {
        "type": "analysis",
        "text": "For \u03b1_restitution \u2208 (0,1), intermediate dissipation: internal kinetic energy reduced by \u03b1_restitution\u00b2, balancing kinetic diversity and variance control."
      }
    ],
    "related_refs": [],
    "tags": [
      "inelastic-collision",
      "cloning-update",
      "momentum-conservation",
      "velocity-reset",
      "restitution-parameter"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 2017,
      "end_line": 2078,
      "content_start": 2020,
      "content_end": 2077,
      "header_lines": [
        2018
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-inelastic-collision-update"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-unified-high-low-error-sets",
    "type": "definition",
    "title": "The Unified High-Error and Low-Error Sets",
    "term": "Unified High-Error Set H_k(\u03b5) and Low-Error Set L_k(\u03b5)",
    "object_type": "sets",
    "nl_definition": "A partition of the alive set A_k into a high-error set H_k(\u03b5), consisting of walkers in small invalid clusters or outlier clusters with high phase-space variance contribution, and a complementary low-error set L_k(\u03b5), constructed via hierarchical clustering on phase-space distances with statistical validity and outlier detection.",
    "content_markdown": ":label: def-unified-high-low-error-sets\n\nFor a given swarm `k` with alive set $\\mathcal{A}_k$ ($k \\ge 2$), we define a partition into a unified high-error set $H_k(\\epsilon)$ and a unified low-error set $L_k(\\epsilon)$ using a **clustering-based approach** that applies uniformly across all interaction regimes. This unified approach captures both global outlier structure and local phase-space clustering through a single consistent mechanism.\n\n**Phase-Space Clustering Construction:**\n\nThe construction proceeds in four steps:\n\n1.  **Clustering:** Partition the alive set $\\mathcal{A}_k$ into disjoint clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with a maximum cluster diameter $D_{\\text{diam}}(\\epsilon) := c_d \\cdot \\epsilon$ (where $c_d > 0$ is a fixed constant, typically $c_d = 2$). Each cluster $G_m$ satisfies:\n\n$$\n\\text{diam}(G_m) := \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)\n$$\n\nwhere $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$ is the algorithmic phase-space distance.\n\n2.  **Statistical Validity Constraint:** To ensure that cluster-level statistics are meaningful, we impose a minimum cluster size requirement. Let $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$ be the minimum statistically valid cluster size. All clusters with $|G_m| < k_{\\min}$ are marked as **invalid** and their walkers are automatically included in the high-error set (as they represent statistically unreliable outlier configurations).\n\n3.  **Outlier Cluster Identification:** For each valid cluster $G_m$ (with $|G_m| \\ge k_{\\min}$), compute its center of mass in phase space: $(\\mu_{x,m}, \\mu_{v,m})$. Compute the between-cluster hypocoercive variance contribution:\n\n$$\n\\text{Contrib}(G_m) := |G_m| \\left(\\|\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\|\\mu_{v,m} - \\mu_v\\|^2\\right)\n$$\n\nwhere $(\\mu_x, \\mu_v)$ is the global center of mass. Sort valid clusters by $\\text{Contrib}(G_m)$ in descending order, and let $O_M \\subseteq \\{1, \\ldots, M\\}$ be the smallest set of cluster indices (among valid clusters) whose cumulative contribution meets or exceeds a fraction $(1-\\varepsilon_O)$ of the total contribution from valid clusters (where $\\varepsilon_O \\in (0, 1)$ is a fixed structural parameter, typically $\\varepsilon_O = 0.1$):\n\n$$\n\\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\\\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)\n$$\n\n4.  **Unified High-Error Set Construction:** The unified high-error set is the union of all walkers in outlier clusters plus all walkers in invalid clusters:\n\n$$\nH_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)\n$$\n\nThe **Unified Low-Error Set** is the complement:\n\n$$\nL_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)",
    "raw_directive": "2371: Therefore, this section formally defines these sets based on the swarm's full **phase-space configuration**. We will partition the swarm based on two distinct phase-space measures: global kinematic dispersion and local phase-space density. These definitions create the crucial link between the state of the swarm and the signals measured by the algorithm. The remainder of the Keystone analysis will then be dedicated to proving that high *positional* variance is a sufficient condition to force a non-trivial number of walkers into these *phase-space* defined error sets.\n2372: \n2373: :::{prf:definition} The Unified High-Error and Low-Error Sets\n2374: :label: def-unified-high-low-error-sets\n2375: \n2376: For a given swarm `k` with alive set $\\mathcal{A}_k$ ($k \\ge 2$), we define a partition into a unified high-error set $H_k(\\epsilon)$ and a unified low-error set $L_k(\\epsilon)$ using a **clustering-based approach** that applies uniformly across all interaction regimes. This unified approach captures both global outlier structure and local phase-space clustering through a single consistent mechanism.\n2377: \n2378: **Phase-Space Clustering Construction:**\n2379: \n2380: The construction proceeds in four steps:\n2381: \n2382: 1.  **Clustering:** Partition the alive set $\\mathcal{A}_k$ into disjoint clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with a maximum cluster diameter $D_{\\text{diam}}(\\epsilon) := c_d \\cdot \\epsilon$ (where $c_d > 0$ is a fixed constant, typically $c_d = 2$). Each cluster $G_m$ satisfies:\n2383: \n2384: $$\n2385: \\text{diam}(G_m) := \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)\n2386: $$\n2387: \n2388: where $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$ is the algorithmic phase-space distance.\n2389: \n2390: 2.  **Statistical Validity Constraint:** To ensure that cluster-level statistics are meaningful, we impose a minimum cluster size requirement. Let $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$ be the minimum statistically valid cluster size. All clusters with $|G_m| < k_{\\min}$ are marked as **invalid** and their walkers are automatically included in the high-error set (as they represent statistically unreliable outlier configurations).\n2391: \n2392: 3.  **Outlier Cluster Identification:** For each valid cluster $G_m$ (with $|G_m| \\ge k_{\\min}$), compute its center of mass in phase space: $(\\mu_{x,m}, \\mu_{v,m})$. Compute the between-cluster hypocoercive variance contribution:\n2393: \n2394: $$\n2395: \\text{Contrib}(G_m) := |G_m| \\left(\\|\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\|\\mu_{v,m} - \\mu_v\\|^2\\right)\n2396: $$\n2397: \n2398: where $(\\mu_x, \\mu_v)$ is the global center of mass. Sort valid clusters by $\\text{Contrib}(G_m)$ in descending order, and let $O_M \\subseteq \\{1, \\ldots, M\\}$ be the smallest set of cluster indices (among valid clusters) whose cumulative contribution meets or exceeds a fraction $(1-\\varepsilon_O)$ of the total contribution from valid clusters (where $\\varepsilon_O \\in (0, 1)$ is a fixed structural parameter, typically $\\varepsilon_O = 0.1$):\n2399: \n2400: $$\n2401: \\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\\\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)\n2402: $$\n2403: \n2404: 4.  **Unified High-Error Set Construction:** The unified high-error set is the union of all walkers in outlier clusters plus all walkers in invalid clusters:\n2405: \n2406: $$\n2407: H_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)\n2408: $$\n2409: \n2410: The **Unified Low-Error Set** is the complement:\n2411: \n2412: $$\n2413: L_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)\n2414: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Partition A_k into clusters {G_1, ..., G_M} using complete-linkage hierarchical clustering with max diameter D_diam(\u03b5) = c_d \u00b7 \u03b5, where diam(G_m) = max_{i,j \u2208 G_m} d_alg(i,j) \u2264 D_diam(\u03b5) and d_alg(i,j)^2 = ||x_i - x_j||^2 + \u03bb_alg ||v_i - v_j||^2.",
        "latex": "Partition $\\mathcal{A}_k$ into clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with max diameter $D_{\\text{diam}}(\\epsilon) = c_d \\cdot \\epsilon$, where $\\text{diam}(G_m) = \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)$ and $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$."
      },
      {
        "type": null,
        "text": "Impose minimum cluster size k_min = max(5, \u23080.05k\u2309); clusters with |G_m| < k_min are invalid and their walkers go to H_k(\u03b5).",
        "latex": "Impose minimum cluster size $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$; clusters with $|G_m| < k_{\\min}$ are invalid."
      },
      {
        "type": null,
        "text": "For valid clusters (|G_m| \u2265 k_min), compute center (\u03bc_{x,m}, \u03bc_{v,m}) and Contrib(G_m) = |G_m| (||\u03bc_{x,m} - \u03bc_x||^2 + \u03bb_v ||\u03bc_{v,m} - \u03bc_v||^2), where (\u03bc_x, \u03bc_v) is global center. Identify outlier indices O_M such that sum_{m \u2208 O_M} Contrib(G_m) \u2265 (1 - \u03b5_O) total valid contribution.",
        "latex": "For valid clusters, compute $\\text{Contrib}(G_m) := |G_m| \\left(\\||\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\||\\mu_{v,m} - \\mu_v\\|^2\\right)$. Identify $O_M$ s.t. $\\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)$."
      },
      {
        "type": null,
        "text": "H_k(\u03b5) = union of G_m for m \u2208 O_M and invalid m; L_k(\u03b5) = A_k \\ H_k(\u03b5).",
        "latex": "$H_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)$; $L_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)$."
      }
    ],
    "properties": [
      {
        "name": "Partition Property",
        "description": "H_k(\u03b5) and L_k(\u03b5) form a partition of A_k: disjoint and their union is A_k."
      },
      {
        "name": "Unified Approach",
        "description": "Applies consistently across all interaction regimes, capturing global outliers and local clustering via phase-space measures."
      },
      {
        "name": "Statistical Validity",
        "description": "Invalid small clusters (|G_m| < k_min) are treated as high-error to ensure reliable statistics."
      },
      {
        "name": "Outlier Detection",
        "description": "Based on hypocoercive variance contribution, selecting clusters covering (1 - \u03b5_O) of total valid contribution."
      }
    ],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "Index of the swarm step",
        "constraints": [
          "k \u2265 2"
        ],
        "tags": [
          "swarm",
          "step"
        ]
      },
      {
        "symbol": "\u03b5",
        "name": "error parameter",
        "description": "Threshold parameter controlling cluster diameter and error scale",
        "constraints": [],
        "tags": [
          "error",
          "threshold"
        ]
      },
      {
        "symbol": "c_d",
        "name": "diameter constant",
        "description": "Fixed constant scaling the maximum cluster diameter D_diam(\u03b5)",
        "constraints": [
          "c_d > 0",
          "typically c_d = 2"
        ],
        "tags": [
          "clustering",
          "diameter"
        ]
      },
      {
        "symbol": "k_min",
        "name": "minimum cluster size",
        "description": "Minimum size for statistically valid clusters, defined as max(5, \u23080.05k\u2309)",
        "constraints": [
          "k_min \u2265 5"
        ],
        "tags": [
          "cluster",
          "validity"
        ]
      },
      {
        "symbol": "\u03b5_O",
        "name": "outlier fraction parameter",
        "description": "Structural parameter determining the fraction of total contribution for outlier clusters",
        "constraints": [
          "\u03b5_O \u2208 (0,1)",
          "typically \u03b5_O = 0.1"
        ],
        "tags": [
          "outlier",
          "contribution"
        ]
      },
      {
        "symbol": "\u03bb_alg",
        "name": "algorithmic velocity weight",
        "description": "Weight parameter in the phase-space distance d_alg",
        "constraints": [],
        "tags": [
          "distance",
          "velocity"
        ]
      },
      {
        "symbol": "\u03bb_v",
        "name": "variance velocity weight",
        "description": "Weight parameter in the contribution variance calculation",
        "constraints": [],
        "tags": [
          "variance",
          "velocity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "construction",
        "text": "The clustering uses complete-linkage hierarchical method for phase-space partitioning."
      },
      {
        "type": "parameters",
        "text": "Constants like c_d=2, \u03b5_O=0.1 are typical; \u03bb_alg and \u03bb_v are fixed algorithmic parameters."
      },
      {
        "type": "motivation",
        "text": "Links swarm state to algorithm signals via global kinematic dispersion and local phase-space density."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "phase-space",
      "clustering",
      "error-sets",
      "high-error",
      "low-error",
      "partition",
      "kinematic-dispersion"
    ],
    "document_id": "03_cloning",
    "section": "## 6. The Geometry of Error: From System Error to a Guaranteed Geometric Structure",
    "span": {
      "start_line": 2371,
      "end_line": 2414,
      "content_start": 2374,
      "content_end": 2413,
      "header_lines": [
        2372
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-unified-high-low-error-sets"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 6,
      "chapter_file": "chapter_6.json",
      "section_id": "## 6. The Geometry of Error: From System Error to a Guaranteed Geometric Structure"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-max-patched-std",
    "type": "definition",
    "title": "Maximum Patched Standard Deviation",
    "term": "maximum patched standard deviation",
    "object_type": "bound",
    "nl_definition": "The maximum value that the patched standard deviation function can attain over its entire possible input domain.",
    "content_markdown": ":label: def-max-patched-std\n\nLet $V_{\\max}$ be the uniform upper bound on a raw measurement's absolute value (either $V_{\\max}^{(R)}$ for rewards or $D_{\\text{valid}}$ for distances). The **maximum patched standard deviation**, $\\sigma'_{\\max}$, is the maximum value that the patched standard deviation function can attain over its entire possible input domain.\n\n$$\n\\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)\n$$",
    "raw_directive": "3656: The first component we must bound is the denominator of the standardization formula. The following definition establishes a uniform upper bound on the patched standard deviation (see {prf:ref}`def-patched-std-dev-function`).\n3657: \n3658: :::{prf:definition} Maximum Patched Standard Deviation\n3659: :label: def-max-patched-std\n3660: \n3661: Let $V_{\\max}$ be the uniform upper bound on a raw measurement's absolute value (either $V_{\\max}^{(R)}$ for rewards or $D_{\\text{valid}}$ for distances). The **maximum patched standard deviation**, $\\sigma'_{\\max}$, is the maximum value that the patched standard deviation function can attain over its entire possible input domain.\n3662: \n3663: $$\n3664: \\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)\n3665: $$\n3666: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "\u03c3'_max := sup_{0 \u2264 V \u2264 V_max^2} \u03c3'_patch(V)",
        "latex": "\\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)"
      }
    ],
    "properties": [
      {
        "name": "upper bound",
        "description": "provides a uniform upper bound on the patched standard deviation \u03c3'_patch(V) for all admissible V in [0, V_max^2]"
      }
    ],
    "parameters": [
      {
        "symbol": "V_{\\max}",
        "name": "V_max",
        "description": "uniform upper bound on a raw measurement's absolute value (either V_{\\max}^{(R)} for rewards or D_{\\text{valid}} for distances)",
        "constraints": [],
        "tags": [
          "upper bound",
          "measurement",
          "reward",
          "distance"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This definition establishes a uniform upper bound on the patched standard deviation for use in the denominator of the standardization formula."
      }
    ],
    "related_refs": [],
    "tags": [
      "patched",
      "standard deviation",
      "maximum",
      "bound",
      "supremum",
      "standardization"
    ],
    "document_id": "03_cloning",
    "section": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation",
    "span": {
      "start_line": 3656,
      "end_line": 3666,
      "content_start": 3659,
      "content_end": 3665,
      "header_lines": [
        3657
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-max-patched-std"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 7,
      "chapter_file": "chapter_7.json",
      "section_id": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-unfit-set",
    "type": "definition",
    "title": "The Unfit Set",
    "term": "Unfit Set",
    "object_type": "set",
    "nl_definition": "The unfit set of a swarm is the subset of its alive walkers whose individual fitness potentials are at most the swarm's average fitness potential.",
    "content_markdown": ":label: def-unfit-set\n\nFor a given swarm `k` with alive set $\\mathcal{A}_k$ and a calculated fitness potential vector $(V_{k,i})_{i \\in \\mathcal{A}_k}$, the **unfit set**, $U_k$, is the subset of alive walkers whose fitness potential is less than or equal to the swarm's mean fitness potential, $\\mu_{V,k} = \\frac{1}{k}\\sum_{j \\in \\mathcal{A}_k} V_{k,j}$.\n\n$$\nU_k := \\{i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k}\\}",
    "raw_directive": "4559: The first pillar of the overlap proof is to show that the fitness signal generated by a high-error swarm is a collective phenomenon. A large `V_struct` implies a large internal variance, which is guaranteed to produce a non-vanishing raw measurement variance ([](#thm-geometry-guarantees-variance)). This raw signal robustly propagates through the measurement pipeline to create a guaranteed microscopic gap in the final fitness potentials, ensuring a non-trivial overall fitness range, $\\kappa_V,gap(\\varepsilon) > 0$. The following lemma proves that such a gap cannot be explained by a single unusually fit or unfit walker; it necessitates a statistically significant imbalance in the fitness distribution of the entire population.\n4560: \n4561: :::{prf:definition} The Unfit Set\n4562: :label: def-unfit-set\n4563: \n4564: For a given swarm `k` with alive set $\\mathcal{A}_k$ and a calculated fitness potential vector $(V_{k,i})_{i \\in \\mathcal{A}_k}$, the **unfit set**, $U_k$, is the subset of alive walkers whose fitness potential is less than or equal to the swarm's mean fitness potential, $\\mu_{V,k} = \\frac{1}{k}\\sum_{j \\in \\mathcal{A}_k} V_{k,j}$.\n4565: \n4566: $$\n4567: U_k := \\{i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k}\\}\n4568: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "U_k := \\{ i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k} \\}"
      },
      {
        "type": null,
        "text": "where \\mu_{V,k} = \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}",
        "latex": "\\mu_{V,k} = \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "Identifier for the swarm.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "\\mathcal{A}_k",
        "name": "alive set",
        "description": "The set of alive walkers in swarm k.",
        "constraints": [],
        "tags": [
          "alive",
          "walkers"
        ]
      },
      {
        "symbol": "V_{k,i}",
        "name": "fitness potential",
        "description": "Fitness potential of walker i in swarm k.",
        "constraints": [],
        "tags": [
          "fitness",
          "potential"
        ]
      },
      {
        "symbol": "\\mu_{V,k}",
        "name": "mean fitness potential",
        "description": "Average fitness potential across alive walkers in swarm k, defined as \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}.",
        "constraints": [],
        "tags": [
          "mean",
          "average"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "Used in proofs involving fitness distribution imbalances in swarms."
      }
    ],
    "related_refs": [
      "thm-geometry-guarantees-variance"
    ],
    "tags": [
      "unfit-set",
      "swarm",
      "fitness-potential",
      "mean-fitness",
      "alive-walkers",
      "population-subset"
    ],
    "document_id": "03_cloning",
    "section": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation",
    "span": {
      "start_line": 4559,
      "end_line": 4568,
      "content_start": 4562,
      "content_end": 4567,
      "header_lines": [
        4560
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-unfit-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 7,
      "chapter_file": "chapter_7.json",
      "section_id": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-critical-target-set",
    "type": "definition",
    "title": "The Critical Target Set",
    "term": "critical target set",
    "object_type": "set",
    "nl_definition": "For a state in the high-error regime, with k the index of the high-variance swarm, the critical target set I_target is the set of walkers that are simultaneously stably alive in both swarms, unfit in swarm k, and high-error in swarm k.",
    "content_markdown": ":label: def-critical-target-set\n\nFor a state in the high-error regime, let $k$ be the index of the high-variance swarm. The **critical target set**, $I_{\\text{target}}$, is the set of walkers that are simultaneously stably alive, unfit in swarm $k$, and high-error in swarm $k$.\n\n$$\nI_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)\n$$",
    "raw_directive": "4761: The analysis in Chapter 7 proved that this high-variance swarm $k$ contains a non-vanishing fraction of \"unfit\" walkers ($U_k$) and a non-vanishing fraction of \"high-error\" walkers ($H_k$), and that these two sets have a substantial overlap. The final step of the Keystone proof is to show that the corrective cloning action is concentrated on the walkers that are simultaneously members of all three critical sets: those that are alive in both swarms (and thus can contribute to the contractive force), those that are unfit (and thus targeted for cloning), and those that are high-error (and thus the source of the problem). We formally define this intersection as our target set.\n4762: \n4763: :::{prf:definition} The Critical Target Set\n4764: :label: def-critical-target-set\n4765: \n4766: For a state in the high-error regime, let $k$ be the index of the high-variance swarm. The **critical target set**, $I_{\\text{target}}$, is the set of walkers that are simultaneously stably alive, unfit in swarm $k$, and high-error in swarm $k$.\n4767: \n4768: $$\n4769: I_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)\n4770: $$\n4771: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "I_target := I_11 \u2229 U_k \u2229 H_k(\u03b5)",
        "latex": "I_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)"
      }
    ],
    "properties": [
      {
        "name": "intersection",
        "description": "intersection of sets of stably alive walkers (I_11), unfit walkers (U_k), and high-error walkers (H_k(\u03b5))"
      }
    ],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "index of the high-variance swarm",
        "constraints": [
          "k is the index for the high-variance swarm in the high-error regime"
        ],
        "tags": [
          "swarm",
          "high-variance"
        ]
      },
      {
        "symbol": "\\epsilon",
        "name": "error parameter",
        "description": "parameter defining the high-error threshold in H_k",
        "constraints": [
          "\\epsilon > 0, small"
        ],
        "tags": [
          "error",
          "threshold"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "motivation",
        "text": "This set represents walkers that are alive in both swarms (contributing to contractive force), unfit (targeted for cloning), and high-error (source of the problem), concentrating the corrective cloning action."
      }
    ],
    "related_refs": [],
    "tags": [
      "critical target set",
      "high-variance swarm",
      "unfit walkers",
      "high-error walkers",
      "intersection",
      "stably alive",
      "corrective cloning"
    ],
    "document_id": "03_cloning",
    "section": "## 8. The N-Uniform Quantitative Keystone Lemma",
    "span": {
      "start_line": 4761,
      "end_line": 4771,
      "content_start": 4764,
      "content_end": 4770,
      "header_lines": [
        4762
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-critical-target-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 8,
      "chapter_file": "chapter_8.json",
      "section_id": "## 8. The N-Uniform Quantitative Keystone Lemma"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-operator-formal",
    "type": "definition",
    "title": "The Cloning Operator $\\Psi_{\\text{clone}}$",
    "term": "cloning operator $\\Psi_{\\text{clone}}$",
    "object_type": "Markov transition kernel",
    "nl_definition": "A stochastic operator that maps a swarm configuration with at least one alive walker to a probability distribution over new all-alive swarm configurations, defined as the composition of measure, fitness, decision, and update sub-operators.",
    "content_markdown": ":label: def-cloning-operator-formal\n\nThe **cloning operator** $\\Psi_{\\text{clone}}$ is a Markov transition kernel on the swarm state space $\\Sigma_N$. For any input swarm configuration $S \\in \\Sigma_N$, it produces a probability measure $\\Psi_{\\text{clone}}(S, \\cdot)$ on $\\Sigma_N$.\n\n**Domain and Range:**\n- **Input:** A swarm configuration $S = ((x_1, v_1, s_1), \\ldots, (x_N, v_N, s_N)) \\in \\Sigma_N$ with at least one alive walker ($|\\mathcal{A}(S)| \\geq 1$).\n- **Output:** A probability measure over swarm configurations $S' \\in \\Sigma_N$ where all walkers have status $s'_i = 1$ (the intermediate, all-alive configuration).\n\n**Stochastic Structure:**\n\nThe operator is defined by a composition of deterministic and stochastic sub-operators (see {prf:ref}`thm-cloning-operator-composition` for the rigorous compositional representation):\n\n$$\n\\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}\n$$\n\nwhere each sub-operator is defined in the subsequent sections.\n\n**Key Property - All-Alive Output:**\n\nBy construction, the output configuration $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$ satisfies:\n\n$$\ns'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n$$",
    "raw_directive": "5806: We begin with the highest-level definition of the operator as a mathematical object.\n5807: \n5808: :::{prf:definition} The Cloning Operator $\\Psi_{\\text{clone}}$\n5809: :label: def-cloning-operator-formal\n5810: \n5811: The **cloning operator** $\\Psi_{\\text{clone}}$ is a Markov transition kernel on the swarm state space $\\Sigma_N$. For any input swarm configuration $S \\in \\Sigma_N$, it produces a probability measure $\\Psi_{\\text{clone}}(S, \\cdot)$ on $\\Sigma_N$.\n5812: \n5813: **Domain and Range:**\n5814: - **Input:** A swarm configuration $S = ((x_1, v_1, s_1), \\ldots, (x_N, v_N, s_N)) \\in \\Sigma_N$ with at least one alive walker ($|\\mathcal{A}(S)| \\geq 1$).\n5815: - **Output:** A probability measure over swarm configurations $S' \\in \\Sigma_N$ where all walkers have status $s'_i = 1$ (the intermediate, all-alive configuration).\n5816: \n5817: **Stochastic Structure:**\n5818: \n5819: The operator is defined by a composition of deterministic and stochastic sub-operators (see {prf:ref}`thm-cloning-operator-composition` for the rigorous compositional representation):\n5820: \n5821: $$\n5822: \\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}\n5823: $$\n5824: \n5825: where each sub-operator is defined in the subsequent sections.\n5826: \n5827: **Key Property - All-Alive Output:**\n5828: \n5829: By construction, the output configuration $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$ satisfies:\n5830: \n5831: $$\n5832: s'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n5833: $$\n5834: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input requires at least one alive walker",
        "latex": "$|\\mathcal{A}(S)| \\geq 1$"
      },
      {
        "type": null,
        "text": "Output configurations have all walkers alive",
        "latex": "$s'_i = 1$ for all $i \\in \\{1, \\ldots, N\\}$"
      },
      {
        "type": null,
        "text": "Operator composition",
        "latex": "$\\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}$"
      }
    ],
    "properties": [
      {
        "name": "Domain",
        "description": "Swarm configurations $S \\in \\Sigma_N$ with $|\\mathcal{A}(S)| \\geq 1$"
      },
      {
        "name": "Range",
        "description": "Probability measures on all-alive configurations in $\\Sigma_N$"
      },
      {
        "name": "Stochastic Structure",
        "description": "Composition of deterministic and stochastic sub-operators"
      },
      {
        "name": "All-Alive Output",
        "description": "By construction, all output walkers have status $s'_i = 1$"
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "construction",
        "text": "The operator ensures all output configurations are intermediate all-alive states."
      }
    ],
    "related_refs": [],
    "tags": [
      "cloning",
      "operator",
      "Markov",
      "kernel",
      "swarm",
      "stochastic",
      "transition",
      "probability"
    ],
    "document_id": "03_cloning",
    "section": "## 9.2. The Cloning Operator as a Markov Kernel",
    "span": {
      "start_line": 5806,
      "end_line": 5834,
      "content_start": 5809,
      "content_end": 5833,
      "header_lines": [
        5807
      ]
    },
    "references": [
      "thm-cloning-operator-composition"
    ],
    "metadata": {
      "label": "def-cloning-operator-formal"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 10,
      "chapter_file": "chapter_10.json",
      "section_id": "## 9.2. The Cloning Operator as a Markov Kernel"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-measurement-operator",
    "type": "definition",
    "title": "The Measurement Operator",
    "term": "measurement operator",
    "object_type": "operator",
    "nl_definition": "A stochastic operator that takes a swarm configuration S and outputs an N-dimensional raw distance vector d by sampling a spatially-aware pairing of alive agents and computing algorithmic distances along the pairing, setting distances to zero for dead agents.",
    "content_markdown": ":label: def-measurement-operator\n\nFor input swarm $S$ with alive set $\\mathcal{A}(S)$ of size $k = |\\mathcal{A}(S)|$:\n\n**Input:** Swarm configuration $S$\n\n**Stochastic Process:**\n\n1. **Companion Pairing:** Sample a pairing $\\pi: \\mathcal{A}(S) \\to \\mathcal{A}(S)$ from the spatially-aware random pairing distribution ({prf:ref}`def-standardization-operator`):\n\n\n$$\n\\pi \\sim P_{\\text{pair}}(S, \\cdot)\n$$\n\n2. **Raw Distance Vector** (see {prf:ref}`def-raw-value-operators`): For each alive walker $i \\in \\mathcal{A}(S)$, compute:\n\n\n$$\nd_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})\n$$\n\n\n   For dead walkers $i \\notin \\mathcal{A}(S)$, set $d_i = 0$ deterministically.\n\n**Output:** The $N$-dimensional raw distance vector $\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Key Properties:**\n- The pairing $\\pi$ is sampled once per swarm, creating correlations between measurements",
    "raw_directive": "5853: The first stage (as discussed in Section 5.3) generates the stochastic diversity measurements that form the foundation of the fitness evaluation.\n5854: \n5855: :::{prf:definition} The Measurement Operator\n5856: :label: def-measurement-operator\n5857: \n5858: For input swarm $S$ with alive set $\\mathcal{A}(S)$ of size $k = |\\mathcal{A}(S)|$:\n5859: \n5860: **Input:** Swarm configuration $S$\n5861: \n5862: **Stochastic Process:**\n5863: \n5864: 1. **Companion Pairing:** Sample a pairing $\\pi: \\mathcal{A}(S) \\to \\mathcal{A}(S)$ from the spatially-aware random pairing distribution ({prf:ref}`def-standardization-operator`):\n5865: \n5866: \n5867: $$\n5868: \\pi \\sim P_{\\text{pair}}(S, \\cdot)\n5869: $$\n5870: \n5871: 2. **Raw Distance Vector** (see {prf:ref}`def-raw-value-operators`): For each alive walker $i \\in \\mathcal{A}(S)$, compute:\n5872: \n5873: \n5874: $$\n5875: d_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})\n5876: $$\n5877: \n5878: \n5879:    For dead walkers $i \\notin \\mathcal{A}(S)$, set $d_i = 0$ deterministically.\n5880: \n5881: **Output:** The $N$-dimensional raw distance vector $\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}$\n5882: \n5883: **Key Properties:**\n5884: - The pairing $\\pi$ is sampled once per swarm, creating correlations between measurements\n5885: - The distribution of $\\mathbf{d}$ depends only on $S$ and the algorithmic parameters $(\\epsilon_p, \\ell_p)$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input: Swarm configuration S with alive set A(S) of size k = |A(S)|.",
        "latex": null
      },
      {
        "type": null,
        "text": "Sample a pairing \u03c0: A(S) \u2192 A(S) from the spatially-aware random pairing distribution.",
        "latex": "\\pi \\sim P_{\\text{pair}}(S, \\cdot)"
      },
      {
        "type": null,
        "text": "For each alive walker i \u2208 A(S), compute d_i = d_alg(x_i, x_\u03c0(i)).",
        "latex": "d_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})"
      },
      {
        "type": null,
        "text": "For dead walkers i \u2209 A(S), set d_i = 0 deterministically.",
        "latex": "d_i = 0"
      },
      {
        "type": null,
        "text": "Output: The N-dimensional raw distance vector d = (d_1, \u2026, d_N) \u2208 R^N_{\u22650}.",
        "latex": "\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}"
      }
    ],
    "properties": [
      {
        "name": "Correlated Measurements",
        "description": "The pairing \u03c0 is sampled once per swarm, creating correlations between measurements."
      },
      {
        "name": "Distribution Dependency",
        "description": "The distribution of d depends only on S and the algorithmic parameters (\u03b5_p, \u2113_p)."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm",
        "description": "Input swarm configuration with alive set A(S) of size k",
        "constraints": [],
        "tags": [
          "input"
        ]
      },
      {
        "symbol": "\\epsilon_p",
        "name": "epsilon_p",
        "description": "Algorithmic parameter for pairing distribution",
        "constraints": [],
        "tags": [
          "parameter"
        ]
      },
      {
        "symbol": "\\ell_p",
        "name": "ell_p",
        "description": "Algorithmic parameter for pairing distribution",
        "constraints": [],
        "tags": [
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [
      "def-standardization-operator"
    ],
    "tags": [
      "stochastic",
      "measurement",
      "operator",
      "pairing",
      "distance",
      "swarm",
      "diversity"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 5853,
      "end_line": 5885,
      "content_start": 5856,
      "content_end": 5884,
      "header_lines": [
        5854
      ]
    },
    "references": [
      "def-standardization-operator",
      "def-raw-value-operators"
    ],
    "metadata": {
      "label": "def-measurement-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-fitness-operator",
    "type": "definition",
    "title": "The Fitness Evaluation Operator",
    "term": "Fitness Evaluation Operator",
    "object_type": "operator",
    "nl_definition": "A deterministic operator that transforms a swarm configuration and raw distance vector into a fitness potential vector by computing boundary proximity rewards, applying rescaling and z-score normalization over alive walkers, and combining normalized components with dynamics weights.",
    "content_markdown": ":label: def-fitness-operator\n\n**Input:**\n- Swarm configuration $S$\n- Raw distance vector $\\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Deterministic Computation:**\n\n1. **Boundary Proximity:** For each walker $i$, compute:\n\n\n$$\nr_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i)\n$$\n\n   yielding the raw reward vector $\\mathbf{r} = (r_1, \\ldots, r_N)$.\n\n2. **Rescaling:** Apply the rescale function with floor $\\eta > 0$:\n\n\n$$\n\\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta\n$$\n\n3. **Z-Score Normalization:** Compute empirical means and standard deviations over **alive walkers only**:\n\n\n$$\n\\bar{d} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2}\n$$\n\n\n\n$$\n\\bar{r} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{r}_i, \\quad \\sigma_r = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{r}_i - \\bar{r})^2}\n$$\n\n\n   For alive walkers $i \\in \\mathcal{A}(S)$:\n\n\n$$\nz_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}}\n$$\n\n\n   For dead walkers, set $z_{d,i} = z_{r,i} = 0$.\n\n4. **Fitness Potential:** For each walker $i$, compute:\n\n   a. Apply the Rescale Function $g_A$ and add the floor $\\eta$ to create the rescaled components:\n      - $r'_i := g_A(z_{r,i}) + \\eta$\n      - $d'_i := g_A(z_{d,i}) + \\eta$\n\n   b. Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n\n\n$$\nV_{\\text{fit},i} = \\begin{cases}\n      (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & \\text{if } i \\in \\mathcal{A}(S) \\\\\n      0 & \\text{if } i \\notin \\mathcal{A}(S)\n      \\end{cases}\n$$\n\n**Output:** The fitness potential vector $\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Key Properties:**\n- The operator is deterministic given $S$ and $\\mathbf{d}$",
    "raw_directive": "5900: This deterministic operator (implementing the pipeline from Chapter 5) transforms raw measurements into fitness potentials.\n5901: \n5902: :::{prf:definition} The Fitness Evaluation Operator\n5903: :label: def-fitness-operator\n5904: \n5905: **Input:**\n5906: - Swarm configuration $S$\n5907: - Raw distance vector $\\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}$\n5908: \n5909: **Deterministic Computation:**\n5910: \n5911: 1. **Boundary Proximity:** For each walker $i$, compute:\n5912: \n5913: \n5914: $$\n5915: r_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i)\n5916: $$\n5917: \n5918:    yielding the raw reward vector $\\mathbf{r} = (r_1, \\ldots, r_N)$.\n5919: \n5920: 2. **Rescaling:** Apply the rescale function with floor $\\eta > 0$:\n5921: \n5922: \n5923: $$\n5924: \\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta\n5925: $$\n5926: \n5927: 3. **Z-Score Normalization:** Compute empirical means and standard deviations over **alive walkers only**:\n5928: \n5929: \n5930: $$\n5931: \\bar{d} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2}\n5932: $$\n5933: \n5934: \n5935: \n5936: $$\n5937: \\bar{r} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{r}_i, \\quad \\sigma_r = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{r}_i - \\bar{r})^2}\n5938: $$\n5939: \n5940: \n5941:    For alive walkers $i \\in \\mathcal{A}(S)$:\n5942: \n5943: \n5944: $$\n5945: z_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}}\n5946: $$\n5947: \n5948: \n5949:    For dead walkers, set $z_{d,i} = z_{r,i} = 0$.\n5950: \n5951: 4. **Fitness Potential:** For each walker $i$, compute:\n5952: \n5953:    a. Apply the Rescale Function $g_A$ and add the floor $\\eta$ to create the rescaled components:\n5954:       - $r'_i := g_A(z_{r,i}) + \\eta$\n5955:       - $d'_i := g_A(z_{d,i}) + \\eta$\n5956: \n5957:    b. Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n5958: \n5959: \n5960: $$\n5961: V_{\\text{fit},i} = \\begin{cases}\n5962:       (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & \\text{if } i \\in \\mathcal{A}(S) \\\\\n5963:       0 & \\text{if } i \\notin \\mathcal{A}(S)\n5964:       \\end{cases}\n5965: $$\n5966: \n5967: **Output:** The fitness potential vector $\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}$\n5968: \n5969: **Key Properties:**\n5970: - The operator is deterministic given $S$ and $\\mathbf{d}$\n5971: - Bounded: $V_{\\text{fit},i} \\in [0, V_{\\text{pot,max}}]$ for alive walkers, where $V_{\\text{pot,max}} = (g_{A,\\max} + \\eta)^{\\alpha+\\beta}$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input: Swarm configuration S and raw distance vector d \u2208 \u211d^N_{\u22650}",
        "latex": "S, \\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}"
      },
      {
        "type": null,
        "text": "Compute raw rewards r_i = g_A(x_i) = \u03c6_barrier(x_i) for each walker i, yielding r = (r_1, \u2026, r_N)",
        "latex": "r_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i), \\quad \\mathbf{r} = (r_1, \\ldots, r_N)"
      },
      {
        "type": null,
        "text": "Rescale: \\tilde{d}_i = d_i + \u03b7, \\tilde{r}_i = r_i + \u03b7",
        "latex": "\\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta"
      },
      {
        "type": null,
        "text": "Z-score over alive walkers i \u2208 A(S): means \\bar{d}, \\bar{r} and std devs \u03c3_d, \u03c3_r with k = |A(S)|",
        "latex": "\\bar{d} = \\frac{1}{k} \\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k} \\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2} \\quad (similarly for r)"
      },
      {
        "type": null,
        "text": "Z-scores for alive: z_{d,i} = (\\tilde{d}_i - \\bar{d}) / (\u03c3_d + \u03c3_stab), similarly for z_{r,i}; zero for dead",
        "latex": "z_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}} \\quad (i \\in \\mathcal{A}(S)); \\ 0 \\ otherwise"
      },
      {
        "type": null,
        "text": "Rescaled components: r'_i = g_A(z_{r,i}) + \u03b7, d'_i = g_A(z_{d,i}) + \u03b7",
        "latex": "r'_i := g_A(z_{r,i}) + \\eta, \\quad d'_i := g_A(z_{d,i}) + \\eta"
      },
      {
        "type": null,
        "text": "Fitness: V_{fit,i} = (d'_i)^\u03b2 \u00b7 (r'_i)^\u03b1 if alive, else 0",
        "latex": "V_{\\text{fit},i} = \\begin{cases} (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & i \\in \\mathcal{A}(S) \\\\ 0 & \\text{otherwise} \\end{cases}"
      },
      {
        "type": null,
        "text": "Output: V_{fit} = (V_{fit,1}, \u2026, V_{fit,N}) \u2208 \u211d^N_{\u22650}",
        "latex": "\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}"
      }
    ],
    "properties": [
      {
        "name": "Deterministic",
        "description": "The operator produces the same output given fixed inputs S and d"
      },
      {
        "name": "Bounded",
        "description": "For alive walkers, V_{fit,i} \u2208 [0, V_{pot,max}] where V_{pot,max} = (g_{A,max} + \u03b7)^{\u03b1+\u03b2}"
      },
      {
        "name": "Alive-Only Normalization",
        "description": "Empirical statistics computed exclusively over alive walkers A(S)"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm Configuration",
        "description": "Current state of the swarm including walker positions and alive status",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "d",
        "name": "Raw Distance Vector",
        "description": "Vector of non-negative raw distances for N walkers",
        "constraints": [
          "d \u2208 \u211d^N_{\u22650}"
        ],
        "tags": [
          "input",
          "distance"
        ]
      },
      {
        "symbol": "\u03b7",
        "name": "Floor Parameter",
        "description": "Positive additive floor for rescaling to avoid zero or negative values",
        "constraints": [
          "\u03b7 > 0"
        ],
        "tags": [
          "floor",
          "rescaling"
        ]
      },
      {
        "symbol": "\u03c3_stab",
        "name": "Stability Constant",
        "description": "Small positive constant added to standard deviations for numerical stability",
        "constraints": [
          "\u03c3_stab > 0"
        ],
        "tags": [
          "stability",
          "normalization"
        ]
      },
      {
        "symbol": "\u03b1",
        "name": "Reward Weight",
        "description": "Exponent weight for the rescaled reward component in fitness potential",
        "constraints": [],
        "tags": [
          "weight",
          "reward",
          "exponent"
        ]
      },
      {
        "symbol": "\u03b2",
        "name": "Distance Weight",
        "description": "Exponent weight for the rescaled distance component in fitness potential",
        "constraints": [],
        "tags": [
          "weight",
          "distance",
          "exponent"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "Dead walkers receive zero fitness potential, ensuring selection favors alive ones"
      },
      {
        "type": "dependency",
        "text": "Requires predefined functions g_A and \u03c6_barrier, as well as system parameters \u03b7, \u03c3_stab, \u03b1, \u03b2"
      }
    ],
    "related_refs": [],
    "tags": [
      "fitness-evaluation",
      "operator",
      "swarm",
      "deterministic",
      "z-score-normalization",
      "boundary-proximity",
      "rescaling"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 5900,
      "end_line": 5971,
      "content_start": 5903,
      "content_end": 5970,
      "header_lines": [
        5901
      ]
    },
    "references": [
      "lem-potential-bounds"
    ],
    "metadata": {
      "label": "def-fitness-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-decision-operator",
    "type": "definition",
    "title": "The Cloning Decision Operator",
    "term": "Cloning Decision Operator",
    "object_type": "stochastic operator",
    "nl_definition": "A stochastic process that assigns companions to walkers in a swarm based on their status and computes cloning scores from fitness differences, then decides cloning or persistence via threshold comparison, producing companion and action vectors.",
    "content_markdown": ":label: def-decision-operator\n\n**Input:**\n- Swarm configuration $S$\n- Fitness potential vector $\\mathbf{V}_{\\text{fit}}$\n\n**Stochastic Process:**\n\nFor each walker $i \\in \\{1, \\ldots, N\\}$:\n\n1. **Companion Selection** (see {prf:ref}`def-cloning-companion-operator`):\n\n   - If $i \\in \\mathcal{A}(S)$ (alive): Sample companion $c_i$ from the softmax distribution over other alive walkers:\n\n\n$$\nP(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}\n$$\n\n\n   - If $i \\in \\mathcal{D}(S)$ (dead): Sample companion uniformly from all alive walkers:\n\n\n$$\nP(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)\n$$\n\n2. **Cloning Score:** Compute the score based on fitness difference:\n\n\n$$\nS_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}\n$$\n\n3. **Stochastic Decision:** Sample threshold $T_i \\sim \\text{Uniform}(0, p_{\\max})$ independently.\n\n   Walker $i$ is marked for **cloning** if $S_i > T_i$, otherwise marked to **persist**.\n\n**Output:**\n- Companion assignment vector $\\mathbf{c} = (c_1, \\ldots, c_N)$\n- Binary action vector $\\mathbf{a} = (a_1, \\ldots, a_N)$ where $a_i \\in \\{\\text{clone}, \\text{persist}\\}$\n\n**Total Cloning Probability:**\n\nThe key quantity for drift analysis is the **total probability** that walker $i$ clones, averaging over all randomness in companion selection and threshold sampling:\n\n$$\np_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}})\n$$",
    "raw_directive": "5977: This stochastic operator (formalized from {prf:ref}`def-cloning-decision`) determines which walkers will clone and which will persist.\n5978: \n5979: :::{prf:definition} The Cloning Decision Operator\n5980: :label: def-decision-operator\n5981: \n5982: **Input:**\n5983: - Swarm configuration $S$\n5984: - Fitness potential vector $\\mathbf{V}_{\\text{fit}}$\n5985: \n5986: **Stochastic Process:**\n5987: \n5988: For each walker $i \\in \\{1, \\ldots, N\\}$:\n5989: \n5990: 1. **Companion Selection** (see {prf:ref}`def-cloning-companion-operator`):\n5991: \n5992:    - If $i \\in \\mathcal{A}(S)$ (alive): Sample companion $c_i$ from the softmax distribution over other alive walkers:\n5993: \n5994: \n5995: $$\n5996: P(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}\n5997: $$\n5998: \n5999: \n6000:    - If $i \\in \\mathcal{D}(S)$ (dead): Sample companion uniformly from all alive walkers:\n6001: \n6002: \n6003: $$\n6004: P(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)\n6005: $$\n6006: \n6007: 2. **Cloning Score:** Compute the score based on fitness difference:\n6008: \n6009: \n6010: $$\n6011: S_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}\n6012: $$\n6013: \n6014: 3. **Stochastic Decision:** Sample threshold $T_i \\sim \\text{Uniform}(0, p_{\\max})$ independently.\n6015: \n6016:    Walker $i$ is marked for **cloning** if $S_i > T_i$, otherwise marked to **persist**.\n6017: \n6018: **Output:**\n6019: - Companion assignment vector $\\mathbf{c} = (c_1, \\ldots, c_N)$\n6020: - Binary action vector $\\mathbf{a} = (a_1, \\ldots, a_N)$ where $a_i \\in \\{\\text{clone}, \\text{persist}\\}$\n6021: \n6022: **Total Cloning Probability:**\n6023: \n6024: The key quantity for drift analysis is the **total probability** that walker $i$ clones, averaging over all randomness in companion selection and threshold sampling:\n6025: \n6026: $$\n6027: p_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}})\n6028: $$\n6029: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "For alive walker i, companion c_i sampled from softmax over other alive walkers using algorithmic distances.",
        "latex": "P(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}"
      },
      {
        "type": null,
        "text": "For dead walker i, companion c_i sampled uniformly from alive walkers.",
        "latex": "P(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)"
      },
      {
        "type": null,
        "text": "Cloning score S_i computed as normalized fitness difference.",
        "latex": "S_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}"
      },
      {
        "type": null,
        "text": "Decision: Sample T_i ~ Uniform(0, p_max); clone if S_i > T_i, else persist.",
        "latex": "a_i = \\text{clone if } S_i > T_i, \\text{ else persist}"
      },
      {
        "type": null,
        "text": "Total cloning probability p_i averages over companion and threshold randomness.",
        "latex": "p_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}} )"
      }
    ],
    "properties": [
      {
        "name": "Input",
        "description": "Swarm configuration S and fitness potential vector V_fit"
      },
      {
        "name": "Output",
        "description": "Companion assignment vector c and binary action vector a indicating clone or persist for each walker"
      },
      {
        "name": "Stochastic Elements",
        "description": "Companion selection via softmax or uniform, and independent uniform threshold sampling for decisions"
      },
      {
        "name": "Key Quantity",
        "description": "Total cloning probability p_i for each walker, used in drift analysis"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm configuration",
        "description": "Current state of the swarm including positions and statuses of walkers",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "\\mathbf{V}_{\\text{fit}}",
        "name": "Fitness potential vector",
        "description": "Vector of fitness potentials V_fit,i for each walker i",
        "constraints": [],
        "tags": [
          "input",
          "fitness",
          "vector"
        ]
      },
      {
        "symbol": "\\epsilon_c",
        "name": "Companion selection scale",
        "description": "Scale parameter for the softmax distribution in companion selection",
        "constraints": [
          "\\epsilon_c > 0"
        ],
        "tags": [
          "hyperparameter",
          "scale",
          "companion"
        ]
      },
      {
        "symbol": "\\varepsilon_{\\text{clone}}",
        "name": "Cloning epsilon",
        "description": "Small positive constant to avoid division by zero in cloning score",
        "constraints": [
          "\\varepsilon_{\\text{clone}} > 0"
        ],
        "tags": [
          "hyperparameter",
          "regularization"
        ]
      },
      {
        "symbol": "p_{\\max}",
        "name": "Maximum cloning probability",
        "description": "Upper bound for the uniform threshold sampling",
        "constraints": [
          "0 < p_{\\max} \\leq 1"
        ],
        "tags": [
          "hyperparameter",
          "probability"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "note",
        "text": "The operator processes each walker independently but with shared randomness in companion selection probabilities."
      },
      {
        "type": "note",
        "text": "The total probability p_i is the expected cloning rate conditional on current swarm state and fitnesses, essential for analyzing population drift."
      }
    ],
    "related_refs": [],
    "tags": [
      "stochastic operator",
      "cloning decision",
      "swarm",
      "walker",
      "fitness potential",
      "companion selection",
      "cloning score",
      "drift analysis"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 5977,
      "end_line": 6029,
      "content_start": 5980,
      "content_end": 6028,
      "header_lines": [
        5978
      ]
    },
    "references": [
      "def-cloning-companion-operator",
      "lem-quantitative-keystone"
    ],
    "metadata": {
      "label": "def-decision-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-update-operator",
    "type": "definition",
    "title": "The State Update Operator",
    "term": "State Update Operator",
    "object_type": "operator",
    "nl_definition": "An operator that updates a swarm's positions, velocities, and statuses based on cloning and persistence actions, involving deterministic grouping of cloners, stochastic position jittering with Gaussian noise, momentum-conserving inelastic collisions for velocities without jitter, and setting all output statuses to alive.",
    "content_markdown": ":label: def-update-operator\n\nThe state update operator implements the inelastic collision model (see {prf:ref}`def-inelastic-collision-update`) to update walker states after cloning decisions.\n\n**Input:**\n- Swarm configuration $S$\n- Companion vector $\\mathbf{c}$\n- Action vector $\\mathbf{a}$\n\n**Deterministic Grouping:**\n\nFor each unique companion $j \\in \\mathcal{A}(S)$, identify all walkers cloning from it:\n\n$$\nI_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}\n$$\n\nLet $M_j = |I_j|$ be the number of cloners for companion $j$.\n\n**Stochastic State Update:**\n\nFor each $(M_j + 1)$-particle system consisting of companion $j$ and its cloners $I_j$:\n\n1. **Position Updates:**\n\n   For each cloner $i \\in I_j$, the position is reset to the companion's position plus **Gaussian jitter**:\n\n\n$$\nx'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\text{where } \\zeta_i^x \\sim \\mathcal{N}(0, I_d)\n$$\n\n\n   Companion position is unchanged: $x'_j = x_j$\n\n2. **Velocity Updates (The Inelastic Collision):**\n\n   The velocities are updated through a momentum-conserving inelastic collision model. **There is NO Gaussian jitter added to velocities.**\n\n   **a. Center-of-Mass Velocity:**\n\n\n$$\nV_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)\n$$\n\n\n   **b. Update Relative Velocities:**\n\n   For each walker $k \\in I_j \\cup \\{j\\}$, compute the relative velocity:\n\n\n$$\nu_k = v_k - V_{\\text{COM},j}\n$$\n\n\n   Sample a random orthogonal transformation $R_k$ that isotropically rotates $u_k$ (uniformly random direction on the $(d-1)$-sphere, preserving magnitude). The new relative velocity is:\n\n\n$$\nu'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n$$\n\n\n   **c. Return to Lab Frame:**\n\n\n$$\nv'_k = V_{\\text{COM},j} + u'_k\n$$\n\n3. **Persisting Walkers:**\n\n   For walkers with $a_i = \\text{persist}$:\n\n\n$$\nx'_i = x_i, \\quad v'_i = v_i\n$$\n\n4. **Status Update:**\n\n   All walkers in the output are alive:\n\n\n$$\ns'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n$$",
    "raw_directive": "6064: The final stage executes the cloning actions, producing the output swarm configuration.\n6065: \n6066: :::{prf:definition} The State Update Operator\n6067: :label: def-update-operator\n6068: \n6069: The state update operator implements the inelastic collision model (see {prf:ref}`def-inelastic-collision-update`) to update walker states after cloning decisions.\n6070: \n6071: **Input:**\n6072: - Swarm configuration $S$\n6073: - Companion vector $\\mathbf{c}$\n6074: - Action vector $\\mathbf{a}$\n6075: \n6076: **Deterministic Grouping:**\n6077: \n6078: For each unique companion $j \\in \\mathcal{A}(S)$, identify all walkers cloning from it:\n6079: \n6080: $$\n6081: I_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}\n6082: $$\n6083: \n6084: Let $M_j = |I_j|$ be the number of cloners for companion $j$.\n6085: \n6086: **Stochastic State Update:**\n6087: \n6088: For each $(M_j + 1)$-particle system consisting of companion $j$ and its cloners $I_j$:\n6089: \n6090: 1. **Position Updates:**\n6091: \n6092:    For each cloner $i \\in I_j$, the position is reset to the companion's position plus **Gaussian jitter**:\n6093: \n6094: \n6095: $$\n6096: x'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\text{where } \\zeta_i^x \\sim \\mathcal{N}(0, I_d)\n6097: $$\n6098: \n6099: \n6100:    Companion position is unchanged: $x'_j = x_j$\n6101: \n6102: 2. **Velocity Updates (The Inelastic Collision):**\n6103: \n6104:    The velocities are updated through a momentum-conserving inelastic collision model. **There is NO Gaussian jitter added to velocities.**\n6105: \n6106:    **a. Center-of-Mass Velocity:**\n6107: \n6108: \n6109: $$\n6110: V_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)\n6111: $$\n6112: \n6113: \n6114:    **b. Update Relative Velocities:**\n6115: \n6116:    For each walker $k \\in I_j \\cup \\{j\\}$, compute the relative velocity:\n6117: \n6118: \n6119: $$\n6120: u_k = v_k - V_{\\text{COM},j}\n6121: $$\n6122: \n6123: \n6124:    Sample a random orthogonal transformation $R_k$ that isotropically rotates $u_k$ (uniformly random direction on the $(d-1)$-sphere, preserving magnitude). The new relative velocity is:\n6125: \n6126: \n6127: $$\n6128: u'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n6129: $$\n6130: \n6131: \n6132:    **c. Return to Lab Frame:**\n6133: \n6134: \n6135: $$\n6136: v'_k = V_{\\text{COM},j} + u'_k\n6137: $$\n6138: \n6139: 3. **Persisting Walkers:**\n6140: \n6141:    For walkers with $a_i = \\text{persist}$:\n6142: \n6143: \n6144: $$\n6145: x'_i = x_i, \\quad v'_i = v_i\n6146: $$\n6147: \n6148: 4. **Status Update:**\n6149: \n6150:    All walkers in the output are alive:\n6151: \n6152: \n6153: $$\n6154: s'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n6155: $$\n6156: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Deterministic Grouping: For each unique companion j in \\mathcal{A}(S), identify cloners I_j = {i : a_i = clone and c_i = j}, with M_j = |I_j|.",
        "latex": "I_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}, \\quad M_j = |I_j|"
      },
      {
        "type": null,
        "text": "Position Updates for Cloners: For each i in I_j, x'_i = x_j + \\sigma_x \\zeta_i^x where \\zeta_i^x \\sim \\mathcal{N}(0, I_d); companion x'_j = x_j.",
        "latex": "x'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\zeta_i^x \\sim \\mathcal{N}(0, I_d), \\quad x'_j = x_j"
      },
      {
        "type": null,
        "text": "Velocity Updates - Center-of-Mass: V_{COM,j} = 1/(M_j + 1) (v_j + \\sum_{i \\in I_j} v_i).",
        "latex": "V_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)"
      },
      {
        "type": null,
        "text": "Velocity Updates - Relative Velocities: For k in I_j \\cup {j}, u_k = v_k - V_{COM,j}; u'_k = \\alpha_{restitution} \\cdot R_k(u_k) where R_k is random orthogonal transformation preserving magnitude.",
        "latex": "u_k = v_k - V_{\\text{COM},j}, \\quad u'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)"
      },
      {
        "type": null,
        "text": "Velocity Updates - Lab Frame: v'_k = V_{COM,j} + u'_k.",
        "latex": "v'_k = V_{\\text{COM},j} + u'_k"
      },
      {
        "type": null,
        "text": "Persisting Walkers: For a_i = persist, x'_i = x_i, v'_i = v_i.",
        "latex": "x'_i = x_i, \\quad v'_i = v_i"
      },
      {
        "type": null,
        "text": "Status Update: s'_i = 1 for all i in {1, ..., N}.",
        "latex": "s'_i = 1 \\quad \\forall i \\in \\{1, \\ldots, N\\}"
      }
    ],
    "properties": [
      {
        "name": "Deterministic Grouping",
        "description": "Groups cloners by unique companions before updates."
      },
      {
        "name": "Stochastic Position Jitter",
        "description": "Adds Gaussian noise to cloner positions relative to companion, with scale \\sigma_x."
      },
      {
        "name": "Inelastic Collision Model",
        "description": "Updates velocities via momentum conservation, restitution coefficient \\alpha_{restitution}, and random orthogonal rotations, without velocity jitter."
      },
      {
        "name": "Persistence",
        "description": "Unchanged positions and velocities for persisting walkers."
      },
      {
        "name": "Universal Alive Status",
        "description": "All output walkers are set to alive status."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm configuration",
        "description": "Current state of the swarm including positions x, velocities v, and statuses s for N walkers.",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "\\mathbf{c}",
        "name": "Companion vector",
        "description": "Vector assigning each walker i a companion j in \\mathcal{A}(S) for cloning actions.",
        "constraints": [],
        "tags": [
          "input",
          "companion"
        ]
      },
      {
        "symbol": "\\mathbf{a}",
        "name": "Action vector",
        "description": "Vector specifying actions for each walker i, such as 'clone' or 'persist'.",
        "constraints": [],
        "tags": [
          "input",
          "action"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "No Gaussian jitter is added to velocities; only positions receive jitter during cloning."
      },
      {
        "type": "parameter",
        "text": "Parameters like \\sigma_x (jitter scale) and \\alpha_{restitution} (restitution coefficient) are assumed defined elsewhere."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "update",
      "operator",
      "cloning",
      "inelastic collision",
      "gaussian jitter",
      "velocity update",
      "position reset"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 6064,
      "end_line": 6156,
      "content_start": 6067,
      "content_end": 6155,
      "header_lines": [
        6065
      ]
    },
    "references": [
      "def-inelastic-collision-update"
    ],
    "metadata": {
      "label": "def-update-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-key-operator-outputs",
    "type": "definition",
    "title": "Key Operator Outputs",
    "term": "Key Operator Outputs",
    "object_type": "quantities",
    "nl_definition": "Central quantities in the drift analysis for a swarm S and its output S' under the cloning operator \u03a8_clone, including cloning probabilities, position displacements, velocity perturbations, and centered displacements for coupled swarms.",
    "content_markdown": ":label: def-key-operator-outputs\n\nFor input swarm $S$ and output swarm $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$, the following quantities are central to the drift analysis:\n\n1. **Total Cloning Probability:** For each walker $i$:\n\n\n$$\np_i = P(\\text{walker } i \\text{ clones} \\mid S)\n$$\n\n2. **Position Displacement:** For each walker $i$:\n\n\n$$\n\\Delta x_i := x'_i - x_i\n$$\n\n   For cloners, $\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$.\n\n3. **Velocity Perturbation:** For each walker $i$ that participates in a cloning event:\n\n\n$$\n\\Delta v_i := v'_i - v_i\n$$\n\n   This arises from the inelastic collision model. The expected squared velocity change depends on:\n   - The center-of-mass shift: $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$\n   - The restitution coefficient: $\\alpha_{\\text{restitution}}$\n   - The random rotation: $R_i$\n\n4. **Centered Displacements:** For coupled swarms $(S_1, S_2)$:\n\n\n$$\n\\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}",
    "raw_directive": "6206: We conclude by highlighting the critical quantities (see {prf:ref}`def-key-operator-outputs`) that will be used in the subsequent drift analysis.\n6207: \n6208: :::{prf:definition} Key Operator Outputs\n6209: :label: def-key-operator-outputs\n6210: \n6211: For input swarm $S$ and output swarm $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$, the following quantities are central to the drift analysis:\n6212: \n6213: 1. **Total Cloning Probability:** For each walker $i$:\n6214: \n6215: \n6216: $$\n6217: p_i = P(\\text{walker } i \\text{ clones} \\mid S)\n6218: $$\n6219: \n6220: 2. **Position Displacement:** For each walker $i$:\n6221: \n6222: \n6223: $$\n6224: \\Delta x_i := x'_i - x_i\n6225: $$\n6226: \n6227:    For cloners, $\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$.\n6228: \n6229: 3. **Velocity Perturbation:** For each walker $i$ that participates in a cloning event:\n6230: \n6231: \n6232: $$\n6233: \\Delta v_i := v'_i - v_i\n6234: $$\n6235: \n6236:    This arises from the inelastic collision model. The expected squared velocity change depends on:\n6237:    - The center-of-mass shift: $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$\n6238:    - The restitution coefficient: $\\alpha_{\\text{restitution}}$\n6239:    - The random rotation: $R_i$\n6240: \n6241: 4. **Centered Displacements:** For coupled swarms $(S_1, S_2)$:\n6242: \n6243: \n6244: $$\n6245: \\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}\n6246: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Total Cloning Probability for each walker i",
        "latex": "$$p_i = P(\\text{walker } i \\text{ clones} \\mid S)$$"
      },
      {
        "type": null,
        "text": "Position Displacement for each walker i",
        "latex": "$$\\Delta x_i := x'_i - x_i$$ For cloners, $$\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$."
      },
      {
        "type": null,
        "text": "Velocity Perturbation for each walker i in cloning event",
        "latex": "$$\\Delta v_i := v'_i - v_i$$ Expected squared change depends on $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$, $\\alpha_{\\text{restitution}}$, and $R_i$."
      },
      {
        "type": null,
        "text": "Centered Displacements for coupled swarms (S_1, S_2)",
        "latex": "$$\\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}$$"
      }
    ],
    "properties": [
      {
        "name": "Dependence on Swarm State",
        "description": "All quantities depend on the input swarm S and its walker positions/velocities."
      },
      {
        "name": "Stochastic Elements",
        "description": "Incorporate random variables like \u03b6_i^x ~ N(0, I_d) and random rotations R_i."
      },
      {
        "name": "Coupling Relevance",
        "description": "Centered displacements apply specifically to paired swarms for comparative analysis."
      }
    ],
    "parameters": [
      {
        "symbol": "p_i",
        "name": "Total Cloning Probability",
        "description": "Probability that walker i clones given the input swarm S",
        "constraints": [],
        "tags": [
          "probability",
          "cloning"
        ]
      },
      {
        "symbol": "\u0394x_i",
        "name": "Position Displacement",
        "description": "Change in position for walker i, specifically for cloners \u0394x_i = x_{c_i} - x_i + \u03c3_x \u03b6_i^x where \u03b6_i^x ~ N(0, I_d)",
        "constraints": [
          "For cloners"
        ],
        "tags": [
          "displacement",
          "position"
        ]
      },
      {
        "symbol": "\u0394v_i",
        "name": "Velocity Perturbation",
        "description": "Change in velocity for walker i participating in cloning, from inelastic collision depending on center-of-mass shift, restitution coefficient \u03b1_restitution, and random rotation R_i",
        "constraints": [
          "For cloning participants"
        ],
        "tags": [
          "velocity",
          "perturbation",
          "collision"
        ]
      },
      {
        "symbol": "\u0394\u03b4_{x,i}",
        "name": "Centered Displacements",
        "description": "Difference in position displacements for coupled swarms (S_1, S_2): \u03b4_{x,1,i} - \u03b4_{x,2,i}",
        "constraints": [],
        "tags": [
          "coupled",
          "displacement",
          "centered"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "These quantities are used in subsequent drift analysis for swarm evolution under cloning."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "cloning",
      "drift analysis",
      "probability",
      "displacement",
      "velocity perturbation",
      "coupled swarms"
    ],
    "document_id": "03_cloning",
    "section": "## 9.5. Key Quantities for Drift Analysis",
    "span": {
      "start_line": 6206,
      "end_line": 6246,
      "content_start": 6209,
      "content_end": 6245,
      "header_lines": [
        6207
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-key-operator-outputs"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 13,
      "chapter_file": "chapter_13.json",
      "section_id": "## 9.5. Key Quantities for Drift Analysis"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-coupled-cloning-expectation",
    "type": "definition",
    "title": "Coupled Cloning Expectation",
    "term": "Coupled Cloning Expectation",
    "object_type": "expectation operator",
    "nl_definition": "The expected value of a function f applied to the output swarms (S'_1, S'_2) obtained by independently applying the cloning operation \u03a8_clone to input swarms (S_1, S_2), where all sources of randomness in the cloning processes are synchronously coupled.",
    "content_markdown": ":label: def-coupled-cloning-expectation\n\nConsider two swarms $(S_1, S_2)$ in the coupled state space (see {prf:ref}`def-coupled-state-space`). Let $(S'_1, S'_2)$ be the output swarms after applying $\\Psi_{\\text{clone}}$ to each independently, using **synchronous coupling** of all randomness:\n\n- Same PRNG seeds for companion selection\n- Same pairing algorithm random choices\n- Same threshold samples $T_i$ for each walker index $i$\n- Same Gaussian jitters $\\zeta_i^x$ for position updates (when both walkers clone)\n- Same rotation operators $R_i$ for velocity collisions (when both walkers participate in collisions)\n\nFor any function $f: \\Sigma_N \\times \\Sigma_N \\to \\mathbb{R}$, the **coupled cloning expectation** is:\n\n$$\n\\mathbb{E}_{\\text{clone}}[f(S'_1, S'_2) \\mid S_1, S_2] := \\mathbb{E}[f(S'_1, S'_2) \\mid S_1, S_2, \\text{coupling}]",
    "raw_directive": "6326: To analyze the drift of the Lyapunov function components, we work with two copies of the swarm evolving under synchronous coupling.\n6327: \n6328: :::{prf:definition} Coupled Cloning Expectation\n6329: :label: def-coupled-cloning-expectation\n6330: \n6331: Consider two swarms $(S_1, S_2)$ in the coupled state space (see {prf:ref}`def-coupled-state-space`). Let $(S'_1, S'_2)$ be the output swarms after applying $\\Psi_{\\text{clone}}$ to each independently, using **synchronous coupling** of all randomness:\n6332: \n6333: - Same PRNG seeds for companion selection\n6334: - Same pairing algorithm random choices\n6335: - Same threshold samples $T_i$ for each walker index $i$\n6336: - Same Gaussian jitters $\\zeta_i^x$ for position updates (when both walkers clone)\n6337: - Same rotation operators $R_i$ for velocity collisions (when both walkers participate in collisions)\n6338: \n6339: For any function $f: \\Sigma_N \\times \\Sigma_N \\to \\mathbb{R}$, the **coupled cloning expectation** is:\n6340: \n6341: $$\n6342: \\mathbb{E}_{\\text{clone}}[f(S'_1, S'_2) \\mid S_1, S_2] := \\mathbb{E}[f(S'_1, S'_2) \\mid S_1, S_2, \\text{coupling}]\n6343: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Same PRNG seeds for companion selection",
        "latex": null
      },
      {
        "type": null,
        "text": "Same pairing algorithm random choices",
        "latex": null
      },
      {
        "type": null,
        "text": "Same threshold samples T_i for each walker index i",
        "latex": null
      },
      {
        "type": null,
        "text": "Same Gaussian jitters \u03b6_i^x for position updates (when both walkers clone)",
        "latex": null
      },
      {
        "type": null,
        "text": "Same rotation operators R_i for velocity collisions (when both walkers participate in collisions)",
        "latex": null
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "S_1",
        "name": "first swarm",
        "description": "A swarm in the coupled state space.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "S_2",
        "name": "second swarm",
        "description": "A swarm in the coupled state space.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "f",
        "name": "test function",
        "description": "A function f: \u03a3_N \u00d7 \u03a3_N \u2192 \u211d.",
        "constraints": [],
        "tags": [
          "function",
          "test"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "coupled",
      "cloning",
      "expectation",
      "synchronous",
      "swarm",
      "randomness",
      "PRNG"
    ],
    "document_id": "03_cloning",
    "section": "## 10.2. The Coupled Expectation Framework",
    "span": {
      "start_line": 6326,
      "end_line": 6343,
      "content_start": 6329,
      "content_end": 6342,
      "header_lines": [
        6327
      ]
    },
    "references": [
      "def-coupled-state-space"
    ],
    "metadata": {
      "label": "def-coupled-cloning-expectation"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 16,
      "chapter_file": "chapter_16.json",
      "section_id": "## 10.2. The Coupled Expectation Framework"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-boundary-potential-recall",
    "type": "definition",
    "title": "Boundary Potential Component (Recall)",
    "term": "boundary potential",
    "object_type": "function",
    "nl_definition": "The boundary potential is the average value of a smooth barrier function applied to the states of agents in two swarms, promoting safety by penalizing proximity to the boundary of the valid state space.",
    "content_markdown": ":label: def-boundary-potential-recall\n\nFrom {prf:ref}`def-full-synergistic-lyapunov-function`, the boundary potential is:\n\n$$\nW_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n$$\n\nwhere $\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}$ is the smooth barrier function satisfying:\n\n1. **Interior safety:** $\\varphi_{\\text{barrier}}(x) = 0$ for $x$ in the safe interior region (distance $> \\delta_{\\text{safe}}$ from boundary)\n\n2. **Boundary growth:** $\\varphi_{\\text{barrier}}(x) \\to \\infty$ as $x \\to \\partial \\mathcal{X}_{\\text{valid}}$\n\n3. **Smoothness:** $\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}})$ with bounded derivatives in the interior",
    "raw_directive": "7051: ### 11.2.1. The Barrier Function\n7052: \n7053: :::{prf:definition} Boundary Potential Component (Recall)\n7054: :label: def-boundary-potential-recall\n7055: \n7056: From {prf:ref}`def-full-synergistic-lyapunov-function`, the boundary potential is:\n7057: \n7058: $$\n7059: W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n7060: $$\n7061: \n7062: where $\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}$ is the smooth barrier function satisfying:\n7063: \n7064: 1. **Interior safety:** $\\varphi_{\\text{barrier}}(x) = 0$ for $x$ in the safe interior region (distance $> \\delta_{\\text{safe}}$ from boundary)\n7065: \n7066: 2. **Boundary growth:** $\\varphi_{\\text{barrier}}(x) \\to \\infty$ as $x \\to \\partial \\mathcal{X}_{\\text{valid}}$\n7067: \n7068: 3. **Smoothness:** $\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}})$ with bounded derivatives in the interior\n7069: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Interior safety: \\varphi_{\\text{barrier}}(x) = 0 for x in the safe interior region (distance > \\delta_{\\text{safe}} from boundary)",
        "latex": "\\varphi_{\\text{barrier}}(x) = 0 \\ \\forall x \\in \\text{interior (dist}(x, \\partial \\mathcal{X}_{\\text{valid}}) > \\delta_{\\text{safe}})"
      },
      {
        "type": null,
        "text": "Boundary growth: \\varphi_{\\text{barrier}}(x) \\to \\infty as x \\to \\partial \\mathcal{X}_{\\text{valid}}",
        "latex": "\\varphi_{\\text{barrier}}(x) \\to \\infty \\ \\text{as} \\ x \\to \\partial \\mathcal{X}_{\\text{valid}}"
      },
      {
        "type": null,
        "text": "Smoothness: \\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}}) with bounded derivatives in the interior",
        "latex": "\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}}), \\ \\text{bounded derivatives in interior}"
      }
    ],
    "properties": [
      {
        "name": "Non-negativity",
        "description": "W_b(S_1, S_2) \\geq 0 due to \\varphi_{\\text{barrier}} \\geq 0"
      },
      {
        "name": "Averaged sum",
        "description": "Computed as average over agents in each swarm"
      },
      {
        "name": "Recall definition",
        "description": "Component of the full synergistic Lyapunov function"
      }
    ],
    "parameters": [
      {
        "symbol": "S_1",
        "name": "S_1",
        "description": "State of the first swarm",
        "constraints": [],
        "tags": [
          "swarm-state"
        ]
      },
      {
        "symbol": "S_2",
        "name": "S_2",
        "description": "State of the second swarm",
        "constraints": [],
        "tags": [
          "swarm-state"
        ]
      },
      {
        "symbol": "N",
        "name": "N",
        "description": "Number of agents in each swarm",
        "constraints": [
          "N > 0",
          "integer"
        ],
        "tags": [
          "agent-count"
        ]
      },
      {
        "symbol": "\\varphi_{\\text{barrier}}",
        "name": "varphi_barrier",
        "description": "Smooth barrier function mapping valid states to non-negative reals",
        "constraints": [
          "\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}"
        ],
        "tags": [
          "barrier",
          "smooth"
        ]
      },
      {
        "symbol": "\\mathcal{A}(S_1)",
        "name": "A(S_1)",
        "description": "Set of agent indices in swarm S_1",
        "constraints": [],
        "tags": [
          "agent-set"
        ]
      },
      {
        "symbol": "x_{1,i}",
        "name": "x_{1,i}",
        "description": "State of the i-th agent in S_1",
        "constraints": [
          "i \\in \\mathcal{A}(S_1)"
        ],
        "tags": [
          "agent-state"
        ]
      },
      {
        "symbol": "x_{2,i}",
        "name": "x_{2,i}",
        "description": "State of the i-th agent in S_2",
        "constraints": [
          "i \\in \\mathcal{A}(S_2)"
        ],
        "tags": [
          "agent-state"
        ]
      },
      {
        "symbol": "\\delta_{\\text{safe}}",
        "name": "delta_safe",
        "description": "Safety distance threshold from boundary",
        "constraints": [
          "\\delta_{\\text{safe}} > 0"
        ],
        "tags": [
          "safety-threshold"
        ]
      },
      {
        "symbol": "\\mathcal{X}_{\\text{valid}}",
        "name": "X_valid",
        "description": "Valid state space",
        "constraints": [],
        "tags": [
          "state-space"
        ]
      },
      {
        "symbol": "\\partial \\mathcal{X}_{\\text{valid}}",
        "name": "partial X_valid",
        "description": "Boundary of the valid state space",
        "constraints": [],
        "tags": [
          "boundary"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "recall",
        "text": "This definition is recalled from the full synergistic Lyapunov function for context in the barrier analysis."
      }
    ],
    "related_refs": [
      "def-full-synergistic-lyapunov-function"
    ],
    "tags": [
      "boundary-potential",
      "barrier-function",
      "safety",
      "lyapunov-component",
      "multi-agent",
      "swarm",
      "smoothness"
    ],
    "document_id": "03_cloning",
    "section": "## 11.2. The Boundary Barrier and Fitness Gradient",
    "span": {
      "start_line": 7051,
      "end_line": 7069,
      "content_start": 7054,
      "content_end": 7068,
      "header_lines": [
        7052
      ]
    },
    "references": [
      "def-full-synergistic-lyapunov-function",
      "prop-barrier-existence"
    ],
    "metadata": {
      "label": "def-boundary-potential-recall"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 23,
      "chapter_file": "chapter_23.json",
      "section_id": "## 11.2. The Boundary Barrier and Fitness Gradient"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  },
  {
    "label": "def-boundary-exposed-set",
    "type": "definition",
    "title": "The Boundary-Exposed Set",
    "term": "boundary-exposed set",
    "object_type": "set",
    "nl_definition": "The boundary-exposed set of a swarm is the collection of its alive walkers whose barrier penalty exceeds a specified positive threshold, signaling dangerous proximity to the boundary; associated is the boundary-exposed mass, averaging these penalties normalized by the total number of walkers.",
    "content_markdown": ":label: def-boundary-exposed-set\n\nFor a swarm $S$ and a threshold $\\phi_{\\text{thresh}} > 0$, the **boundary-exposed set** is:\n\n$$\n\\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}\n$$\n\nThese are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary.\n\nThe **boundary-exposed mass** is:\n\n$$\nM_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)",
    "raw_directive": "7259: We now formalize the set of walkers (see {prf:ref}`def-boundary-exposed-set`) that are in danger due to boundary proximity.\n7260: \n7261: :::{prf:definition} The Boundary-Exposed Set\n7262: :label: def-boundary-exposed-set\n7263: \n7264: For a swarm $S$ and a threshold $\\phi_{\\text{thresh}} > 0$, the **boundary-exposed set** is:\n7265: \n7266: $$\n7267: \\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}\n7268: $$\n7269: \n7270: These are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary.\n7271: \n7272: The **boundary-exposed mass** is:\n7273: \n7274: $$\n7275: M_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)\n7276: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "The boundary-exposed set",
        "latex": "\\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}"
      },
      {
        "type": null,
        "text": "The boundary-exposed mass",
        "latex": "M_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)"
      }
    ],
    "properties": [
      {
        "name": "membership condition",
        "description": "An index i belongs to the set if it is an alive walker and its barrier penalty \u03c6_barrier(x_i) > \u03c6_thresh"
      },
      {
        "name": "mass computation",
        "description": "Average barrier penalty over exposed walkers, normalized by total walker count N"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm",
        "description": "The swarm of walkers",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "\\phi_{\\text{thresh}}",
        "name": "threshold",
        "description": "Positive threshold for barrier penalty",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "threshold",
          "positive"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "These are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary."
      }
    ],
    "related_refs": [],
    "tags": [
      "boundary",
      "exposed",
      "set",
      "swarm",
      "walkers",
      "proximity",
      "threshold",
      "barrier",
      "mass"
    ],
    "document_id": "03_cloning",
    "section": "## 11.2. The Boundary Barrier and Fitness Gradient",
    "span": {
      "start_line": 7259,
      "end_line": 7276,
      "content_start": 7262,
      "content_end": 7275,
      "header_lines": [
        7260
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-boundary-exposed-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 23,
      "chapter_file": "chapter_23.json",
      "section_id": "## 11.2. The Boundary Barrier and Fitness Gradient"
    },
    "generated_at": "2025-11-10T12:23:04.013511+00:00",
    "alt_labels": []
  }
]