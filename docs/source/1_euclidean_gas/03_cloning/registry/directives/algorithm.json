{
  "document_id": "03_cloning",
  "stage": "directives",
  "directive_type": "algorithm",
  "generated_at": "2025-11-08T17:07:43.186057+00:00",
  "count": 1,
  "items": [
    {
      "directive_type": "algorithm",
      "label": "alg-greedy-pairing",
      "title": "Sequential Stochastic Greedy Pairing Algorithm",
      "start_line": 1461,
      "end_line": 1500,
      "header_lines": [
        1462
      ],
      "content_start": 1464,
      "content_end": 1499,
      "content": "1464: :label: alg-greedy-pairing\n1465: \n1466: ALGORITHM: GreedyPairing(alive_walkers, epsilon_d)\n1467: -------------------------------------------------\n1468: INPUT:\n1469:   alive_walkers: A list of k walker objects.\n1470:   epsilon_d: The interaction range for diversity.\n1471: OUTPUT:\n1472:   companion_map: A dictionary representing the pairing.\n1473: \n1474: 1.  unpaired_set ← a set containing all walkers from alive_walkers\n1475: 2.  companion_map ← an empty dictionary\n1476: \n1477: 3.  WHILE len(unpaired_set) > 1:\n1478: 4.      i ← unpaired_set.pop()  // Select and remove a walker\n1479: \n1480: 5.      // Prepare to compute the probability distribution\n1481: 6.      companions ← list(unpaired_set)\n1482: 7.      weights ← empty list of floats\n1483: 8.\n1484: 9.      FOR j IN companions:\n1485: 10.         dist_sq = algorithmic_distance(i.state, j.state)^2\n1486: 11.         weight = exp(-dist_sq / (2 * epsilon_d^2))\n1487: 12.         weights.append(weight)\n1488: \n1489: 13.     // Normalize weights to get probabilities\n1490: 14.     total_weight = sum(weights)\n1491: 15.     probabilities = [w / total_weight for w in weights]\n1492: \n1493: 16.     // Sample the companion based on the probabilities\n1494: 17.     c_i ← sample_from(companions, probabilities)\n1495: \n1496: 18.     // Finalize the pair\n1497: 19.     unpaired_set.remove(c_i)\n1498: 20.     companion_map[i] ← c_i\n1499: 21.     companion_map[c_i] ← i",
      "metadata": {
        "label": "alg-greedy-pairing"
      },
      "section": "## 5. The Measurement and Interaction Pipeline",
      "raw_directive": "1461: The following pseudocode provides a concrete implementation of this operator.\n1462: \n1463: :::{prf:algorithm} Sequential Stochastic Greedy Pairing Algorithm\n1464: :label: alg-greedy-pairing\n1465: \n1466: ALGORITHM: GreedyPairing(alive_walkers, epsilon_d)\n1467: -------------------------------------------------\n1468: INPUT:\n1469:   alive_walkers: A list of k walker objects.\n1470:   epsilon_d: The interaction range for diversity.\n1471: OUTPUT:\n1472:   companion_map: A dictionary representing the pairing.\n1473: \n1474: 1.  unpaired_set ← a set containing all walkers from alive_walkers\n1475: 2.  companion_map ← an empty dictionary\n1476: \n1477: 3.  WHILE len(unpaired_set) > 1:\n1478: 4.      i ← unpaired_set.pop()  // Select and remove a walker\n1479: \n1480: 5.      // Prepare to compute the probability distribution\n1481: 6.      companions ← list(unpaired_set)\n1482: 7.      weights ← empty list of floats\n1483: 8.\n1484: 9.      FOR j IN companions:\n1485: 10.         dist_sq = algorithmic_distance(i.state, j.state)^2\n1486: 11.         weight = exp(-dist_sq / (2 * epsilon_d^2))\n1487: 12.         weights.append(weight)\n1488: \n1489: 13.     // Normalize weights to get probabilities\n1490: 14.     total_weight = sum(weights)\n1491: 15.     probabilities = [w / total_weight for w in weights]\n1492: \n1493: 16.     // Sample the companion based on the probabilities\n1494: 17.     c_i ← sample_from(companions, probabilities)\n1495: \n1496: 18.     // Finalize the pair\n1497: 19.     unpaired_set.remove(c_i)\n1498: 20.     companion_map[i] ← c_i\n1499: 21.     companion_map[c_i] ← i\n1500: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "03_cloning",
        "chapter_index": 5,
        "chapter_file": "chapter_5.json",
        "section_id": "## 5. The Measurement and Interaction Pipeline"
      }
    }
  ]
}