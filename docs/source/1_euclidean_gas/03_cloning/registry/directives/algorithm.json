{
  "document_id": "03_cloning",
  "stage": "directives",
  "directive_type": "algorithm",
  "generated_at": "2025-11-12T22:37:33.901174+00:00",
  "count": 1,
  "items": [
    {
      "directive_type": "algorithm",
      "label": "alg-greedy-pairing",
      "title": "Sequential Stochastic Greedy Pairing Algorithm",
      "start_line": 1481,
      "end_line": 1520,
      "header_lines": [
        1482
      ],
      "content_start": 1484,
      "content_end": 1519,
      "content": "1484: :label: alg-greedy-pairing\n1485: \n1486: ALGORITHM: GreedyPairing(alive_walkers, epsilon_d)\n1487: -------------------------------------------------\n1488: INPUT:\n1489:   alive_walkers: A list of k walker ({prf:ref}`def-walker`) objects.\n1490:   epsilon_d: The interaction range for diversity.\n1491: OUTPUT:\n1492:   companion_map: A dictionary representing the pairing.\n1493: \n1494: 1.  unpaired_set ← a set containing all walkers from alive_walkers\n1495: 2.  companion_map ← an empty dictionary\n1496: \n1497: 3.  WHILE len(unpaired_set) > 1:\n1498: 4.      i ← unpaired_set.pop()  // Select and remove a walker ({prf:ref}`def-walker`)\n1499: \n1500: 5.      // Prepare to compute the probability distribution\n1501: 6.      companions ← list(unpaired_set)\n1502: 7.      weights ← empty list of floats\n1503: 8.\n1504: 9.      FOR j IN companions:\n1505: 10.         dist_sq = algorithmic_distance(i.state, j.state)^2\n1506: 11.         weight = exp(-dist_sq / (2 * epsilon_d^2))\n1507: 12.         weights.append(weight)\n1508: \n1509: 13.     // Normalize weights to get probabilities\n1510: 14.     total_weight = sum(weights)\n1511: 15.     probabilities = [w / total_weight for w in weights]\n1512: \n1513: 16.     // Sample the companion based on the probabilities\n1514: 17.     c_i ← sample_from(companions, probabilities)\n1515: \n1516: 18.     // Finalize the pair\n1517: 19.     unpaired_set.remove(c_i)\n1518: 20.     companion_map[i] ← c_i\n1519: 21.     companion_map[c_i] ← i",
      "metadata": {
        "label": "alg-greedy-pairing"
      },
      "section": "## 5. The Measurement and Interaction Pipeline",
      "references": [
        "def-walker"
      ],
      "raw_directive": "1481: The following pseudocode provides a concrete implementation of this operator.\n1482: \n1483: :::{prf:algorithm} Sequential Stochastic Greedy Pairing Algorithm\n1484: :label: alg-greedy-pairing\n1485: \n1486: ALGORITHM: GreedyPairing(alive_walkers, epsilon_d)\n1487: -------------------------------------------------\n1488: INPUT:\n1489:   alive_walkers: A list of k walker ({prf:ref}`def-walker`) objects.\n1490:   epsilon_d: The interaction range for diversity.\n1491: OUTPUT:\n1492:   companion_map: A dictionary representing the pairing.\n1493: \n1494: 1.  unpaired_set ← a set containing all walkers from alive_walkers\n1495: 2.  companion_map ← an empty dictionary\n1496: \n1497: 3.  WHILE len(unpaired_set) > 1:\n1498: 4.      i ← unpaired_set.pop()  // Select and remove a walker ({prf:ref}`def-walker`)\n1499: \n1500: 5.      // Prepare to compute the probability distribution\n1501: 6.      companions ← list(unpaired_set)\n1502: 7.      weights ← empty list of floats\n1503: 8.\n1504: 9.      FOR j IN companions:\n1505: 10.         dist_sq = algorithmic_distance(i.state, j.state)^2\n1506: 11.         weight = exp(-dist_sq / (2 * epsilon_d^2))\n1507: 12.         weights.append(weight)\n1508: \n1509: 13.     // Normalize weights to get probabilities\n1510: 14.     total_weight = sum(weights)\n1511: 15.     probabilities = [w / total_weight for w in weights]\n1512: \n1513: 16.     // Sample the companion based on the probabilities\n1514: 17.     c_i ← sample_from(companions, probabilities)\n1515: \n1516: 18.     // Finalize the pair\n1517: 19.     unpaired_set.remove(c_i)\n1518: 20.     companion_map[i] ← c_i\n1519: 21.     companion_map[c_i] ← i\n1520: ",
      "_registry_context": {
        "stage": "directives",
        "document_id": "03_cloning",
        "chapter_index": 5,
        "chapter_file": "chapter_5.json",
        "section_id": "## 5. The Measurement and Interaction Pipeline"
      }
    }
  ]
}