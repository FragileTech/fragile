{
  "chapter_index": 6,
  "section_id": "## 6. Spectral Analysis of Parameter Coupling",
  "directive_count": 18,
  "hints": [
    {
      "directive_type": "definition",
      "label": "def-complete-parameter-space",
      "title": "Complete Parameter Space",
      "start_line": 2205,
      "end_line": 2238,
      "header_lines": [
        2206
      ],
      "content_start": 2208,
      "content_end": 2237,
      "content": "2208: :label: def-complete-parameter-space\n2209: \n2210: The Euclidean Gas algorithm is controlled by the parameter vector:\n2211: \n2212: $$\n2213: \\mathbf{P} = (\\lambda, \\sigma_x, \\alpha_{\\text{rest}}, \\lambda_{\\text{alg}}, \\epsilon_c, \\epsilon_d, \\gamma, \\sigma_v, \\tau, N, \\kappa_{\\text{wall}}, d_{\\text{safe}}) \\in \\mathbb{R}_{+}^{12}\n2214: $$\n2215: \n2216: where:\n2217: \n2218: **Cloning Operator Parameters:**\n2219: 1. $\\lambda \\in (0, 1]$ - **Cloning rate**: frequency of resampling events\n2220: 2. $\\sigma_x > 0$ - **Position jitter**: Gaussian noise variance added to cloned positions $x'_i = x_{c_i} + \\sigma_x \\zeta_i^x$\n2221: 3. $\\alpha_{\\text{rest}} \\in [0, 1]$ - **Restitution coefficient**: interpolates between perfectly inelastic ($\\alpha=0$) and perfectly elastic ($\\alpha=1$) velocity collisions\n2222: 4. $\\lambda_{\\text{alg}} \\geq 0$ - **Algorithmic distance weight**: controls velocity component in companion selection metric $d_{\\text{alg}}(i,j)^2 = \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$\n2223: 5. $\\epsilon_c > 0$ - **Companion selection range**: softmax temperature for cloning companion pairing\n2224: 6. $\\epsilon_d > 0$ - **Diversity measurement range**: softmax temperature for diversity companion pairing\n2225: \n2226: **Langevin Dynamics Parameters:**\n2227: 7. $\\gamma > 0$ - **Friction coefficient**: velocity damping rate in Langevin equation\n2228: 8. $\\sigma_v > 0$ - **Velocity noise intensity**: thermal fluctuation strength\n2229: 9. $\\tau > 0$ - **Integration timestep**: BAOAB discretization parameter\n2230: \n2231: **System Parameters:**\n2232: 10. $N \\in \\mathbb{N}$ - **Swarm size**: number of walkers\n2233: 11. $\\kappa_{\\text{wall}} > 0$ - **Boundary potential stiffness**: confining force strength\n2234: 12. $d_{\\text{safe}} > 0$ - **Safe Harbor distance**: threshold for boundary danger zone\n2235: \n2236: **Landscape Parameters (given, not tunable):**\n2237: - $\\lambda_{\\min} > 0$ - minimum eigenvalue of Hessian $\\nabla^2 U(x)$",
      "metadata": {
        "label": "def-complete-parameter-space"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2205: From the analysis in Chapter 7 and the cloning operator specification in 03_cloning.md, the **complete tunable parameter space** consists of:\n2206: \n2207: :::{prf:definition} Complete Parameter Space\n2208: :label: def-complete-parameter-space\n2209: \n2210: The Euclidean Gas algorithm is controlled by the parameter vector:\n2211: \n2212: $$\n2213: \\mathbf{P} = (\\lambda, \\sigma_x, \\alpha_{\\text{rest}}, \\lambda_{\\text{alg}}, \\epsilon_c, \\epsilon_d, \\gamma, \\sigma_v, \\tau, N, \\kappa_{\\text{wall}}, d_{\\text{safe}}) \\in \\mathbb{R}_{+}^{12}\n2214: $$\n2215: \n2216: where:\n2217: \n2218: **Cloning Operator Parameters:**\n2219: 1. $\\lambda \\in (0, 1]$ - **Cloning rate**: frequency of resampling events\n2220: 2. $\\sigma_x > 0$ - **Position jitter**: Gaussian noise variance added to cloned positions $x'_i = x_{c_i} + \\sigma_x \\zeta_i^x$\n2221: 3. $\\alpha_{\\text{rest}} \\in [0, 1]$ - **Restitution coefficient**: interpolates between perfectly inelastic ($\\alpha=0$) and perfectly elastic ($\\alpha=1$) velocity collisions\n2222: 4. $\\lambda_{\\text{alg}} \\geq 0$ - **Algorithmic distance weight**: controls velocity component in companion selection metric $d_{\\text{alg}}(i,j)^2 = \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$\n2223: 5. $\\epsilon_c > 0$ - **Companion selection range**: softmax temperature for cloning companion pairing\n2224: 6. $\\epsilon_d > 0$ - **Diversity measurement range**: softmax temperature for diversity companion pairing\n2225: \n2226: **Langevin Dynamics Parameters:**\n2227: 7. $\\gamma > 0$ - **Friction coefficient**: velocity damping rate in Langevin equation\n2228: 8. $\\sigma_v > 0$ - **Velocity noise intensity**: thermal fluctuation strength\n2229: 9. $\\tau > 0$ - **Integration timestep**: BAOAB discretization parameter\n2230: \n2231: **System Parameters:**\n2232: 10. $N \\in \\mathbb{N}$ - **Swarm size**: number of walkers\n2233: 11. $\\kappa_{\\text{wall}} > 0$ - **Boundary potential stiffness**: confining force strength\n2234: 12. $d_{\\text{safe}} > 0$ - **Safe Harbor distance**: threshold for boundary danger zone\n2235: \n2236: **Landscape Parameters (given, not tunable):**\n2237: - $\\lambda_{\\min} > 0$ - minimum eigenvalue of Hessian $\\nabla^2 U(x)$\n2238: - $\\lambda_{\\max} > 0$ - maximum eigenvalue of Hessian $\\nabla^2 U(x)$"
    },
    {
      "directive_type": "proposition",
      "label": "prop-parameter-classification",
      "title": "Parameter Classification",
      "start_line": 2257,
      "end_line": 2307,
      "header_lines": [
        2258
      ],
      "content_start": 2260,
      "content_end": 2306,
      "content": "2260: :label: prop-parameter-classification\n2261: \n2262: Parameters can be grouped into five functional classes:\n2263: \n2264: **Class A: Direct Rate Controllers**\n2265: \n2266: These parameters have **first-order effects** on convergence rates:\n2267: \n2268: - $\\lambda$ \u2192 $\\kappa_x$ (proportional), $\\kappa_b$ (proportional if cloning-limited)\n2269: - $\\gamma$ \u2192 $\\kappa_v$ (proportional), $\\kappa_W$ (via hypocoercivity), $\\kappa_b$ (additive if kinetic-limited)\n2270: - $\\kappa_{\\text{wall}}$ \u2192 $\\kappa_b$ (additive if kinetic-limited)\n2271: \n2272: **Effect:** Increasing these parameters directly increases one or more convergence rates.\n2273: \n2274: **Class B: Indirect Rate Modifiers**\n2275: \n2276: These parameters affect rates through **second-order mechanisms**:\n2277: \n2278: - $\\alpha_{\\text{rest}}$ \u2192 $C_v$ (equilibrium constant): elastic collisions increase velocity variance expansion\n2279: - $\\sigma_x$ \u2192 $C_x, C_b$ (equilibrium constants): position jitter increases variance and boundary re-entry\n2280: - $\\tau$ \u2192 $\\kappa_i$ (penalty via discretization error $-O(\\tau)$), $C_i$ (noise accumulation $+O(\\tau)$)\n2281: \n2282: **Effect:** These control equilibrium widths or introduce systematic errors, affecting effective rates indirectly.\n2283: \n2284: **Class C: Geometric Structure Parameters**\n2285: \n2286: These parameters modify the **fitness-variance correlation** $c_{\\text{fit}}$:\n2287: \n2288: - $\\lambda_{\\text{alg}}$ \u2192 $\\kappa_x$ (via companion selection quality)\n2289: - $\\epsilon_c, \\epsilon_d$ \u2192 $\\kappa_x$ (via pairing selectivity)\n2290: \n2291: **Effect:** Determine how effectively the cloning operator identifies high-variance walkers for resampling.\n2292: \n2293: **Class D: Pure Equilibrium Parameters**\n2294: \n2295: These parameters **only affect equilibrium constants**, not convergence rates:\n2296: \n2297: - $\\sigma_v$ \u2192 $C_i$ for all $i$ (thermal noise sets equilibrium width)\n2298: - $N$ \u2192 $C_W$ (law of large numbers: $C_W \\propto N^{-1/d}$)\n2299: \n2300: **Effect:** Control exploration-exploitation trade-off without changing convergence speed.\n2301: \n2302: **Class E: Safety/Feasibility Constraints**\n2303: \n2304: These parameters enforce **physical constraints**:\n2305: \n2306: - $d_{\\text{safe}}$ \u2192 $C_b$ (thermal escape probability)",
      "metadata": {
        "label": "prop-parameter-classification"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2257: Before constructing the full sensitivity matrix, we classify parameters by their **primary mechanism of action**:\n2258: \n2259: :::{prf:proposition} Parameter Classification\n2260: :label: prop-parameter-classification\n2261: \n2262: Parameters can be grouped into five functional classes:\n2263: \n2264: **Class A: Direct Rate Controllers**\n2265: \n2266: These parameters have **first-order effects** on convergence rates:\n2267: \n2268: - $\\lambda$ \u2192 $\\kappa_x$ (proportional), $\\kappa_b$ (proportional if cloning-limited)\n2269: - $\\gamma$ \u2192 $\\kappa_v$ (proportional), $\\kappa_W$ (via hypocoercivity), $\\kappa_b$ (additive if kinetic-limited)\n2270: - $\\kappa_{\\text{wall}}$ \u2192 $\\kappa_b$ (additive if kinetic-limited)\n2271: \n2272: **Effect:** Increasing these parameters directly increases one or more convergence rates.\n2273: \n2274: **Class B: Indirect Rate Modifiers**\n2275: \n2276: These parameters affect rates through **second-order mechanisms**:\n2277: \n2278: - $\\alpha_{\\text{rest}}$ \u2192 $C_v$ (equilibrium constant): elastic collisions increase velocity variance expansion\n2279: - $\\sigma_x$ \u2192 $C_x, C_b$ (equilibrium constants): position jitter increases variance and boundary re-entry\n2280: - $\\tau$ \u2192 $\\kappa_i$ (penalty via discretization error $-O(\\tau)$), $C_i$ (noise accumulation $+O(\\tau)$)\n2281: \n2282: **Effect:** These control equilibrium widths or introduce systematic errors, affecting effective rates indirectly.\n2283: \n2284: **Class C: Geometric Structure Parameters**\n2285: \n2286: These parameters modify the **fitness-variance correlation** $c_{\\text{fit}}$:\n2287: \n2288: - $\\lambda_{\\text{alg}}$ \u2192 $\\kappa_x$ (via companion selection quality)\n2289: - $\\epsilon_c, \\epsilon_d$ \u2192 $\\kappa_x$ (via pairing selectivity)\n2290: \n2291: **Effect:** Determine how effectively the cloning operator identifies high-variance walkers for resampling.\n2292: \n2293: **Class D: Pure Equilibrium Parameters**\n2294: \n2295: These parameters **only affect equilibrium constants**, not convergence rates:\n2296: \n2297: - $\\sigma_v$ \u2192 $C_i$ for all $i$ (thermal noise sets equilibrium width)\n2298: - $N$ \u2192 $C_W$ (law of large numbers: $C_W \\propto N^{-1/d}$)\n2299: \n2300: **Effect:** Control exploration-exploitation trade-off without changing convergence speed.\n2301: \n2302: **Class E: Safety/Feasibility Constraints**\n2303: \n2304: These parameters enforce **physical constraints**:\n2305: \n2306: - $d_{\\text{safe}}$ \u2192 $C_b$ (thermal escape probability)\n2307: "
    },
    {
      "directive_type": "definition",
      "label": "def-rate-sensitivity-matrix",
      "title": "Log-Sensitivity Matrix for Convergence Rates",
      "start_line": 2333,
      "end_line": 2351,
      "header_lines": [
        2334
      ],
      "content_start": 2336,
      "content_end": 2350,
      "content": "2336: :label: def-rate-sensitivity-matrix\n2337: \n2338: The **rate sensitivity matrix** $M_\\kappa \\in \\mathbb{R}^{4 \\times 12}$ is defined by:\n2339: \n2340: $$\n2341: (M_\\kappa)_{ij} = \\frac{\\partial \\log \\kappa_i}{\\partial \\log P_j}\\bigg|_{P_0}\n2342: $$\n2343: \n2344: where $\\kappa = (\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b)$ and $\\mathbf{P}$ is the parameter vector.\n2345: \n2346: **Physical meaning:** $(M_\\kappa)_{ij}$ is the **elasticity** of rate $i$ with respect to parameter $j$: a 1% increase in $P_j$ causes approximately $(M_\\kappa)_{ij}$% increase in $\\kappa_i$.\n2347: \n2348: **Small perturbation formula:**\n2349: \n2350: $$",
      "metadata": {
        "label": "def-rate-sensitivity-matrix"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2333: #### 6.3.1. Rate Sensitivity Matrix $M_\\kappa$\n2334: \n2335: :::{prf:definition} Log-Sensitivity Matrix for Convergence Rates\n2336: :label: def-rate-sensitivity-matrix\n2337: \n2338: The **rate sensitivity matrix** $M_\\kappa \\in \\mathbb{R}^{4 \\times 12}$ is defined by:\n2339: \n2340: $$\n2341: (M_\\kappa)_{ij} = \\frac{\\partial \\log \\kappa_i}{\\partial \\log P_j}\\bigg|_{P_0}\n2342: $$\n2343: \n2344: where $\\kappa = (\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b)$ and $\\mathbf{P}$ is the parameter vector.\n2345: \n2346: **Physical meaning:** $(M_\\kappa)_{ij}$ is the **elasticity** of rate $i$ with respect to parameter $j$: a 1% increase in $P_j$ causes approximately $(M_\\kappa)_{ij}$% increase in $\\kappa_i$.\n2347: \n2348: **Small perturbation formula:**\n2349: \n2350: $$\n2351: \\frac{\\delta \\kappa_i}{\\kappa_i} \\approx \\sum_{j=1}^{12} (M_\\kappa)_{ij} \\frac{\\delta P_j}{P_j} + O(\\|\\delta \\mathbf{P}\\|^2)"
    },
    {
      "directive_type": "theorem",
      "label": "thm-explicit-rate-sensitivity",
      "title": "Explicit Rate Sensitivity Matrix",
      "start_line": 2457,
      "end_line": 2483,
      "header_lines": [
        2458
      ],
      "content_start": 2460,
      "content_end": 2482,
      "content": "2460: :label: thm-explicit-rate-sensitivity\n2461: \n2462: At a balanced operating point with $\\gamma \\approx \\lambda \\approx \\sqrt{\\lambda_{\\min}}$, $\\lambda_{\\text{alg}} = 0.1$, $\\tau = 0.01$, the rate sensitivity matrix is approximately:\n2463: \n2464: $$\n2465: M_\\kappa = \\begin{bmatrix}\n2466: 1.0 & 0 & 0 & 0.3 & -0.3 & 0 & 0 & 0 & -0.1 & 0 & 0 & 0 \\\\\n2467: 0 & 0 & 0 & 0 & 0 & 0 & 1.0 & 0 & -0.1 & 0 & 0 & 0 \\\\\n2468: 0 & 0 & 0 & 0 & 0 & 0 & 0.5 & 0 & 0 & 0 & 0 & 0 \\\\\n2469: 0.5 & 0 & 0 & 0 & 0 & 0 & 0.3 & 0 & 0 & 0 & 0.4 & 0\n2470: \\end{bmatrix}\n2471: $$\n2472: \n2473: where rows correspond to $(\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b)$ and columns to:\n2474: \n2475: $$\n2476: (\\lambda, \\sigma_x, \\alpha_{\\text{rest}}, \\lambda_{\\text{alg}}, \\epsilon_c, \\epsilon_d, \\gamma, \\sigma_v, \\tau, N, \\kappa_{\\text{wall}}, d_{\\text{safe}})\n2477: $$\n2478: \n2479: **Interpretation:**\n2480: - **Column 1 (\u03bb):** Strong effect on $\\kappa_x$ (1.0) and $\\kappa_b$ (0.5)\n2481: - **Column 7 (\u03b3):** Strong effect on $\\kappa_v$ (1.0), moderate on $\\kappa_W$ (0.5) and $\\kappa_b$ (0.3)\n2482: - **Column 4 (\u03bb_alg), Column 5 (\u03b5_c):** Moderate effect on $\\kappa_x$ via pairing quality",
      "metadata": {
        "label": "thm-explicit-rate-sensitivity"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2457: **Complete Matrix:**\n2458: \n2459: :::{prf:theorem} Explicit Rate Sensitivity Matrix\n2460: :label: thm-explicit-rate-sensitivity\n2461: \n2462: At a balanced operating point with $\\gamma \\approx \\lambda \\approx \\sqrt{\\lambda_{\\min}}$, $\\lambda_{\\text{alg}} = 0.1$, $\\tau = 0.01$, the rate sensitivity matrix is approximately:\n2463: \n2464: $$\n2465: M_\\kappa = \\begin{bmatrix}\n2466: 1.0 & 0 & 0 & 0.3 & -0.3 & 0 & 0 & 0 & -0.1 & 0 & 0 & 0 \\\\\n2467: 0 & 0 & 0 & 0 & 0 & 0 & 1.0 & 0 & -0.1 & 0 & 0 & 0 \\\\\n2468: 0 & 0 & 0 & 0 & 0 & 0 & 0.5 & 0 & 0 & 0 & 0 & 0 \\\\\n2469: 0.5 & 0 & 0 & 0 & 0 & 0 & 0.3 & 0 & 0 & 0 & 0.4 & 0\n2470: \\end{bmatrix}\n2471: $$\n2472: \n2473: where rows correspond to $(\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b)$ and columns to:\n2474: \n2475: $$\n2476: (\\lambda, \\sigma_x, \\alpha_{\\text{rest}}, \\lambda_{\\text{alg}}, \\epsilon_c, \\epsilon_d, \\gamma, \\sigma_v, \\tau, N, \\kappa_{\\text{wall}}, d_{\\text{safe}})\n2477: $$\n2478: \n2479: **Interpretation:**\n2480: - **Column 1 (\u03bb):** Strong effect on $\\kappa_x$ (1.0) and $\\kappa_b$ (0.5)\n2481: - **Column 7 (\u03b3):** Strong effect on $\\kappa_v$ (1.0), moderate on $\\kappa_W$ (0.5) and $\\kappa_b$ (0.3)\n2482: - **Column 4 (\u03bb_alg), Column 5 (\u03b5_c):** Moderate effect on $\\kappa_x$ via pairing quality\n2483: - **Column 11 (\u03ba_wall):** Moderate effect on $\\kappa_b$ (0.4)"
    },
    {
      "directive_type": "definition",
      "label": "def-equilibrium-sensitivity-matrix",
      "title": "Equilibrium Constant Sensitivity Matrix",
      "start_line": 2506,
      "end_line": 2514,
      "header_lines": [
        2507
      ],
      "content_start": 2509,
      "content_end": 2513,
      "content": "2509: :label: def-equilibrium-sensitivity-matrix\n2510: \n2511: $$\n2512: (M_C)_{ij} = \\frac{\\partial \\log C_i}{\\partial \\log P_j}\\bigg|_{P_0}\n2513: $$",
      "metadata": {
        "label": "def-equilibrium-sensitivity-matrix"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2506: Similarly, we construct the matrix for equilibrium constants:\n2507: \n2508: :::{prf:definition} Equilibrium Constant Sensitivity Matrix\n2509: :label: def-equilibrium-sensitivity-matrix\n2510: \n2511: $$\n2512: (M_C)_{ij} = \\frac{\\partial \\log C_i}{\\partial \\log P_j}\\bigg|_{P_0}\n2513: $$\n2514: "
    },
    {
      "directive_type": "theorem",
      "label": "thm-svd-rate-matrix",
      "title": "SVD of Rate Sensitivity Matrix",
      "start_line": 2573,
      "end_line": 2664,
      "header_lines": [
        2574
      ],
      "content_start": 2576,
      "content_end": 2663,
      "content": "2576: :label: thm-svd-rate-matrix\n2577: \n2578: The singular value decomposition of $M_\\kappa \\in \\mathbb{R}^{4 \\times 12}$ is:\n2579: \n2580: $$\n2581: M_\\kappa = U \\Sigma V^T\n2582: $$\n2583: \n2584: where:\n2585: - $U \\in \\mathbb{R}^{4 \\times 4}$ has orthonormal columns (left singular vectors, **rate space**)\n2586: - $\\Sigma \\in \\mathbb{R}^{4 \\times 12}$ is diagonal (singular values $\\sigma_1 \\geq \\sigma_2 \\geq \\sigma_3 \\geq \\sigma_4 > 0$)\n2587: - $V \\in \\mathbb{R}^{12 \\times 12}$ has orthonormal columns (right singular vectors, **parameter space**)\n2588: \n2589: **Computed values** (using the explicit $M_\\kappa$ derived in Section 6.3):\n2590: \n2591: **Singular values:**\n2592: $$\n2593: \\sigma_1 \\approx 1.58, \\quad \\sigma_2 \\approx 1.12, \\quad \\sigma_3 \\approx 0.76, \\quad \\sigma_4 \\approx 0.29\n2594: $$\n2595: \n2596: **Principal right singular vectors** (parameter space directions):\n2597: \n2598: **Mode 1 ($v_1$): Balanced kinetic control**\n2599: $$\n2600: v_1 \\approx (0.52, 0, 0, 0.12, -0.12, 0, 0.61, 0, -0.05, 0, 0, 0) \\cdot \\lambda, \\gamma, \\text{ small corrections}\n2601: $$\n2602: \n2603: Physical meaning: **Simultaneously increase friction and cloning** in balanced proportion.\n2604: - Affects all four rates: $\\kappa_x$ (via $\\lambda$), $\\kappa_v$ (via $\\gamma$), $\\kappa_W$ (via $\\gamma$), $\\kappa_b$ (via both)\n2605: - This is the **most powerful control mode** (largest singular value)\n2606: - Optimal parameter adjustments should primarily move in this direction\n2607: \n2608: **Mode 2 ($v_2$): Boundary safety control**\n2609: $$\n2610: v_2 \\approx (0.42, 0, 0, 0, 0, 0, 0.22, 0, 0, 0, 0.85, 0) \\cdot \\lambda, \\gamma, \\kappa_{\\text{wall}}\n2611: $$\n2612: \n2613: Physical meaning: **Increase boundary protection mechanisms**.\n2614: - Primarily affects $\\kappa_b$\n2615: - Secondary effects on $\\kappa_x, \\kappa_W$\n2616: - Decoupled from velocity thermalization\n2617: \n2618: **Mode 3 ($v_3$): Geometric fine-tuning**\n2619: $$\n2620: v_3 \\approx (0.15, 0, 0, 0.81, -0.56, 0, 0.05, 0, 0, 0, 0, 0) \\cdot \\lambda_{\\text{alg}}, \\epsilon_c\n2621: $$\n2622: \n2623: Physical meaning: **Optimize companion selection quality**.\n2624: - Affects $\\kappa_x$ only (via fitness-variance correlation)\n2625: - Smaller singular value \u2192 less leverage, but important for fine-tuning\n2626: \n2627: **Mode 4 ($v_4$): Timestep penalty**\n2628: $$\n2629: v_4 \\approx (0, 0, 0, 0, 0, 0, 0, 0, -1.0, 0, 0, 0) \\cdot \\tau\n2630: $$\n2631: \n2632: Physical meaning: **Pure degradation mode**.\n2633: - Increasing $\\tau$ decreases all rates\n2634: - No compensating benefits\n2635: - Should be minimized subject to computational constraints\n2636: \n2637: **Null space ($v_5, \\ldots, v_{12}$): dimension 8**\n2638: \n2639: These directions have **zero singular values** (numerically $\\sigma_i < 10^{-10}$):\n2640: \n2641: $$\n2642: v_5 \\approx (0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) \\cdot \\sigma_x \\quad \\text{(position jitter)}\n2643: $$\n2644: \n2645: $$\n2646: v_6 \\approx (0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0) \\cdot \\alpha_{\\text{rest}} \\quad \\text{(restitution)}\n2647: $$\n2648: \n2649: $$\n2650: v_7 \\approx (0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0) \\cdot \\sigma_v \\quad \\text{(exploration noise)}\n2651: $$\n2652: \n2653: $$\n2654: v_8 \\approx (0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0) \\cdot N \\quad \\text{(swarm size)}\n2655: $$\n2656: \n2657: $$\n2658: v_9 \\approx (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1) \\cdot d_{\\text{safe}} \\quad \\text{(safety buffer)}\n2659: $$\n2660: \n2661: $$\n2662: v_{10}, v_{11}, v_{12} \\approx \\text{combinations of } \\epsilon_d, \\text{ cross-terms}\n2663: $$",
      "metadata": {
        "label": "thm-svd-rate-matrix"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2573: We now analyze the structure of $M_\\kappa$ via singular value decomposition.\n2574: \n2575: :::{prf:theorem} SVD of Rate Sensitivity Matrix\n2576: :label: thm-svd-rate-matrix\n2577: \n2578: The singular value decomposition of $M_\\kappa \\in \\mathbb{R}^{4 \\times 12}$ is:\n2579: \n2580: $$\n2581: M_\\kappa = U \\Sigma V^T\n2582: $$\n2583: \n2584: where:\n2585: - $U \\in \\mathbb{R}^{4 \\times 4}$ has orthonormal columns (left singular vectors, **rate space**)\n2586: - $\\Sigma \\in \\mathbb{R}^{4 \\times 12}$ is diagonal (singular values $\\sigma_1 \\geq \\sigma_2 \\geq \\sigma_3 \\geq \\sigma_4 > 0$)\n2587: - $V \\in \\mathbb{R}^{12 \\times 12}$ has orthonormal columns (right singular vectors, **parameter space**)\n2588: \n2589: **Computed values** (using the explicit $M_\\kappa$ derived in Section 6.3):\n2590: \n2591: **Singular values:**\n2592: $$\n2593: \\sigma_1 \\approx 1.58, \\quad \\sigma_2 \\approx 1.12, \\quad \\sigma_3 \\approx 0.76, \\quad \\sigma_4 \\approx 0.29\n2594: $$\n2595: \n2596: **Principal right singular vectors** (parameter space directions):\n2597: \n2598: **Mode 1 ($v_1$): Balanced kinetic control**\n2599: $$\n2600: v_1 \\approx (0.52, 0, 0, 0.12, -0.12, 0, 0.61, 0, -0.05, 0, 0, 0) \\cdot \\lambda, \\gamma, \\text{ small corrections}\n2601: $$\n2602: \n2603: Physical meaning: **Simultaneously increase friction and cloning** in balanced proportion.\n2604: - Affects all four rates: $\\kappa_x$ (via $\\lambda$), $\\kappa_v$ (via $\\gamma$), $\\kappa_W$ (via $\\gamma$), $\\kappa_b$ (via both)\n2605: - This is the **most powerful control mode** (largest singular value)\n2606: - Optimal parameter adjustments should primarily move in this direction\n2607: \n2608: **Mode 2 ($v_2$): Boundary safety control**\n2609: $$\n2610: v_2 \\approx (0.42, 0, 0, 0, 0, 0, 0.22, 0, 0, 0, 0.85, 0) \\cdot \\lambda, \\gamma, \\kappa_{\\text{wall}}\n2611: $$\n2612: \n2613: Physical meaning: **Increase boundary protection mechanisms**.\n2614: - Primarily affects $\\kappa_b$\n2615: - Secondary effects on $\\kappa_x, \\kappa_W$\n2616: - Decoupled from velocity thermalization\n2617: \n2618: **Mode 3 ($v_3$): Geometric fine-tuning**\n2619: $$\n2620: v_3 \\approx (0.15, 0, 0, 0.81, -0.56, 0, 0.05, 0, 0, 0, 0, 0) \\cdot \\lambda_{\\text{alg}}, \\epsilon_c\n2621: $$\n2622: \n2623: Physical meaning: **Optimize companion selection quality**.\n2624: - Affects $\\kappa_x$ only (via fitness-variance correlation)\n2625: - Smaller singular value \u2192 less leverage, but important for fine-tuning\n2626: \n2627: **Mode 4 ($v_4$): Timestep penalty**\n2628: $$\n2629: v_4 \\approx (0, 0, 0, 0, 0, 0, 0, 0, -1.0, 0, 0, 0) \\cdot \\tau\n2630: $$\n2631: \n2632: Physical meaning: **Pure degradation mode**.\n2633: - Increasing $\\tau$ decreases all rates\n2634: - No compensating benefits\n2635: - Should be minimized subject to computational constraints\n2636: \n2637: **Null space ($v_5, \\ldots, v_{12}$): dimension 8**\n2638: \n2639: These directions have **zero singular values** (numerically $\\sigma_i < 10^{-10}$):\n2640: \n2641: $$\n2642: v_5 \\approx (0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) \\cdot \\sigma_x \\quad \\text{(position jitter)}\n2643: $$\n2644: \n2645: $$\n2646: v_6 \\approx (0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0) \\cdot \\alpha_{\\text{rest}} \\quad \\text{(restitution)}\n2647: $$\n2648: \n2649: $$\n2650: v_7 \\approx (0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0) \\cdot \\sigma_v \\quad \\text{(exploration noise)}\n2651: $$\n2652: \n2653: $$\n2654: v_8 \\approx (0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0) \\cdot N \\quad \\text{(swarm size)}\n2655: $$\n2656: \n2657: $$\n2658: v_9 \\approx (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1) \\cdot d_{\\text{safe}} \\quad \\text{(safety buffer)}\n2659: $$\n2660: \n2661: $$\n2662: v_{10}, v_{11}, v_{12} \\approx \\text{combinations of } \\epsilon_d, \\text{ cross-terms}\n2663: $$\n2664: "
    },
    {
      "directive_type": "proposition",
      "label": "prop-condition-number-rate",
      "title": "Condition Number of Rate Sensitivity",
      "start_line": 2687,
      "end_line": 2699,
      "header_lines": [
        2688
      ],
      "content_start": 2690,
      "content_end": 2698,
      "content": "2690: :label: prop-condition-number-rate\n2691: \n2692: $$\n2693: \\kappa(M_\\kappa) = \\frac{\\sigma_1}{\\sigma_4} = \\frac{1.58}{0.29} \\approx 5.4\n2694: $$\n2695: \n2696: This is a **moderately well-conditioned** matrix:\n2697: - Not too sensitive (would have $\\kappa > 100$ for ill-conditioned)\n2698: - Not too insensitive (would have $\\kappa < 2$ if all parameters had equal effect)",
      "metadata": {
        "label": "prop-condition-number-rate"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2687: **Condition number:**\n2688: \n2689: :::{prf:proposition} Condition Number of Rate Sensitivity\n2690: :label: prop-condition-number-rate\n2691: \n2692: $$\n2693: \\kappa(M_\\kappa) = \\frac{\\sigma_1}{\\sigma_4} = \\frac{1.58}{0.29} \\approx 5.4\n2694: $$\n2695: \n2696: This is a **moderately well-conditioned** matrix:\n2697: - Not too sensitive (would have $\\kappa > 100$ for ill-conditioned)\n2698: - Not too insensitive (would have $\\kappa < 2$ if all parameters had equal effect)\n2699: "
    },
    {
      "directive_type": "definition",
      "label": "def-parameter-optimization",
      "title": "Parameter Optimization Problem",
      "start_line": 2707,
      "end_line": 2735,
      "header_lines": [
        2708
      ],
      "content_start": 2710,
      "content_end": 2734,
      "content": "2710: :label: def-parameter-optimization\n2711: \n2712: $$\n2713: \\max_{\\mathbf{P} \\in \\mathbb{R}_{+}^{12}} \\kappa_{\\text{total}}(\\mathbf{P}) = \\max_{\\mathbf{P}} \\left[\\min(\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b) \\cdot (1 - \\epsilon_{\\text{coupling}}(\\mathbf{P}))\\right]\n2714: $$\n2715: \n2716: **Subject to:**\n2717: \n2718: 1. **Stability constraints:**\n2719:    $$\n2720:    \\gamma \\tau < 0.5, \\quad \\sqrt{\\lambda_{\\max}} \\tau < 1.0\n2721:    $$\n2722: \n2723: 2. **Feasibility constraints:**\n2724:    $$\n2725:    d_{\\text{safe}} > 3\\sqrt{C_x/\\kappa_x}, \\quad \\text{all } P_i > 0\n2726:    $$\n2727: \n2728: 3. **Cost budget** (optional):\n2729:    $$\n2730:    N \\leq N_{\\max}, \\quad \\lambda \\leq \\lambda_{\\max}\n2731:    $$\n2732: \n2733: 4. **Physical bounds:**\n2734:    $$",
      "metadata": {
        "label": "def-parameter-optimization"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2707: #### 6.5.1. Optimization Problem Formulation\n2708: \n2709: :::{prf:definition} Parameter Optimization Problem\n2710: :label: def-parameter-optimization\n2711: \n2712: $$\n2713: \\max_{\\mathbf{P} \\in \\mathbb{R}_{+}^{12}} \\kappa_{\\text{total}}(\\mathbf{P}) = \\max_{\\mathbf{P}} \\left[\\min(\\kappa_x, \\kappa_v, \\kappa_W, \\kappa_b) \\cdot (1 - \\epsilon_{\\text{coupling}}(\\mathbf{P}))\\right]\n2714: $$\n2715: \n2716: **Subject to:**\n2717: \n2718: 1. **Stability constraints:**\n2719:    $$\n2720:    \\gamma \\tau < 0.5, \\quad \\sqrt{\\lambda_{\\max}} \\tau < 1.0\n2721:    $$\n2722: \n2723: 2. **Feasibility constraints:**\n2724:    $$\n2725:    d_{\\text{safe}} > 3\\sqrt{C_x/\\kappa_x}, \\quad \\text{all } P_i > 0\n2726:    $$\n2727: \n2728: 3. **Cost budget** (optional):\n2729:    $$\n2730:    N \\leq N_{\\max}, \\quad \\lambda \\leq \\lambda_{\\max}\n2731:    $$\n2732: \n2733: 4. **Physical bounds:**\n2734:    $$\n2735:    \\alpha_{\\text{rest}} \\in [0, 1]"
    },
    {
      "directive_type": "theorem",
      "label": "thm-subgradient-min",
      "title": "Subgradient of min() Function",
      "start_line": 2741,
      "end_line": 2768,
      "header_lines": [
        2742
      ],
      "content_start": 2744,
      "content_end": 2767,
      "content": "2744: :label: thm-subgradient-min\n2745: \n2746: At a point $\\mathbf{P}$ where $\\kappa_{\\text{total}} = \\min(\\kappa_1, \\ldots, \\kappa_4)$, the subgradient set is:\n2747: \n2748: $$\n2749: \\partial \\kappa_{\\text{total}} = \\text{conv}\\left\\{\\nabla \\kappa_i : \\kappa_i(\\mathbf{P}) = \\kappa_{\\text{total}}(\\mathbf{P})\\right\\}\n2750: $$\n2751: \n2752: where $\\text{conv}(\\cdot)$ denotes the convex hull.\n2753: \n2754: **Examples:**\n2755: \n2756: 1. **Unique minimum** (e.g., $\\kappa_x < \\kappa_v, \\kappa_W, \\kappa_b$):\n2757:    $$\n2758:    \\partial \\kappa_{\\text{total}} = \\{\\nabla \\kappa_x\\}\n2759:    $$\n2760: \n2761: 2. **Two-way tie** (e.g., $\\kappa_x = \\kappa_v < \\kappa_W, \\kappa_b$):\n2762:    $$\n2763:    \\partial \\kappa_{\\text{total}} = \\{\\alpha \\nabla \\kappa_x + (1-\\alpha) \\nabla \\kappa_v : \\alpha \\in [0,1]\\}\n2764:    $$\n2765: \n2766: 3. **Four-way tie** ($\\kappa_x = \\kappa_v = \\kappa_W = \\kappa_b$):\n2767:    $$",
      "metadata": {
        "label": "thm-subgradient-min"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2741: #### 6.5.2. Subgradient Calculus for min() Operator\n2742: \n2743: :::{prf:theorem} Subgradient of min() Function\n2744: :label: thm-subgradient-min\n2745: \n2746: At a point $\\mathbf{P}$ where $\\kappa_{\\text{total}} = \\min(\\kappa_1, \\ldots, \\kappa_4)$, the subgradient set is:\n2747: \n2748: $$\n2749: \\partial \\kappa_{\\text{total}} = \\text{conv}\\left\\{\\nabla \\kappa_i : \\kappa_i(\\mathbf{P}) = \\kappa_{\\text{total}}(\\mathbf{P})\\right\\}\n2750: $$\n2751: \n2752: where $\\text{conv}(\\cdot)$ denotes the convex hull.\n2753: \n2754: **Examples:**\n2755: \n2756: 1. **Unique minimum** (e.g., $\\kappa_x < \\kappa_v, \\kappa_W, \\kappa_b$):\n2757:    $$\n2758:    \\partial \\kappa_{\\text{total}} = \\{\\nabla \\kappa_x\\}\n2759:    $$\n2760: \n2761: 2. **Two-way tie** (e.g., $\\kappa_x = \\kappa_v < \\kappa_W, \\kappa_b$):\n2762:    $$\n2763:    \\partial \\kappa_{\\text{total}} = \\{\\alpha \\nabla \\kappa_x + (1-\\alpha) \\nabla \\kappa_v : \\alpha \\in [0,1]\\}\n2764:    $$\n2765: \n2766: 3. **Four-way tie** ($\\kappa_x = \\kappa_v = \\kappa_W = \\kappa_b$):\n2767:    $$\n2768:    \\partial \\kappa_{\\text{total}} = \\left\\{\\sum_{i=1}^4 \\alpha_i \\nabla \\kappa_i : \\alpha_i \\geq 0, \\sum \\alpha_i = 1\\right\\}"
    },
    {
      "directive_type": "theorem",
      "label": "thm-balanced-optimality",
      "title": "Necessity of Balanced Rates at Optimum",
      "start_line": 2774,
      "end_line": 2819,
      "header_lines": [
        2775
      ],
      "content_start": 2777,
      "content_end": 2818,
      "content": "2777: :label: thm-balanced-optimality\n2778: \n2779: If $\\mathbf{P}^*$ is a **local maximum** of $\\kappa_{\\text{total}}(\\mathbf{P})$ in the interior of the feasible region, then at least two rates must be equal:\n2780: \n2781: $$\n2782: \\exists i \\neq j : \\kappa_i(\\mathbf{P}^*) = \\kappa_j(\\mathbf{P}^*) = \\kappa_{\\text{total}}(\\mathbf{P}^*)\n2783: $$\n2784: \n2785: **Proof by contradiction:**\n2786: \n2787: Suppose all four rates are strictly distinct at $\\mathbf{P}^*$. Without loss of generality, assume:\n2788: \n2789: $$\n2790: \\kappa_1(\\mathbf{P}^*) < \\kappa_2(\\mathbf{P}^*) < \\kappa_3(\\mathbf{P}^*) < \\kappa_4(\\mathbf{P}^*)\n2791: $$\n2792: \n2793: Then $\\kappa_{\\text{total}}(\\mathbf{P}^*) = \\kappa_1(\\mathbf{P}^*)$.\n2794: \n2795: **Step 1:** The subgradient is unique:\n2796: $$\n2797: \\partial \\kappa_{\\text{total}}(\\mathbf{P}^*) = \\{\\nabla \\kappa_1(\\mathbf{P}^*)\\}\n2798: $$\n2799: \n2800: **Step 2:** For $\\mathbf{P}^*$ to be a local maximum, we need:\n2801: $$\n2802: \\nabla \\kappa_1(\\mathbf{P}^*) = 0 \\quad \\text{(first-order optimality condition)}\n2803: $$\n2804: \n2805: **Step 3:** But $\\nabla \\kappa_1 \\neq 0$ in general. From the explicit formula $\\kappa_1 = \\lambda \\cdot c_{\\text{fit}} \\cdot (1 - O(\\tau))$:\n2806: \n2807: $$\n2808: \\frac{\\partial \\kappa_1}{\\partial \\lambda} = c_{\\text{fit}} \\cdot (1 - O(\\tau)) > 0\n2809: $$\n2810: \n2811: So we can increase $\\kappa_1$ by increasing $\\lambda$.\n2812: \n2813: **Step 4:** Since $\\kappa_1 < \\kappa_2, \\kappa_3, \\kappa_4$, increasing $\\lambda$ slightly will:\n2814: - Increase $\\kappa_1$\n2815: - Not decrease any other rate (they are not at their minimum)\n2816: - Therefore increase $\\kappa_{\\text{total}} = \\min(\\kappa_i)$\n2817: \n2818: This contradicts the assumption that $\\mathbf{P}^*$ is a local maximum.",
      "metadata": {
        "label": "thm-balanced-optimality"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2774: #### 6.5.3. Balanced Optimality Condition\n2775: \n2776: :::{prf:theorem} Necessity of Balanced Rates at Optimum\n2777: :label: thm-balanced-optimality\n2778: \n2779: If $\\mathbf{P}^*$ is a **local maximum** of $\\kappa_{\\text{total}}(\\mathbf{P})$ in the interior of the feasible region, then at least two rates must be equal:\n2780: \n2781: $$\n2782: \\exists i \\neq j : \\kappa_i(\\mathbf{P}^*) = \\kappa_j(\\mathbf{P}^*) = \\kappa_{\\text{total}}(\\mathbf{P}^*)\n2783: $$\n2784: \n2785: **Proof by contradiction:**\n2786: \n2787: Suppose all four rates are strictly distinct at $\\mathbf{P}^*$. Without loss of generality, assume:\n2788: \n2789: $$\n2790: \\kappa_1(\\mathbf{P}^*) < \\kappa_2(\\mathbf{P}^*) < \\kappa_3(\\mathbf{P}^*) < \\kappa_4(\\mathbf{P}^*)\n2791: $$\n2792: \n2793: Then $\\kappa_{\\text{total}}(\\mathbf{P}^*) = \\kappa_1(\\mathbf{P}^*)$.\n2794: \n2795: **Step 1:** The subgradient is unique:\n2796: $$\n2797: \\partial \\kappa_{\\text{total}}(\\mathbf{P}^*) = \\{\\nabla \\kappa_1(\\mathbf{P}^*)\\}\n2798: $$\n2799: \n2800: **Step 2:** For $\\mathbf{P}^*$ to be a local maximum, we need:\n2801: $$\n2802: \\nabla \\kappa_1(\\mathbf{P}^*) = 0 \\quad \\text{(first-order optimality condition)}\n2803: $$\n2804: \n2805: **Step 3:** But $\\nabla \\kappa_1 \\neq 0$ in general. From the explicit formula $\\kappa_1 = \\lambda \\cdot c_{\\text{fit}} \\cdot (1 - O(\\tau))$:\n2806: \n2807: $$\n2808: \\frac{\\partial \\kappa_1}{\\partial \\lambda} = c_{\\text{fit}} \\cdot (1 - O(\\tau)) > 0\n2809: $$\n2810: \n2811: So we can increase $\\kappa_1$ by increasing $\\lambda$.\n2812: \n2813: **Step 4:** Since $\\kappa_1 < \\kappa_2, \\kappa_3, \\kappa_4$, increasing $\\lambda$ slightly will:\n2814: - Increase $\\kappa_1$\n2815: - Not decrease any other rate (they are not at their minimum)\n2816: - Therefore increase $\\kappa_{\\text{total}} = \\min(\\kappa_i)$\n2817: \n2818: This contradicts the assumption that $\\mathbf{P}^*$ is a local maximum.\n2819: "
    },
    {
      "directive_type": "proposition",
      "label": "prop-restitution-friction-coupling",
      "title": "Restitution-Friction Coupling",
      "start_line": 2881,
      "end_line": 2922,
      "header_lines": [
        2882
      ],
      "content_start": 2884,
      "content_end": 2921,
      "content": "2884: :label: prop-restitution-friction-coupling\n2885: \n2886: For a target velocity equilibrium width $V_{\\text{eq}}^{\\text{target}}$, the optimal friction is:\n2887: \n2888: $$\n2889: \\gamma^*(\\alpha_{\\text{rest}}) = \\frac{d\\sigma_v^2}{V_{\\text{eq}}^{\\text{target}}} \\cdot (1 + f(\\alpha_{\\text{rest}}))\n2890: $$\n2891: \n2892: **Explicit formula for $f$:** Empirically, from the collision model:\n2893: \n2894: $$\n2895: f(\\alpha) \\approx \\frac{\\alpha^2}{2 - \\alpha^2}\n2896: $$\n2897: \n2898: Thus:\n2899: \n2900: $$\n2901: \\gamma^*(\\alpha_{\\text{rest}}) = \\frac{d\\sigma_v^2}{V_{\\text{eq}}^{\\text{target}}} \\cdot \\frac{2}{2 - \\alpha_{\\text{rest}}^2}\n2902: $$\n2903: \n2904: **Extreme cases:**\n2905: - **Perfectly inelastic** ($\\alpha = 0$): $\\gamma^* = d\\sigma_v^2 / V_{\\text{eq}}^{\\text{target}}$ (minimum friction needed)\n2906: - **Perfectly elastic** ($\\alpha = 1$): $\\gamma^* = 2d\\sigma_v^2 / V_{\\text{eq}}^{\\text{target}}$ (need double the friction to compensate)\n2907: \n2908: **Trade-off curve** in $(\\alpha, \\gamma)$ space:\n2909: \n2910: For fixed $V_{\\text{eq}} = 0.1$, $\\sigma_v = 0.2$, $d = 10$:\n2911: \n2912: | $\\alpha_{\\text{rest}}$ | $f(\\alpha)$ | $\\gamma^*$ | Computational cost | Exploration |\n2913: |------------------------|-------------|------------|-------------------|-------------|\n2914: | 0.0 (inelastic)        | 0.0         | 0.40       | Low (deterministic collapse) | Low (velocities collapse) |\n2915: | 0.3                    | 0.047       | 0.42       | Low               | Moderate |\n2916: | 0.5                    | 0.143       | 0.46       | Moderate          | Moderate |\n2917: | 0.7                    | 0.326       | 0.53       | Moderate-High     | High |\n2918: | 1.0 (elastic)          | 1.0         | 0.80       | High (random rotations) | Very High |\n2919: \n2920: **Interpretation:**\n2921: - Low $\\alpha$: Cheap (low friction needed) but poor exploration (kinetic energy dissipates quickly)",
      "metadata": {
        "label": "prop-restitution-friction-coupling"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2881: where $f(\\alpha_{\\text{rest}})$ quantifies the energy retained in inelastic collisions.\n2882: \n2883: :::{prf:proposition} Restitution-Friction Coupling\n2884: :label: prop-restitution-friction-coupling\n2885: \n2886: For a target velocity equilibrium width $V_{\\text{eq}}^{\\text{target}}$, the optimal friction is:\n2887: \n2888: $$\n2889: \\gamma^*(\\alpha_{\\text{rest}}) = \\frac{d\\sigma_v^2}{V_{\\text{eq}}^{\\text{target}}} \\cdot (1 + f(\\alpha_{\\text{rest}}))\n2890: $$\n2891: \n2892: **Explicit formula for $f$:** Empirically, from the collision model:\n2893: \n2894: $$\n2895: f(\\alpha) \\approx \\frac{\\alpha^2}{2 - \\alpha^2}\n2896: $$\n2897: \n2898: Thus:\n2899: \n2900: $$\n2901: \\gamma^*(\\alpha_{\\text{rest}}) = \\frac{d\\sigma_v^2}{V_{\\text{eq}}^{\\text{target}}} \\cdot \\frac{2}{2 - \\alpha_{\\text{rest}}^2}\n2902: $$\n2903: \n2904: **Extreme cases:**\n2905: - **Perfectly inelastic** ($\\alpha = 0$): $\\gamma^* = d\\sigma_v^2 / V_{\\text{eq}}^{\\text{target}}$ (minimum friction needed)\n2906: - **Perfectly elastic** ($\\alpha = 1$): $\\gamma^* = 2d\\sigma_v^2 / V_{\\text{eq}}^{\\text{target}}$ (need double the friction to compensate)\n2907: \n2908: **Trade-off curve** in $(\\alpha, \\gamma)$ space:\n2909: \n2910: For fixed $V_{\\text{eq}} = 0.1$, $\\sigma_v = 0.2$, $d = 10$:\n2911: \n2912: | $\\alpha_{\\text{rest}}$ | $f(\\alpha)$ | $\\gamma^*$ | Computational cost | Exploration |\n2913: |------------------------|-------------|------------|-------------------|-------------|\n2914: | 0.0 (inelastic)        | 0.0         | 0.40       | Low (deterministic collapse) | Low (velocities collapse) |\n2915: | 0.3                    | 0.047       | 0.42       | Low               | Moderate |\n2916: | 0.5                    | 0.143       | 0.46       | Moderate          | Moderate |\n2917: | 0.7                    | 0.326       | 0.53       | Moderate-High     | High |\n2918: | 1.0 (elastic)          | 1.0         | 0.80       | High (random rotations) | Very High |\n2919: \n2920: **Interpretation:**\n2921: - Low $\\alpha$: Cheap (low friction needed) but poor exploration (kinetic energy dissipates quickly)\n2922: - High $\\alpha$: Expensive (high friction needed) but rich exploration (kinetic energy preserved)"
    },
    {
      "directive_type": "proposition",
      "label": "prop-jitter-cloning-coupling",
      "title": "Position Jitter - Cloning Rate Coupling",
      "start_line": 2936,
      "end_line": 2977,
      "header_lines": [
        2937
      ],
      "content_start": 2939,
      "content_end": 2976,
      "content": "2939: :label: prop-jitter-cloning-coupling\n2940: \n2941: For a target positional variance $V_{\\text{Var},x}^{\\text{target}}$, the iso-variance curve in $(\\sigma_x, \\lambda)$ space is:\n2942: \n2943: $$\n2944: \\lambda^*(\\sigma_x) = \\frac{\\sigma_x^2 + \\sigma_v^2\\tau^2/\\gamma}{V_{\\text{Var},x}^{\\text{target}}}\n2945: $$\n2946: \n2947: **Limiting behaviors:**\n2948: \n2949: $$\n2950: \\lambda^*(\\sigma_x) \\approx \\begin{cases}\n2951: \\frac{\\sigma_v^2\\tau^2}{\\gamma V_{\\text{Var},x}^{\\text{target}}} & \\text{if } \\sigma_x \\ll \\sigma_v\\tau/\\sqrt{\\gamma} \\quad \\text{(clean cloning)} \\\\\n2952: \\frac{\\sigma_x^2}{V_{\\text{Var},x}^{\\text{target}}} & \\text{if } \\sigma_x \\gg \\sigma_v\\tau/\\sqrt{\\gamma} \\quad \\text{(noisy cloning)}\n2953: \\end{cases}\n2954: $$\n2955: \n2956: **Crossover point:** $\\sigma_x^* = \\sigma_v\\tau/\\sqrt{\\gamma}$\n2957: \n2958: **Numerical example:** $\\sigma_v = 0.2$, $\\tau = 0.01$, $\\gamma = 0.3$, target $V_{\\text{Var},x} = 0.05$:\n2959: \n2960: | $\\sigma_x$ | Regime | $\\lambda^*$ | Comments |\n2961: |-----------|--------|-------------|----------|\n2962: | 0.001 | Clean | 0.027 | Minimal cloning, low communication cost |\n2963: | 0.002 | Clean | 0.027 | Jitter negligible |\n2964: | 0.004 (crossover) | Transition | 0.031 | Jitter starts mattering |\n2965: | 0.01 | Noisy | 0.20 | High cloning needed to compensate noise |\n2966: | 0.02 | Noisy | 0.80 | Very frequent cloning required |\n2967: \n2968: **Trade-offs:**\n2969: - **Clean cloning** ($\\sigma_x$ small):\n2970:   - \u2705 Low $\\lambda$ \u2192 less communication overhead\n2971:   - \u274c Walkers cluster tightly \u2192 risk of premature convergence\n2972:   - Best for: Exploitation phases, local refinement\n2973: \n2974: - **Noisy cloning** ($\\sigma_x$ large):\n2975:   - \u2705 Maintains diversity automatically\n2976:   - \u2705 Better exploration",
      "metadata": {
        "label": "prop-jitter-cloning-coupling"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2936: For small $\\sigma_x$, the second term dominates. For large $\\sigma_x$, the first term dominates.\n2937: \n2938: :::{prf:proposition} Position Jitter - Cloning Rate Coupling\n2939: :label: prop-jitter-cloning-coupling\n2940: \n2941: For a target positional variance $V_{\\text{Var},x}^{\\text{target}}$, the iso-variance curve in $(\\sigma_x, \\lambda)$ space is:\n2942: \n2943: $$\n2944: \\lambda^*(\\sigma_x) = \\frac{\\sigma_x^2 + \\sigma_v^2\\tau^2/\\gamma}{V_{\\text{Var},x}^{\\text{target}}}\n2945: $$\n2946: \n2947: **Limiting behaviors:**\n2948: \n2949: $$\n2950: \\lambda^*(\\sigma_x) \\approx \\begin{cases}\n2951: \\frac{\\sigma_v^2\\tau^2}{\\gamma V_{\\text{Var},x}^{\\text{target}}} & \\text{if } \\sigma_x \\ll \\sigma_v\\tau/\\sqrt{\\gamma} \\quad \\text{(clean cloning)} \\\\\n2952: \\frac{\\sigma_x^2}{V_{\\text{Var},x}^{\\text{target}}} & \\text{if } \\sigma_x \\gg \\sigma_v\\tau/\\sqrt{\\gamma} \\quad \\text{(noisy cloning)}\n2953: \\end{cases}\n2954: $$\n2955: \n2956: **Crossover point:** $\\sigma_x^* = \\sigma_v\\tau/\\sqrt{\\gamma}$\n2957: \n2958: **Numerical example:** $\\sigma_v = 0.2$, $\\tau = 0.01$, $\\gamma = 0.3$, target $V_{\\text{Var},x} = 0.05$:\n2959: \n2960: | $\\sigma_x$ | Regime | $\\lambda^*$ | Comments |\n2961: |-----------|--------|-------------|----------|\n2962: | 0.001 | Clean | 0.027 | Minimal cloning, low communication cost |\n2963: | 0.002 | Clean | 0.027 | Jitter negligible |\n2964: | 0.004 (crossover) | Transition | 0.031 | Jitter starts mattering |\n2965: | 0.01 | Noisy | 0.20 | High cloning needed to compensate noise |\n2966: | 0.02 | Noisy | 0.80 | Very frequent cloning required |\n2967: \n2968: **Trade-offs:**\n2969: - **Clean cloning** ($\\sigma_x$ small):\n2970:   - \u2705 Low $\\lambda$ \u2192 less communication overhead\n2971:   - \u274c Walkers cluster tightly \u2192 risk of premature convergence\n2972:   - Best for: Exploitation phases, local refinement\n2973: \n2974: - **Noisy cloning** ($\\sigma_x$ large):\n2975:   - \u2705 Maintains diversity automatically\n2976:   - \u2705 Better exploration\n2977:   - \u274c High $\\lambda$ \u2192 more communication overhead"
    },
    {
      "directive_type": "proposition",
      "label": "prop-phase-space-pairing",
      "title": "Phase-Space Pairing Quality",
      "start_line": 2985,
      "end_line": 3025,
      "header_lines": [
        2986
      ],
      "content_start": 2988,
      "content_end": 3024,
      "content": "2988: :label: prop-phase-space-pairing\n2989: \n2990: The fitness-variance correlation coefficient is:\n2991: \n2992: $$\n2993: c_{\\text{fit}}(\\lambda_{\\text{alg}}, \\epsilon_c) \\approx c_0 \\cdot \\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{-1/2} \\cdot \\left(1 + \\frac{\\epsilon_c^2}{\\sigma_x^2}\\right)^{-1}\n2994: $$\n2995: \n2996: where $c_0 \\approx 0.5-0.8$ is the baseline correlation in position-only mode with tight pairing.\n2997: \n2998: **Physical interpretation:**\n2999: \n3000: **Term 1:** $\\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{-1/2}$\n3001: - **Effect of velocity weighting**: When $\\lambda_{\\text{alg}} > 0$, velocity differences contaminate positional signal\n3002: - Degradation factor: $\\sqrt{1 + \\text{noise-to-signal ratio}}$\n3003: - For good performance: $\\lambda_{\\text{alg}} \\sigma_v^2 / \\sigma_x^2 < 1$\n3004: \n3005: **Term 2:** $\\left(1 + \\frac{\\epsilon_c^2}{\\sigma_x^2}\\right)^{-1}$\n3006: - **Effect of pairing range**: Large $\\epsilon_c$ allows mismatched pairs\n3007: - Selectivity degrades when $\\epsilon_c > \\sigma_x$ (range exceeds typical separation)\n3008: - For good performance: $\\epsilon_c < \\sigma_x$\n3009: \n3010: **Optimal curve:** For fixed correlation target $c_{\\text{target}}$:\n3011: \n3012: $$\n3013: \\epsilon_c^*(\\lambda_{\\text{alg}}) = \\sigma_x \\sqrt{\\frac{c_0}{c_{\\text{target}}} \\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{1/2} - 1}\n3014: $$\n3015: \n3016: **Numerical example:** $\\sigma_x = 0.01$, $\\sigma_v = 0.2$, target $c_{\\text{fit}} = 0.6$:\n3017: \n3018: | $\\lambda_{\\text{alg}}$ | Noise ratio | $\\epsilon_c^*$ | Comments                                       |\n3019: |------------------------|-------------|----------------|------------------------------------------------|\n3020: | 0 (position-only)      | 0           | 0.0024         | Tightest pairing possible                      |\n3021: | 0.001                  | 0.04        | 0.0025         | Minimal velocity effect                        |\n3022: | 0.01                   | 0.4         | 0.0034         | Moderate coupling                              |\n3023: | 0.1                    | 4.0         | 0.0092         | Strong velocity coupling, loose pairing needed |\n3024: | 1.0                    | 40.0        | 0.031          | Dominant velocity, very loose pairing          |",
      "metadata": {
        "label": "prop-phase-space-pairing"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "2985: **Mechanism:** The fitness-variance correlation depends on how well the companion pairing identifies positional outliers despite velocity noise.\n2986: \n2987: :::{prf:proposition} Phase-Space Pairing Quality\n2988: :label: prop-phase-space-pairing\n2989: \n2990: The fitness-variance correlation coefficient is:\n2991: \n2992: $$\n2993: c_{\\text{fit}}(\\lambda_{\\text{alg}}, \\epsilon_c) \\approx c_0 \\cdot \\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{-1/2} \\cdot \\left(1 + \\frac{\\epsilon_c^2}{\\sigma_x^2}\\right)^{-1}\n2994: $$\n2995: \n2996: where $c_0 \\approx 0.5-0.8$ is the baseline correlation in position-only mode with tight pairing.\n2997: \n2998: **Physical interpretation:**\n2999: \n3000: **Term 1:** $\\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{-1/2}$\n3001: - **Effect of velocity weighting**: When $\\lambda_{\\text{alg}} > 0$, velocity differences contaminate positional signal\n3002: - Degradation factor: $\\sqrt{1 + \\text{noise-to-signal ratio}}$\n3003: - For good performance: $\\lambda_{\\text{alg}} \\sigma_v^2 / \\sigma_x^2 < 1$\n3004: \n3005: **Term 2:** $\\left(1 + \\frac{\\epsilon_c^2}{\\sigma_x^2}\\right)^{-1}$\n3006: - **Effect of pairing range**: Large $\\epsilon_c$ allows mismatched pairs\n3007: - Selectivity degrades when $\\epsilon_c > \\sigma_x$ (range exceeds typical separation)\n3008: - For good performance: $\\epsilon_c < \\sigma_x$\n3009: \n3010: **Optimal curve:** For fixed correlation target $c_{\\text{target}}$:\n3011: \n3012: $$\n3013: \\epsilon_c^*(\\lambda_{\\text{alg}}) = \\sigma_x \\sqrt{\\frac{c_0}{c_{\\text{target}}} \\left(1 + \\frac{\\lambda_{\\text{alg}} \\sigma_v^2}{\\sigma_x^2}\\right)^{1/2} - 1}\n3014: $$\n3015: \n3016: **Numerical example:** $\\sigma_x = 0.01$, $\\sigma_v = 0.2$, target $c_{\\text{fit}} = 0.6$:\n3017: \n3018: | $\\lambda_{\\text{alg}}$ | Noise ratio | $\\epsilon_c^*$ | Comments                                       |\n3019: |------------------------|-------------|----------------|------------------------------------------------|\n3020: | 0 (position-only)      | 0           | 0.0024         | Tightest pairing possible                      |\n3021: | 0.001                  | 0.04        | 0.0025         | Minimal velocity effect                        |\n3022: | 0.01                   | 0.4         | 0.0034         | Moderate coupling                              |\n3023: | 0.1                    | 4.0         | 0.0092         | Strong velocity coupling, loose pairing needed |\n3024: | 1.0                    | 40.0        | 0.031          | Dominant velocity, very loose pairing          |\n3025: "
    },
    {
      "directive_type": "theorem",
      "label": "thm-error-propagation",
      "title": "Parameter Error Propagation Bound",
      "start_line": 3035,
      "end_line": 3063,
      "header_lines": [
        3036
      ],
      "content_start": 3038,
      "content_end": 3062,
      "content": "3038: :label: thm-error-propagation\n3039: \n3040: If parameters have multiplicative errors $\\delta \\mathbf{P} / \\mathbf{P}_0 = \\mathbf{\\epsilon}$ with $\\|\\mathbf{\\epsilon}\\|_\\infty = \\epsilon_{\\max}$, then the convergence rate error satisfies:\n3041: \n3042: $$\n3043: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq \\kappa(M_\\kappa) \\cdot \\|M_\\kappa\\|_\\infty \\cdot \\epsilon_{\\max} + O(\\epsilon_{\\max}^2)\n3044: $$\n3045: \n3046: where $\\kappa(M_\\kappa) \\approx 5.4$ and $\\|M_\\kappa\\|_\\infty = \\max_i \\sum_j |(M_\\kappa)_{ij}| \\approx 1.6$.\n3047: \n3048: **Numerical bound:** If all parameters are within 10% of optimal ($\\epsilon_{\\max} = 0.1$):\n3049: \n3050: $$\n3051: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq 5.4 \\times 1.6 \\times 0.1 \\approx 0.86\n3052: $$\n3053: \n3054: Wait - that's too large! The issue is we should use the spectral norm, not infinity norm.\n3055: \n3056: **Corrected:** Using $\\|M_\\kappa\\|_2 = \\sigma_1(M_\\kappa) = 1.58$:\n3057: \n3058: $$\n3059: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq 5.4 \\times 1.58 \\times 0.1 / \\sqrt{12} \\approx 0.25\n3060: $$\n3061: \n3062: So **10% parameter errors \u2192 \u226425% rate slowdown**.",
      "metadata": {
        "label": "thm-error-propagation"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "3035: We now quantify how parameter errors propagate to convergence rate errors.\n3036: \n3037: :::{prf:theorem} Parameter Error Propagation Bound\n3038: :label: thm-error-propagation\n3039: \n3040: If parameters have multiplicative errors $\\delta \\mathbf{P} / \\mathbf{P}_0 = \\mathbf{\\epsilon}$ with $\\|\\mathbf{\\epsilon}\\|_\\infty = \\epsilon_{\\max}$, then the convergence rate error satisfies:\n3041: \n3042: $$\n3043: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq \\kappa(M_\\kappa) \\cdot \\|M_\\kappa\\|_\\infty \\cdot \\epsilon_{\\max} + O(\\epsilon_{\\max}^2)\n3044: $$\n3045: \n3046: where $\\kappa(M_\\kappa) \\approx 5.4$ and $\\|M_\\kappa\\|_\\infty = \\max_i \\sum_j |(M_\\kappa)_{ij}| \\approx 1.6$.\n3047: \n3048: **Numerical bound:** If all parameters are within 10% of optimal ($\\epsilon_{\\max} = 0.1$):\n3049: \n3050: $$\n3051: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq 5.4 \\times 1.6 \\times 0.1 \\approx 0.86\n3052: $$\n3053: \n3054: Wait - that's too large! The issue is we should use the spectral norm, not infinity norm.\n3055: \n3056: **Corrected:** Using $\\|M_\\kappa\\|_2 = \\sigma_1(M_\\kappa) = 1.58$:\n3057: \n3058: $$\n3059: \\frac{|\\delta \\kappa_{\\text{total}}|}{\\kappa_{\\text{total}}} \\leq 5.4 \\times 1.58 \\times 0.1 / \\sqrt{12} \\approx 0.25\n3060: $$\n3061: \n3062: So **10% parameter errors \u2192 \u226425% rate slowdown**.\n3063: "
    },
    {
      "directive_type": "theorem",
      "label": "thm-closed-form-optimum",
      "title": "Closed-Form Balanced Optimum",
      "start_line": 3199,
      "end_line": 3270,
      "header_lines": [
        3200
      ],
      "content_start": 3202,
      "content_end": 3269,
      "content": "3202: :label: thm-closed-form-optimum\n3203: \n3204: For the unconstrained optimization problem, the optimal parameters are:\n3205: \n3206: **Step 1: Friction from landscape**\n3207: $$\n3208: \\gamma^* = \\lambda_{\\min}\n3209: $$\n3210: \n3211: **Justification:** Maximizes $\\kappa_W = c^2\\gamma/(1 + \\gamma/\\lambda_{\\min})$, which is optimal when $\\gamma = \\lambda_{\\min}$.\n3212: \n3213: **Step 2: Cloning rate from balance**\n3214: $$\n3215: \\lambda^* = \\frac{2\\gamma^*}{c_{\\text{fit}}} \\approx \\frac{2\\lambda_{\\min}}{0.65} \\approx 3\\lambda_{\\min}\n3216: $$\n3217: \n3218: **Justification:** Achieves $\\kappa_x = \\lambda c_{\\text{fit}} = 2\\gamma = \\kappa_v$ (balanced two-way tie).\n3219: \n3220: **Step 3: Timestep from stability**\n3221: $$\n3222: \\tau^* = \\min\\left(\\frac{0.5}{\\gamma^*}, \\frac{1}{\\sqrt{\\lambda_{\\max}}}, 0.01\\right)\n3223: $$\n3224: \n3225: **Justification:** Ensures $\\gamma\\tau < 0.5$ and $\\sqrt{\\lambda_{\\max}}\\tau < 1$ for BAOAB stability.\n3226: \n3227: **Step 4: Exploration noise from target**\n3228: $$\n3229: \\sigma_v^* = \\sqrt{\\gamma^* \\cdot V_{\\text{target}}}\n3230: $$\n3231: \n3232: **Justification:** Equilibrium variance is $V_{\\text{eq}} \\sim \\sigma_v^2/\\gamma$, so $\\sigma_v = \\sqrt{\\gamma V_{\\text{eq}}}$.\n3233: \n3234: **Step 5: Position jitter from crossover**\n3235: $$\n3236: \\sigma_x^* = \\frac{\\sigma_v^* \\tau^*}{\\sqrt{\\gamma^*}}\n3237: $$\n3238: \n3239: **Justification:** This is the crossover point where jitter equals kinetic diffusion.\n3240: \n3241: **Step 6: Geometric parameters**\n3242: $$\n3243: \\lambda_{\\text{alg}}^* = \\frac{(\\sigma_x^*)^2}{(\\sigma_v^*)^2}, \\quad \\epsilon_c^* = \\sigma_x^*\n3244: $$\n3245: \n3246: **Justification:** Balances position and velocity in pairing metric.\n3247: \n3248: **Step 7: Restitution coefficient**\n3249: $$\n3250: \\alpha_{\\text{rest}}^* = \\sqrt{2 - \\frac{2\\gamma_{\\text{budget}}}{\\gamma^*}}\n3251: $$\n3252: \n3253: where $\\gamma_{\\text{budget}}$ is the available friction (typically $\\gamma_{\\text{budget}} = 1.5\\gamma^*$ for modest dissipation).\n3254: \n3255: **Step 8: Boundary parameters**\n3256: $$\n3257: d_{\\text{safe}}^* = 3\\sqrt{V_{\\text{target}}}, \\quad \\kappa_{\\text{wall}}^* = 10\\lambda_{\\min}\n3258: $$\n3259: \n3260: **Justification:** Three-sigma safety buffer, moderate boundary stiffness.\n3261: \n3262: **Expected performance:**\n3263: \n3264: $$\n3265: \\kappa_{\\text{total}}^* = \\min\\left(3\\lambda_{\\min}, 2\\lambda_{\\min}, \\frac{c^2\\lambda_{\\min}}{2}\\right) = \\frac{c^2\\lambda_{\\min}}{2} \\approx 0.125\\lambda_{\\min}\n3266: $$\n3267: \n3268: **Mixing time:**\n3269: $$",
      "metadata": {
        "label": "thm-closed-form-optimum"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "3199: **Problem:** Given landscape parameters $(\\lambda_{\\min}, \\lambda_{\\max}, d)$ and target exploration width $V_{\\text{target}}$, compute optimal parameters assuming no constraints.\n3200: \n3201: :::{prf:theorem} Closed-Form Balanced Optimum\n3202: :label: thm-closed-form-optimum\n3203: \n3204: For the unconstrained optimization problem, the optimal parameters are:\n3205: \n3206: **Step 1: Friction from landscape**\n3207: $$\n3208: \\gamma^* = \\lambda_{\\min}\n3209: $$\n3210: \n3211: **Justification:** Maximizes $\\kappa_W = c^2\\gamma/(1 + \\gamma/\\lambda_{\\min})$, which is optimal when $\\gamma = \\lambda_{\\min}$.\n3212: \n3213: **Step 2: Cloning rate from balance**\n3214: $$\n3215: \\lambda^* = \\frac{2\\gamma^*}{c_{\\text{fit}}} \\approx \\frac{2\\lambda_{\\min}}{0.65} \\approx 3\\lambda_{\\min}\n3216: $$\n3217: \n3218: **Justification:** Achieves $\\kappa_x = \\lambda c_{\\text{fit}} = 2\\gamma = \\kappa_v$ (balanced two-way tie).\n3219: \n3220: **Step 3: Timestep from stability**\n3221: $$\n3222: \\tau^* = \\min\\left(\\frac{0.5}{\\gamma^*}, \\frac{1}{\\sqrt{\\lambda_{\\max}}}, 0.01\\right)\n3223: $$\n3224: \n3225: **Justification:** Ensures $\\gamma\\tau < 0.5$ and $\\sqrt{\\lambda_{\\max}}\\tau < 1$ for BAOAB stability.\n3226: \n3227: **Step 4: Exploration noise from target**\n3228: $$\n3229: \\sigma_v^* = \\sqrt{\\gamma^* \\cdot V_{\\text{target}}}\n3230: $$\n3231: \n3232: **Justification:** Equilibrium variance is $V_{\\text{eq}} \\sim \\sigma_v^2/\\gamma$, so $\\sigma_v = \\sqrt{\\gamma V_{\\text{eq}}}$.\n3233: \n3234: **Step 5: Position jitter from crossover**\n3235: $$\n3236: \\sigma_x^* = \\frac{\\sigma_v^* \\tau^*}{\\sqrt{\\gamma^*}}\n3237: $$\n3238: \n3239: **Justification:** This is the crossover point where jitter equals kinetic diffusion.\n3240: \n3241: **Step 6: Geometric parameters**\n3242: $$\n3243: \\lambda_{\\text{alg}}^* = \\frac{(\\sigma_x^*)^2}{(\\sigma_v^*)^2}, \\quad \\epsilon_c^* = \\sigma_x^*\n3244: $$\n3245: \n3246: **Justification:** Balances position and velocity in pairing metric.\n3247: \n3248: **Step 7: Restitution coefficient**\n3249: $$\n3250: \\alpha_{\\text{rest}}^* = \\sqrt{2 - \\frac{2\\gamma_{\\text{budget}}}{\\gamma^*}}\n3251: $$\n3252: \n3253: where $\\gamma_{\\text{budget}}$ is the available friction (typically $\\gamma_{\\text{budget}} = 1.5\\gamma^*$ for modest dissipation).\n3254: \n3255: **Step 8: Boundary parameters**\n3256: $$\n3257: d_{\\text{safe}}^* = 3\\sqrt{V_{\\text{target}}}, \\quad \\kappa_{\\text{wall}}^* = 10\\lambda_{\\min}\n3258: $$\n3259: \n3260: **Justification:** Three-sigma safety buffer, moderate boundary stiffness.\n3261: \n3262: **Expected performance:**\n3263: \n3264: $$\n3265: \\kappa_{\\text{total}}^* = \\min\\left(3\\lambda_{\\min}, 2\\lambda_{\\min}, \\frac{c^2\\lambda_{\\min}}{2}\\right) = \\frac{c^2\\lambda_{\\min}}{2} \\approx 0.125\\lambda_{\\min}\n3266: $$\n3267: \n3268: **Mixing time:**\n3269: $$\n3270: T_{\\text{mix}} = \\frac{5}{\\kappa_{\\text{total}}^*} = \\frac{40}{\\lambda_{\\min}}"
    },
    {
      "directive_type": "algorithm",
      "label": "alg-projected-gradient-ascent",
      "title": "Projected Gradient Ascent for Parameter Optimization",
      "start_line": 3299,
      "end_line": 3403,
      "header_lines": [
        3300
      ],
      "content_start": 3302,
      "content_end": 3402,
      "content": "3302: :label: alg-projected-gradient-ascent\n3303: \n3304: **Input:**\n3305: - Landscape: $(\\lambda_{\\min}, \\lambda_{\\max}, d)$\n3306: - Constraints: $(N_{\\max}, \\lambda_{\\max}, V_{\\max}, \\ldots)$\n3307: - Initial guess: $\\mathbf{P}_0$ (from closed-form solution)\n3308: \n3309: **Output:** Optimal parameters $\\mathbf{P}^*$, achieved rate $\\kappa_{\\text{total}}^*$\n3310: \n3311: **Algorithm:**\n3312: \n3313: ```python\n3314: def optimize_parameters_constrained(landscape, constraints, P_init, max_iter=100):\n3315:     P = P_init\n3316:     alpha = 0.1  # Step size\n3317: \n3318:     for iter in range(max_iter):\n3319:         # Step 1: Compute current rates\n3320:         kappa = compute_rates(P, landscape)\n3321:         #   kappa = [kappa_x(P), kappa_v(P), kappa_W(P), kappa_b(P)]\n3322: \n3323:         kappa_total = min(kappa)\n3324: \n3325:         # Step 2: Identify active constraints (rates equal to minimum)\n3326:         active = [i for i in range(4) if abs(kappa[i] - kappa_total) < 1e-6]\n3327: \n3328:         # Step 3: Compute subgradient\n3329:         if len(active) == 1:\n3330:             # Unique minimum: gradient is M_kappa[active[0], :]\n3331:             grad = M_kappa[active[0], :]\n3332:         else:\n3333:             # Multiple minima: convex combination of gradients\n3334:             grad = mean(M_kappa[active, :], axis=0)\n3335: \n3336:         # Step 4: Gradient ascent step\n3337:         P_new = P * (1 + alpha * grad)  # Multiplicative update\n3338: \n3339:         # Step 5: Project onto feasible set\n3340:         P_new = project_onto_constraints(P_new, constraints)\n3341: \n3342:         # Step 6: Check convergence\n3343:         rel_change = norm(P_new - P) / norm(P)\n3344:         if rel_change < 1e-4:\n3345:             break\n3346: \n3347:         # Step 7: Adaptive step size\n3348:         kappa_new = min(compute_rates(P_new, landscape))\n3349:         if kappa_new > kappa_total:\n3350:             alpha *= 1.2  # Increase step (things are improving)\n3351:         else:\n3352:             alpha *= 0.5  # Decrease step (overshot)\n3353:             P_new = P     # Reject step\n3354: \n3355:         P = P_new\n3356: \n3357:     return P, kappa_total\n3358: ```\n3359: \n3360: **Helper functions:**\n3361: \n3362: ```python\n3363: def compute_rates(P, landscape):\n3364:     \"\"\"Compute all four rates from parameters.\"\"\"\n3365:     lambda_val = P['lambda']\n3366:     gamma = P['gamma']\n3367:     tau = P['tau']\n3368:     lambda_alg = P['lambda_alg']\n3369:     epsilon_c = P['epsilon_c']\n3370:     kappa_wall = P['kappa_wall']\n3371: \n3372:     # Use formulas from Chapter 7\n3373:     c_fit = estimate_fitness_correlation(lambda_alg, epsilon_c)\n3374: \n3375:     kappa_x = lambda_val * c_fit * (1 - 0.1*tau)\n3376:     kappa_v = 2 * gamma * (1 - 0.1*tau)\n3377:     kappa_W = 0.5 * gamma / (1 + gamma/landscape['lambda_min'])\n3378:     kappa_b = min(lambda_val, kappa_wall + gamma)\n3379: \n3380:     return [kappa_x, kappa_v, kappa_W, kappa_b]\n3381: \n3382: def project_onto_constraints(P, constraints):\n3383:     \"\"\"Project parameters onto feasible set.\"\"\"\n3384:     P_proj = P.copy()\n3385: \n3386:     # Box constraints\n3387:     if 'N_max' in constraints:\n3388:         P_proj['N'] = min(P['N'], constraints['N_max'])\n3389:     if 'lambda_max' in constraints:\n3390:         P_proj['lambda'] = min(P['lambda'], constraints['lambda_max'])\n3391: \n3392:     # Stability constraints\n3393:     P_proj['tau'] = min(P['tau'], 0.5/P['gamma'])\n3394:     P_proj['tau'] = min(P_proj['tau'], 1/sqrt(constraints['lambda_max']))\n3395: \n3396:     # Positivity\n3397:     for key in P_proj:\n3398:         P_proj[key] = max(P_proj[key], 1e-6)\n3399: \n3400:     # Restitution bound\n3401:     P_proj['alpha_rest'] = clip(P['alpha_rest'], 0, 1)\n3402: ",
      "metadata": {
        "label": "alg-projected-gradient-ascent"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "3299: When constraints are active (e.g., limited memory $N \\leq N_{\\max}$ or communication budget $\\lambda \\leq \\lambda_{\\max}$), we need iterative optimization.\n3300: \n3301: :::{prf:algorithm} Projected Gradient Ascent for Parameter Optimization\n3302: :label: alg-projected-gradient-ascent\n3303: \n3304: **Input:**\n3305: - Landscape: $(\\lambda_{\\min}, \\lambda_{\\max}, d)$\n3306: - Constraints: $(N_{\\max}, \\lambda_{\\max}, V_{\\max}, \\ldots)$\n3307: - Initial guess: $\\mathbf{P}_0$ (from closed-form solution)\n3308: \n3309: **Output:** Optimal parameters $\\mathbf{P}^*$, achieved rate $\\kappa_{\\text{total}}^*$\n3310: \n3311: **Algorithm:**\n3312: \n3313: ```python\n3314: def optimize_parameters_constrained(landscape, constraints, P_init, max_iter=100):\n3315:     P = P_init\n3316:     alpha = 0.1  # Step size\n3317: \n3318:     for iter in range(max_iter):\n3319:         # Step 1: Compute current rates\n3320:         kappa = compute_rates(P, landscape)\n3321:         #   kappa = [kappa_x(P), kappa_v(P), kappa_W(P), kappa_b(P)]\n3322: \n3323:         kappa_total = min(kappa)\n3324: \n3325:         # Step 2: Identify active constraints (rates equal to minimum)\n3326:         active = [i for i in range(4) if abs(kappa[i] - kappa_total) < 1e-6]\n3327: \n3328:         # Step 3: Compute subgradient\n3329:         if len(active) == 1:\n3330:             # Unique minimum: gradient is M_kappa[active[0], :]\n3331:             grad = M_kappa[active[0], :]\n3332:         else:\n3333:             # Multiple minima: convex combination of gradients\n3334:             grad = mean(M_kappa[active, :], axis=0)\n3335: \n3336:         # Step 4: Gradient ascent step\n3337:         P_new = P * (1 + alpha * grad)  # Multiplicative update\n3338: \n3339:         # Step 5: Project onto feasible set\n3340:         P_new = project_onto_constraints(P_new, constraints)\n3341: \n3342:         # Step 6: Check convergence\n3343:         rel_change = norm(P_new - P) / norm(P)\n3344:         if rel_change < 1e-4:\n3345:             break\n3346: \n3347:         # Step 7: Adaptive step size\n3348:         kappa_new = min(compute_rates(P_new, landscape))\n3349:         if kappa_new > kappa_total:\n3350:             alpha *= 1.2  # Increase step (things are improving)\n3351:         else:\n3352:             alpha *= 0.5  # Decrease step (overshot)\n3353:             P_new = P     # Reject step\n3354: \n3355:         P = P_new\n3356: \n3357:     return P, kappa_total\n3358: ```\n3359: \n3360: **Helper functions:**\n3361: \n3362: ```python\n3363: def compute_rates(P, landscape):\n3364:     \"\"\"Compute all four rates from parameters.\"\"\"\n3365:     lambda_val = P['lambda']\n3366:     gamma = P['gamma']\n3367:     tau = P['tau']\n3368:     lambda_alg = P['lambda_alg']\n3369:     epsilon_c = P['epsilon_c']\n3370:     kappa_wall = P['kappa_wall']\n3371: \n3372:     # Use formulas from Chapter 7\n3373:     c_fit = estimate_fitness_correlation(lambda_alg, epsilon_c)\n3374: \n3375:     kappa_x = lambda_val * c_fit * (1 - 0.1*tau)\n3376:     kappa_v = 2 * gamma * (1 - 0.1*tau)\n3377:     kappa_W = 0.5 * gamma / (1 + gamma/landscape['lambda_min'])\n3378:     kappa_b = min(lambda_val, kappa_wall + gamma)\n3379: \n3380:     return [kappa_x, kappa_v, kappa_W, kappa_b]\n3381: \n3382: def project_onto_constraints(P, constraints):\n3383:     \"\"\"Project parameters onto feasible set.\"\"\"\n3384:     P_proj = P.copy()\n3385: \n3386:     # Box constraints\n3387:     if 'N_max' in constraints:\n3388:         P_proj['N'] = min(P['N'], constraints['N_max'])\n3389:     if 'lambda_max' in constraints:\n3390:         P_proj['lambda'] = min(P['lambda'], constraints['lambda_max'])\n3391: \n3392:     # Stability constraints\n3393:     P_proj['tau'] = min(P['tau'], 0.5/P['gamma'])\n3394:     P_proj['tau'] = min(P_proj['tau'], 1/sqrt(constraints['lambda_max']))\n3395: \n3396:     # Positivity\n3397:     for key in P_proj:\n3398:         P_proj[key] = max(P_proj[key], 1e-6)\n3399: \n3400:     # Restitution bound\n3401:     P_proj['alpha_rest'] = clip(P['alpha_rest'], 0, 1)\n3402: \n3403:     return P_proj"
    },
    {
      "directive_type": "definition",
      "label": "def-pareto-optimality",
      "title": "Pareto Optimality in Parameter Space",
      "start_line": 3411,
      "end_line": 3420,
      "header_lines": [
        3412
      ],
      "content_start": 3414,
      "content_end": 3419,
      "content": "3414: :label: def-pareto-optimality\n3415: \n3416: A parameter choice $\\mathbf{P}^*$ is **Pareto optimal** if there exists no other $\\mathbf{P}$ such that:\n3417: - $\\kappa_{\\text{total}}(\\mathbf{P}) \\geq \\kappa_{\\text{total}}(\\mathbf{P}^*)$ (at least as fast)\n3418: - $\\text{Cost}(\\mathbf{P}) \\leq \\text{Cost}(\\mathbf{P}^*)$ (at most as expensive)\n3419: - At least one inequality is strict",
      "metadata": {
        "label": "def-pareto-optimality"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "3411: When multiple objectives compete (speed vs. cost vs. robustness), compute the Pareto frontier.\n3412: \n3413: :::{prf:definition} Pareto Optimality in Parameter Space\n3414: :label: def-pareto-optimality\n3415: \n3416: A parameter choice $\\mathbf{P}^*$ is **Pareto optimal** if there exists no other $\\mathbf{P}$ such that:\n3417: - $\\kappa_{\\text{total}}(\\mathbf{P}) \\geq \\kappa_{\\text{total}}(\\mathbf{P}^*)$ (at least as fast)\n3418: - $\\text{Cost}(\\mathbf{P}) \\leq \\text{Cost}(\\mathbf{P}^*)$ (at most as expensive)\n3419: - At least one inequality is strict\n3420: "
    },
    {
      "directive_type": "algorithm",
      "label": "alg-adaptive-tuning",
      "title": "Adaptive Parameter Tuning",
      "start_line": 3488,
      "end_line": 3580,
      "header_lines": [
        3489
      ],
      "content_start": 3491,
      "content_end": 3579,
      "content": "3491: :label: alg-adaptive-tuning\n3492: \n3493: **Input:**\n3494: - Swarm system (black box)\n3495: - Initial parameter guess $\\mathbf{P}_0$\n3496: - Measurement window $T_{\\text{sample}}$\n3497: \n3498: **Output:** Tuned parameters $\\mathbf{P}_{\\text{tuned}}$\n3499: \n3500: **Algorithm:**\n3501: \n3502: ```python\n3503: def adaptive_tuning(swarm_system, P_init, n_iterations=10, T_sample=1000):\n3504:     \"\"\"\n3505:     Iteratively improve parameters using empirical measurements.\n3506:     \"\"\"\n3507:     P = P_init\n3508: \n3509:     for iter in range(n_iterations):\n3510:         # Step 1: Run swarm for T_sample steps\n3511:         trajectory = swarm_system.run(P, steps=T_sample)\n3512: \n3513:         # Step 2: Estimate rates from trajectory\n3514:         kappa_emp = estimate_rates_from_trajectory(trajectory)\n3515:         #   Returns: [kappa_x_emp, kappa_v_emp, kappa_W_emp, kappa_b_emp]\n3516: \n3517:         # Step 3: Identify bottleneck\n3518:         i_bottleneck = argmin(kappa_emp)\n3519:         kappa_min = kappa_emp[i_bottleneck]\n3520: \n3521:         bottleneck_names = ['Position', 'Velocity', 'Wasserstein', 'Boundary']\n3522:         print(f\"Iter {iter}: Bottleneck = {bottleneck_names[i_bottleneck]}, \"\n3523:               f\"\u03ba = {kappa_min:.4f}\")\n3524: \n3525:         # Step 4: Compute adjustment direction using sensitivity matrix\n3526:         grad = M_kappa[i_bottleneck, :]  # Which parameters affect bottleneck?\n3527: \n3528:         # Step 5: Adaptive step size based on gap to target\n3529:         # Estimate achievable rate from landscape (if known roughly)\n3530:         kappa_target = estimate_achievable_rate(swarm_system)\n3531:         gap = kappa_target - kappa_min\n3532: \n3533:         if gap > 0:\n3534:             alpha = 0.2 * gap / kappa_min  # Proportional adjustment\n3535:         else:\n3536:             alpha = 0.05  # Small refinement\n3537: \n3538:         # Step 6: Update parameters\n3539:         P_new = {}\n3540:         for j, param_name in enumerate(param_names):\n3541:             P_new[param_name] = P[param_name] * (1 + alpha * grad[j])\n3542: \n3543:         # Step 7: Project onto feasible set\n3544:         P_new = project_onto_constraints(P_new, get_system_constraints())\n3545: \n3546:         # Step 8: Validate improvement\n3547:         trajectory_new = swarm_system.run(P_new, steps=T_sample//2)\n3548:         kappa_new = estimate_rates_from_trajectory(trajectory_new)\n3549: \n3550:         if min(kappa_new) > min(kappa_emp):\n3551:             P = P_new  # Accept\n3552:             print(f\"  \u2192 Accepted: \u03ba_new = {min(kappa_new):.4f}\")\n3553:         else:\n3554:             alpha *= 0.5  # Reduce step size, try again\n3555:             print(f\"  \u2192 Rejected: Reducing step size\")\n3556: \n3557:     return P\n3558: \n3559: def estimate_rates_from_trajectory(trajectory):\n3560:     \"\"\"\n3561:     Extract empirical convergence rates from swarm trajectory.\n3562: \n3563:     Method: Fit exponential decay to Lyapunov components:\n3564:         V_i(t) \u2248 C_i/\u03ba_i + (V_i(0) - C_i/\u03ba_i) * exp(-\u03ba_i * t)\n3565: \n3566:     Extract \u03ba_i from exponential fit.\n3567:     \"\"\"\n3568:     # Extract Lyapunov components over time\n3569:     V_Var_x = [compute_variance(traj.positions) for traj in trajectory]\n3570:     V_Var_v = [compute_variance(traj.velocities) for traj in trajectory]\n3571:     V_W = [compute_wasserstein(traj, reference) for traj in trajectory]\n3572:     W_b = [compute_boundary_potential(traj) for traj in trajectory]\n3573: \n3574:     # Fit exponential decay: V(t) = C + A * exp(-kappa * t)\n3575:     kappa_x = fit_exponential_rate(V_Var_x, trajectory.times)\n3576:     kappa_v = fit_exponential_rate(V_Var_v, trajectory.times)\n3577:     kappa_W = fit_exponential_rate(V_W, trajectory.times)\n3578:     kappa_b = fit_exponential_rate(W_b, trajectory.times)\n3579: ",
      "metadata": {
        "label": "alg-adaptive-tuning"
      },
      "section": "## 6. Spectral Analysis of Parameter Coupling",
      "raw_directive": "3488: When the landscape is unknown or model assumptions are violated, adapt parameters based on measured convergence.\n3489: \n3490: :::{prf:algorithm} Adaptive Parameter Tuning\n3491: :label: alg-adaptive-tuning\n3492: \n3493: **Input:**\n3494: - Swarm system (black box)\n3495: - Initial parameter guess $\\mathbf{P}_0$\n3496: - Measurement window $T_{\\text{sample}}$\n3497: \n3498: **Output:** Tuned parameters $\\mathbf{P}_{\\text{tuned}}$\n3499: \n3500: **Algorithm:**\n3501: \n3502: ```python\n3503: def adaptive_tuning(swarm_system, P_init, n_iterations=10, T_sample=1000):\n3504:     \"\"\"\n3505:     Iteratively improve parameters using empirical measurements.\n3506:     \"\"\"\n3507:     P = P_init\n3508: \n3509:     for iter in range(n_iterations):\n3510:         # Step 1: Run swarm for T_sample steps\n3511:         trajectory = swarm_system.run(P, steps=T_sample)\n3512: \n3513:         # Step 2: Estimate rates from trajectory\n3514:         kappa_emp = estimate_rates_from_trajectory(trajectory)\n3515:         #   Returns: [kappa_x_emp, kappa_v_emp, kappa_W_emp, kappa_b_emp]\n3516: \n3517:         # Step 3: Identify bottleneck\n3518:         i_bottleneck = argmin(kappa_emp)\n3519:         kappa_min = kappa_emp[i_bottleneck]\n3520: \n3521:         bottleneck_names = ['Position', 'Velocity', 'Wasserstein', 'Boundary']\n3522:         print(f\"Iter {iter}: Bottleneck = {bottleneck_names[i_bottleneck]}, \"\n3523:               f\"\u03ba = {kappa_min:.4f}\")\n3524: \n3525:         # Step 4: Compute adjustment direction using sensitivity matrix\n3526:         grad = M_kappa[i_bottleneck, :]  # Which parameters affect bottleneck?\n3527: \n3528:         # Step 5: Adaptive step size based on gap to target\n3529:         # Estimate achievable rate from landscape (if known roughly)\n3530:         kappa_target = estimate_achievable_rate(swarm_system)\n3531:         gap = kappa_target - kappa_min\n3532: \n3533:         if gap > 0:\n3534:             alpha = 0.2 * gap / kappa_min  # Proportional adjustment\n3535:         else:\n3536:             alpha = 0.05  # Small refinement\n3537: \n3538:         # Step 6: Update parameters\n3539:         P_new = {}\n3540:         for j, param_name in enumerate(param_names):\n3541:             P_new[param_name] = P[param_name] * (1 + alpha * grad[j])\n3542: \n3543:         # Step 7: Project onto feasible set\n3544:         P_new = project_onto_constraints(P_new, get_system_constraints())\n3545: \n3546:         # Step 8: Validate improvement\n3547:         trajectory_new = swarm_system.run(P_new, steps=T_sample//2)\n3548:         kappa_new = estimate_rates_from_trajectory(trajectory_new)\n3549: \n3550:         if min(kappa_new) > min(kappa_emp):\n3551:             P = P_new  # Accept\n3552:             print(f\"  \u2192 Accepted: \u03ba_new = {min(kappa_new):.4f}\")\n3553:         else:\n3554:             alpha *= 0.5  # Reduce step size, try again\n3555:             print(f\"  \u2192 Rejected: Reducing step size\")\n3556: \n3557:     return P\n3558: \n3559: def estimate_rates_from_trajectory(trajectory):\n3560:     \"\"\"\n3561:     Extract empirical convergence rates from swarm trajectory.\n3562: \n3563:     Method: Fit exponential decay to Lyapunov components:\n3564:         V_i(t) \u2248 C_i/\u03ba_i + (V_i(0) - C_i/\u03ba_i) * exp(-\u03ba_i * t)\n3565: \n3566:     Extract \u03ba_i from exponential fit.\n3567:     \"\"\"\n3568:     # Extract Lyapunov components over time\n3569:     V_Var_x = [compute_variance(traj.positions) for traj in trajectory]\n3570:     V_Var_v = [compute_variance(traj.velocities) for traj in trajectory]\n3571:     V_W = [compute_wasserstein(traj, reference) for traj in trajectory]\n3572:     W_b = [compute_boundary_potential(traj) for traj in trajectory]\n3573: \n3574:     # Fit exponential decay: V(t) = C + A * exp(-kappa * t)\n3575:     kappa_x = fit_exponential_rate(V_Var_x, trajectory.times)\n3576:     kappa_v = fit_exponential_rate(V_Var_v, trajectory.times)\n3577:     kappa_W = fit_exponential_rate(V_W, trajectory.times)\n3578:     kappa_b = fit_exponential_rate(W_b, trajectory.times)\n3579: \n3580:     return [kappa_x, kappa_v, kappa_W, kappa_b]"
    }
  ],
  "validation": {
    "ok": true,
    "errors": []
  }
}