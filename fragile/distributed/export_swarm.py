import copy
from typing import Callable, Tuple

import numpy
import ray

from fragile.core.base_classes import BaseWrapper
from fragile.core.functions import cross_fai_iteration
from fragile.core.states import States
from fragile.core.swarm import Swarm
from fragile.core.utils import float_type, random_state, Scalar, StateDict


class ExportedWalkers(States):
    def __init__(self, batch_size: int):
        self.id_walkers = None
        self.rewards = None
        self.observs = None
        self.states = None
        super(ExportedWalkers, self).__init__(
            batch_size=batch_size, state_dict=self.get_params_dict()
        )

    def get_params_dict(self) -> StateDict:
        """Return a dictionary containing the param_dict to build an instance \
        of States that can handle all the data generated by the :class:`Walkers`.
        """
        params = {
            "id_walkers": {"dtype": numpy.int64},
            "rewards": {"dtype": float_type},
            "observs": {"dtype": float_type},
            "states": {"dtype": float_type},
        }
        return params

    def get_best_index(self, minimize: bool) -> int:
        return self.rewards.argmin() if minimize else self.rewards.argmax()

    def get_best_reward(self, minimize: bool) -> Scalar:
        return self.rewards.min() if minimize else self.rewards.max()


class ExportSwarm(BaseWrapper):
    def __init__(
        self,
        swarm: Swarm,
        n_import: int = 2,
        n_export: int = 2,
        export_best: bool = True,
        import_best: bool = True,
    ):
        self.n_import = n_import
        self.n_export = n_export
        self._export_best = export_best
        self._import_best = import_best
        super(ExportSwarm, self).__init__(data=swarm, name="swarm")

    def run_exchange_step(self, walkers: ExportedWalkers) -> ExportedWalkers:
        self.import_walkers(walkers)
        self.run_step()
        return self.export_walkers()

    def export_walkers(self) -> ExportedWalkers:
        if self.swarm.walkers.states.end_condition.all():  # Do not export dead walkers
            return ExportedWalkers(batch_size=0)
        indexes = self._get_export_index()
        walkers = self._create_export_walkers(indexes)
        return walkers

    def import_walkers(self, walkers: ExportedWalkers) -> None:
        if len(walkers) == 0:  # Do not import dead walkers
            return
        self.merge_walkers(walkers)
        if self._import_best:
            self.import_best(walkers)

    def merge_walkers(self, walkers: ExportedWalkers):
        local_ix, import_ix = self._get_merge_indexes(walkers)
        compas_ix, will_clone = self._cross_fai_iteration(local_ix, import_ix, walkers)
        self._clone_to_imported(compas_ix, will_clone, local_ix, import_ix, walkers)

    def import_best(self, walkers: ExportedWalkers):
        if self._imported_best_is_better(walkers):
            best_ix = walkers.get_best_index(self.swarm.walkers.minimize)
            # TODO (guillemdb): Check if deepcopy is really necessary
            best_reward = copy.deepcopy(walkers.rewards[best_ix])
            best_state = copy.deepcopy(walkers.states[best_ix])
            best_obs = copy.deepcopy(walkers.observs[best_ix])
            best_id = copy.deepcopy(walkers.id_walkers[best_ix])
            self.swarm.walkers.states.update(
                best_reward=best_reward, best_state=best_state, best_obs=best_obs, best_id=best_id
            )
            self.swarm.walkers.fix_best()

    def _get_export_index(self) -> numpy.ndarray:
        index = self.swarm.walkers.get_alive_compas()[: self.n_export]
        if self._export_best:  # Force the best to be present if needed.
            best_ix = self.swarm.walkers.get_best_index()
            if best_ix not in index:
                index[0] = best_ix
        return index

    def _create_export_walkers(self, indexes: numpy.ndarray) -> ExportedWalkers:
        states = self.swarm.walkers.env_states.states[indexes]
        observs = self.swarm.walkers.env_states.observs[indexes]
        rewards = self.swarm.walkers.states.cum_rewards[indexes]
        id_walkers = self.swarm.walkers.states.id_walkers[indexes]
        walkers = ExportedWalkers(batch_size=len(indexes))
        walkers.update(states=states, observs=observs, rewards=rewards, id_walkers=id_walkers)
        return walkers

    def _imported_best_is_better(self, walkers: ExportedWalkers) -> bool:
        minim = self.swarm.walkers.minimize
        improves = (
            self.swarm.best_reward_found > walkers.get_best_reward(minim)
            if minim
            else self.swarm.best_reward_found < walkers.get_best_reward(minim)
        )
        return improves

    def _clone_to_imported(
        self,
        compas_ix: numpy.ndarray,
        will_clone: numpy.ndarray,
        local_ix: numpy.ndarray,
        import_ix: numpy.ndarray,
        walkers: ExportedWalkers,
    ) -> None:

        clone_ids = copy.deepcopy(walkers.id_walkers[import_ix][compas_ix][will_clone])
        clone_rewards = copy.deepcopy(walkers.rewards[import_ix][compas_ix][will_clone])
        clone_states = copy.deepcopy(walkers.states[import_ix][compas_ix][will_clone])
        clone_obs = copy.deepcopy(walkers.observs[import_ix][compas_ix][will_clone])
        # TODO: Find a better way to do this. Assignment does not work after double array indexing
        i = 0
        for (ix, wc) in zip(local_ix, will_clone):
            if wc:
                self.swarm.walkers.states.id_walkers[ix] = clone_ids[i]
                self.swarm.walkers.states.cum_rewards[ix] = clone_rewards[i]
                self.swarm.walkers.env_states.states[ix] = clone_states[i]
                self.swarm.walkers.env_states.observs[ix] = clone_obs[i]
                i += 1

    def _get_merge_indexes(self, walkers: ExportedWalkers) -> Tuple[numpy.ndarray, numpy.ndarray]:
        local_ix = random_state.choice(
            numpy.arange(len(self.swarm.walkers)), size=self.n_import, replace=False
        )
        if len(walkers) <= self.n_import:
            import_ix = random_state.choice(
                numpy.arange(len(walkers)), size=self.n_import, replace=False
            )
        else:
            import_ix = random_state.choice(
                numpy.arange(len(walkers)), size=self.n_import, replace=True
            )
        return local_ix, import_ix

    def _cross_fai_iteration(
        self, local_ix: numpy.ndarray, import_ix: numpy.ndarray, walkers: ExportedWalkers
    ) -> Tuple[numpy.ndarray, numpy.ndarray]:
        local_obs = self.swarm.walkers.env_states.observs[local_ix]
        local_rewards = self.swarm.walkers.states.cum_rewards[local_ix]
        local_ends = self.swarm.walkers.states.end_condition[local_ix]
        import_obs = walkers.observs[import_ix]
        import_rewards = walkers.rewards[import_ix]
        compas_ix, will_clone = cross_fai_iteration(
            host_observs=local_obs,
            host_rewards=local_rewards,
            host_ends=local_ends,
            ext_observs=import_obs,
            ext_rewards=import_rewards,
            dist_coef=self.swarm.walkers.dist_scale,
            reward_coef=self.swarm.walkers.reward_scale,
            distance_function=self.swarm.walkers.distance_function,
        )
        return compas_ix, will_clone
