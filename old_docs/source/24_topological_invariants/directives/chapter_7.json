{
  "chapter_index": 7,
  "section_id": "## Part 7: Computational Methods and Libraries",
  "directive_count": 3,
  "hints": [
    {
      "directive_type": "remark",
      "label": "rem-tda-libraries",
      "title": "Recommended Libraries",
      "start_line": 1015,
      "end_line": 1045,
      "header_lines": [
        1016
      ],
      "content_start": 1018,
      "content_end": 1044,
      "content": "1018: :label: rem-tda-libraries\n1019: \n1020: **GUDHI** (Geometry Understanding in Higher Dimensions):\n1021: - Comprehensive persistent homology, Rips complexes, alpha complexes\n1022: - Python bindings to optimized C++ core\n1023: - Installation: `pip install gudhi`\n1024: - Documentation: [gudhi.inria.fr](http://gudhi.inria.fr)\n1025: \n1026: **Ripser**:\n1027: - Ultra-fast persistent homology (sparse matrix optimizations)\n1028: - Python bindings: `pip install ripser`\n1029: - Ideal for large point clouds ($N > 1000$)\n1030: - GitHub: [Ripser](https://github.com/scikit-tda/ripser.py)\n1031: \n1032: **scikit-tda**:\n1033: - High-level TDA toolkit built on Ripser\n1034: - Includes visualization, preprocessing, and machine learning integration\n1035: - Installation: `pip install scikit-tda`\n1036: - Includes **persim** for persistence diagram metrics\n1037: \n1038: **Giotto-tda**:\n1039: - TDA for time series and machine learning pipelines\n1040: - scikit-learn compatible\n1041: - Installation: `pip install giotto-tda`\n1042: \n1043: **Dionysus 2**:\n1044: - Zigzag persistence, multi-parameter persistence",
      "metadata": {
        "label": "rem-tda-libraries"
      },
      "section": "## Part 7: Computational Methods and Libraries",
      "references": [],
      "raw_directive": "1015: ### 7.1. Python Libraries for TDA\n1016: \n1017: :::{prf:remark} Recommended Libraries\n1018: :label: rem-tda-libraries\n1019: \n1020: **GUDHI** (Geometry Understanding in Higher Dimensions):\n1021: - Comprehensive persistent homology, Rips complexes, alpha complexes\n1022: - Python bindings to optimized C++ core\n1023: - Installation: `pip install gudhi`\n1024: - Documentation: [gudhi.inria.fr](http://gudhi.inria.fr)\n1025: \n1026: **Ripser**:\n1027: - Ultra-fast persistent homology (sparse matrix optimizations)\n1028: - Python bindings: `pip install ripser`\n1029: - Ideal for large point clouds ($N > 1000$)\n1030: - GitHub: [Ripser](https://github.com/scikit-tda/ripser.py)\n1031: \n1032: **scikit-tda**:\n1033: - High-level TDA toolkit built on Ripser\n1034: - Includes visualization, preprocessing, and machine learning integration\n1035: - Installation: `pip install scikit-tda`\n1036: - Includes **persim** for persistence diagram metrics\n1037: \n1038: **Giotto-tda**:\n1039: - TDA for time series and machine learning pipelines\n1040: - scikit-learn compatible\n1041: - Installation: `pip install giotto-tda`\n1042: \n1043: **Dionysus 2**:\n1044: - Zigzag persistence, multi-parameter persistence\n1045: - Python bindings: `pip install dionysus`"
    },
    {
      "directive_type": "algorithm",
      "label": "alg-tda-pipeline",
      "title": "TDA Pipeline for Fragile Gas",
      "start_line": 1049,
      "end_line": 1144,
      "header_lines": [
        1050
      ],
      "content_start": 1052,
      "content_end": 1143,
      "content": "1052: :label: alg-tda-pipeline\n1053: \n1054: **Input**: Swarm trajectory $\\{S_t\\}_{t=0}^T$ where $S_t = \\{x_1(t), \\ldots, x_N(t)\\}$\n1055: \n1056: **Output**: Persistence diagrams, bottleneck distances, topological features\n1057: \n1058: ```python\n1059: import numpy as np\n1060: from ripser import ripser\n1061: from persim import plot_diagrams, bottleneck\n1062: import gudhi\n1063: \n1064: def compute_tda_features(trajectory, max_radius=1.0, max_dimension=2):\n1065:     \"\"\"\n1066:     Compute topological data analysis features for swarm trajectory.\n1067: \n1068:     Parameters\n1069:     ----------\n1070:     trajectory : ndarray, shape (T, N, d)\n1071:         Walker positions over time\n1072:     max_radius : float\n1073:         Maximum filtration radius\n1074:     max_dimension : int\n1075:         Maximum homology dimension to compute\n1076: \n1077:     Returns\n1078:     -------\n1079:     diagrams : list of ndarrays\n1080:         Persistence diagrams for each timestep\n1081:     features : dict\n1082:         Topological feature summary\n1083:     \"\"\"\n1084:     T, N, d = trajectory.shape\n1085:     diagrams = []\n1086: \n1087:     for t in range(T):\n1088:         # Get walker positions at time t\n1089:         positions = trajectory[t]  # shape (N, d)\n1090: \n1091:         # Compute persistent homology using Ripser\n1092:         result = ripser(\n1093:             positions,\n1094:             maxdim=max_dimension,\n1095:             thresh=max_radius,\n1096:             coeff=2  # Use Z/2Z coefficients: much faster (bitwise XOR operations)\n1097:             # but loses torsion information (e.g., cannot distinguish Klein bottle\n1098:             # from torus). For counting holes (Betti numbers), this is sufficient.\n1099:         )\n1100:         diagrams.append(result['dgms'])\n1101: \n1102:     # Compute topological features\n1103:     features = {\n1104:         'betti_0': [count_features(d[0]) for d in diagrams],\n1105:         'betti_1': [count_features(d[1]) for d in diagrams],\n1106:         'persistence_entropy': [entropy(d[1]) for d in diagrams],\n1107:         'max_persistence': [max_lifetime(d[1]) for d in diagrams]\n1108:     }\n1109: \n1110:     return diagrams, features\n1111: \n1112: def count_features(diagram, threshold=0.1):\n1113:     \"\"\"Count persistent features above threshold.\"\"\"\n1114:     if len(diagram) == 0:\n1115:         return 0\n1116:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1117:     return np.sum(lifetimes > threshold)\n1118: \n1119: def entropy(diagram):\n1120:     \"\"\"Compute persistent entropy.\"\"\"\n1121:     if len(diagram) == 0:\n1122:         return 0.0\n1123:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1124:     lifetimes = lifetimes[np.isfinite(lifetimes)]\n1125:     if len(lifetimes) == 0:\n1126:         return 0.0\n1127:     lifetimes = lifetimes / np.sum(lifetimes)\n1128:     return -np.sum(lifetimes * np.log(lifetimes + 1e-12))\n1129: \n1130: def max_lifetime(diagram):\n1131:     \"\"\"Maximum persistence (longest-lived feature).\"\"\"\n1132:     if len(diagram) == 0:\n1133:         return 0.0\n1134:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1135:     finite_lifetimes = lifetimes[np.isfinite(lifetimes)]\n1136:     # Handle case where all classes are essential (infinite death)\n1137:     if finite_lifetimes.size == 0:\n1138:         return float('inf')  # All features are essential\n1139:     return np.max(finite_lifetimes)\n1140: ```\n1141: \n1142: **Integration points**:\n1143: 1. **SwarmState extension**: Add TDA features to swarm metadata",
      "metadata": {
        "label": "alg-tda-pipeline"
      },
      "section": "## Part 7: Computational Methods and Libraries",
      "references": [],
      "raw_directive": "1049: ### 7.2. Integration with Fragile Framework\n1050: \n1051: :::{prf:algorithm} TDA Pipeline for Fragile Gas\n1052: :label: alg-tda-pipeline\n1053: \n1054: **Input**: Swarm trajectory $\\{S_t\\}_{t=0}^T$ where $S_t = \\{x_1(t), \\ldots, x_N(t)\\}$\n1055: \n1056: **Output**: Persistence diagrams, bottleneck distances, topological features\n1057: \n1058: ```python\n1059: import numpy as np\n1060: from ripser import ripser\n1061: from persim import plot_diagrams, bottleneck\n1062: import gudhi\n1063: \n1064: def compute_tda_features(trajectory, max_radius=1.0, max_dimension=2):\n1065:     \"\"\"\n1066:     Compute topological data analysis features for swarm trajectory.\n1067: \n1068:     Parameters\n1069:     ----------\n1070:     trajectory : ndarray, shape (T, N, d)\n1071:         Walker positions over time\n1072:     max_radius : float\n1073:         Maximum filtration radius\n1074:     max_dimension : int\n1075:         Maximum homology dimension to compute\n1076: \n1077:     Returns\n1078:     -------\n1079:     diagrams : list of ndarrays\n1080:         Persistence diagrams for each timestep\n1081:     features : dict\n1082:         Topological feature summary\n1083:     \"\"\"\n1084:     T, N, d = trajectory.shape\n1085:     diagrams = []\n1086: \n1087:     for t in range(T):\n1088:         # Get walker positions at time t\n1089:         positions = trajectory[t]  # shape (N, d)\n1090: \n1091:         # Compute persistent homology using Ripser\n1092:         result = ripser(\n1093:             positions,\n1094:             maxdim=max_dimension,\n1095:             thresh=max_radius,\n1096:             coeff=2  # Use Z/2Z coefficients: much faster (bitwise XOR operations)\n1097:             # but loses torsion information (e.g., cannot distinguish Klein bottle\n1098:             # from torus). For counting holes (Betti numbers), this is sufficient.\n1099:         )\n1100:         diagrams.append(result['dgms'])\n1101: \n1102:     # Compute topological features\n1103:     features = {\n1104:         'betti_0': [count_features(d[0]) for d in diagrams],\n1105:         'betti_1': [count_features(d[1]) for d in diagrams],\n1106:         'persistence_entropy': [entropy(d[1]) for d in diagrams],\n1107:         'max_persistence': [max_lifetime(d[1]) for d in diagrams]\n1108:     }\n1109: \n1110:     return diagrams, features\n1111: \n1112: def count_features(diagram, threshold=0.1):\n1113:     \"\"\"Count persistent features above threshold.\"\"\"\n1114:     if len(diagram) == 0:\n1115:         return 0\n1116:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1117:     return np.sum(lifetimes > threshold)\n1118: \n1119: def entropy(diagram):\n1120:     \"\"\"Compute persistent entropy.\"\"\"\n1121:     if len(diagram) == 0:\n1122:         return 0.0\n1123:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1124:     lifetimes = lifetimes[np.isfinite(lifetimes)]\n1125:     if len(lifetimes) == 0:\n1126:         return 0.0\n1127:     lifetimes = lifetimes / np.sum(lifetimes)\n1128:     return -np.sum(lifetimes * np.log(lifetimes + 1e-12))\n1129: \n1130: def max_lifetime(diagram):\n1131:     \"\"\"Maximum persistence (longest-lived feature).\"\"\"\n1132:     if len(diagram) == 0:\n1133:         return 0.0\n1134:     lifetimes = diagram[:, 1] - diagram[:, 0]\n1135:     finite_lifetimes = lifetimes[np.isfinite(lifetimes)]\n1136:     # Handle case where all classes are essential (infinite death)\n1137:     if finite_lifetimes.size == 0:\n1138:         return float('inf')  # All features are essential\n1139:     return np.max(finite_lifetimes)\n1140: ```\n1141: \n1142: **Integration points**:\n1143: 1. **SwarmState extension**: Add TDA features to swarm metadata\n1144: 2. **Visualization**: Use `fragile.shaolin` to plot persistence diagrams"
    },
    {
      "directive_type": "table",
      "label": "table-complexity",
      "title": "Complexity of Topological Invariants",
      "start_line": 1148,
      "end_line": 1167,
      "header_lines": [
        1149
      ],
      "content_start": 1151,
      "content_end": 1166,
      "content": "1151: :label: table-complexity\n1152: \n1153: | Invariant | Method | Complexity | Framework Status |\n1154: |-----------|--------|------------|------------------|\n1155: | $\\chi$ (Euler char.) | Delaunay count | $O(N)$ | \u26a0\ufe0f Computed (point cloud only; see \u00a7 1.1) |\n1156: | $\\beta_0$ (components) | DFS/Union-Find | $O(N + E)$ | \u2705 Computable from Fractal Set |\n1157: | $\\beta_1$ (cycles) | Cellular homology | $O(s^3)$ via Gaussian elimination over field; Smith Normal Form for $\\mathbb{Z}$ | \u26a0\ufe0f Requires cellular boundary operators |\n1158: | $\\beta_k$ ($k \\ge 2$) | Boundary matrix | $O(s^3)$ | \u26a0\ufe0f Requires full CW complex structure |\n1159: | Persistent $H_*$ | Ripser | $O(s^3)$ | \ud83d\udd27 External library; $s$ = #simplices (exp. in $N$) |\n1160: | $\\pi_1$ (fund. group) | Simplicial approx. | Exponential | \u274c Hard in general |\n1161: | Genus $g$ | From $\\chi$ + TDA | $O(1)$ given $\\chi$ | \u26a0\ufe0f Requires persistent homology for landscape |\n1162: | Chern numbers | Geometric charge | Not implemented | \u274c Plaquette holonomy defined; no Levi-Civita \u03b5-contraction |\n1163: \n1164: **Legend**:\n1165: - \u2705 Already computed or trivially computable\n1166: - \u26a0\ufe0f Feasible but requires additional computation",
      "metadata": {
        "label": "table-complexity"
      },
      "section": "## Part 7: Computational Methods and Libraries",
      "references": [],
      "raw_directive": "1148: ### 7.3. Computational Complexity Summary\n1149: \n1150: :::{prf:table} Complexity of Topological Invariants\n1151: :label: table-complexity\n1152: \n1153: | Invariant | Method | Complexity | Framework Status |\n1154: |-----------|--------|------------|------------------|\n1155: | $\\chi$ (Euler char.) | Delaunay count | $O(N)$ | \u26a0\ufe0f Computed (point cloud only; see \u00a7 1.1) |\n1156: | $\\beta_0$ (components) | DFS/Union-Find | $O(N + E)$ | \u2705 Computable from Fractal Set |\n1157: | $\\beta_1$ (cycles) | Cellular homology | $O(s^3)$ via Gaussian elimination over field; Smith Normal Form for $\\mathbb{Z}$ | \u26a0\ufe0f Requires cellular boundary operators |\n1158: | $\\beta_k$ ($k \\ge 2$) | Boundary matrix | $O(s^3)$ | \u26a0\ufe0f Requires full CW complex structure |\n1159: | Persistent $H_*$ | Ripser | $O(s^3)$ | \ud83d\udd27 External library; $s$ = #simplices (exp. in $N$) |\n1160: | $\\pi_1$ (fund. group) | Simplicial approx. | Exponential | \u274c Hard in general |\n1161: | Genus $g$ | From $\\chi$ + TDA | $O(1)$ given $\\chi$ | \u26a0\ufe0f Requires persistent homology for landscape |\n1162: | Chern numbers | Geometric charge | Not implemented | \u274c Plaquette holonomy defined; no Levi-Civita \u03b5-contraction |\n1163: \n1164: **Legend**:\n1165: - \u2705 Already computed or trivially computable\n1166: - \u26a0\ufe0f Feasible but requires additional computation\n1167: - \ud83d\udd27 Requires external library"
    }
  ],
  "validation": {
    "ok": true,
    "errors": []
  }
}