{
  "chapter_index": 8,
  "section_id": "## 8. Integration with the Fragile Framework",
  "directive_count": 2,
  "hints": [
    {
      "directive_type": "algorithm",
      "label": "alg-gas-with-online-triangulation",
      "title": "Gas Algorithm with Online Triangulation",
      "start_line": 900,
      "end_line": 961,
      "header_lines": [
        901
      ],
      "content_start": 903,
      "content_end": 960,
      "content": "903: :label: alg-gas-with-online-triangulation\n904: \n905: **Augmented Swarm State**:\n906: \n907: ```python\n908: @dataclass\n909: class SwarmStateWithTriangulation:\n910:     # Original swarm state\n911:     x: Tensor              # [N, d] positions\n912:     v: Tensor              # [N, d] velocities\n913:     reward: Tensor         # [N] rewards\n914:     virtual_reward: Tensor # [N] virtual rewards\n915: \n916:     # Geometric data structures (NEW)\n917:     DT: DelaunayTriangulation  # Maintained online\n918:     VT: VoronoiTessellation    # Dual of DT\n919: \n920:     # CST for tracking updates\n921:     CST: CausalSpacetimeTree\n922: ```\n923: \n924: **Modified Step Function**:\n925: \n926: ```python\n927: def step(self, state: SwarmStateWithTriangulation) -> SwarmStateWithTriangulation:\n928:     # 1. Standard Gas operators\n929:     state_after_kinetic = self.kinetic_operator(state)\n930:     state_after_clone = self.cloning_operator(state_after_kinetic)\n931: \n932:     # 2. Extract update information from CST\n933:     moved_walkers, cloned_walkers = extract_updates(\n934:         state.CST, state.x, state_after_clone.x\n935:     )\n936: \n937:     # 3. Update triangulation online (NEW)\n938:     DT_new = update_triangulation(\n939:         state.DT, moved_walkers, cloned_walkers\n940:     )\n941:     VT_new = update_voronoi(state.VT, DT_new)\n942: \n943:     # 4. Compute geometric quantities from updated triangulation\n944:     curvature = compute_curvature_from_DT(DT_new)\n945:     dimension = estimate_dimension_from_DT(DT_new)\n946: \n947:     # 5. Return updated state\n948:     return SwarmStateWithTriangulation(\n949:         x=state_after_clone.x,\n950:         v=state_after_clone.v,\n951:         reward=state_after_clone.reward,\n952:         virtual_reward=state_after_clone.virtual_reward,\n953:         DT=DT_new,\n954:         VT=VT_new,\n955:         CST=state_after_clone.CST\n956:     )\n957: ```\n958: \n959: **Key Changes**:\n960: - Triangulation is now **part of the state**, not recomputed from scratch",
      "metadata": {
        "label": "alg-gas-with-online-triangulation"
      },
      "section": "## 8. Integration with the Fragile Framework",
      "raw_directive": "900: ### 8.1 Modifications to Gas Algorithms\n901: \n902: :::{prf:algorithm} Gas Algorithm with Online Triangulation\n903: :label: alg-gas-with-online-triangulation\n904: \n905: **Augmented Swarm State**:\n906: \n907: ```python\n908: @dataclass\n909: class SwarmStateWithTriangulation:\n910:     # Original swarm state\n911:     x: Tensor              # [N, d] positions\n912:     v: Tensor              # [N, d] velocities\n913:     reward: Tensor         # [N] rewards\n914:     virtual_reward: Tensor # [N] virtual rewards\n915: \n916:     # Geometric data structures (NEW)\n917:     DT: DelaunayTriangulation  # Maintained online\n918:     VT: VoronoiTessellation    # Dual of DT\n919: \n920:     # CST for tracking updates\n921:     CST: CausalSpacetimeTree\n922: ```\n923: \n924: **Modified Step Function**:\n925: \n926: ```python\n927: def step(self, state: SwarmStateWithTriangulation) -> SwarmStateWithTriangulation:\n928:     # 1. Standard Gas operators\n929:     state_after_kinetic = self.kinetic_operator(state)\n930:     state_after_clone = self.cloning_operator(state_after_kinetic)\n931: \n932:     # 2. Extract update information from CST\n933:     moved_walkers, cloned_walkers = extract_updates(\n934:         state.CST, state.x, state_after_clone.x\n935:     )\n936: \n937:     # 3. Update triangulation online (NEW)\n938:     DT_new = update_triangulation(\n939:         state.DT, moved_walkers, cloned_walkers\n940:     )\n941:     VT_new = update_voronoi(state.VT, DT_new)\n942: \n943:     # 4. Compute geometric quantities from updated triangulation\n944:     curvature = compute_curvature_from_DT(DT_new)\n945:     dimension = estimate_dimension_from_DT(DT_new)\n946: \n947:     # 5. Return updated state\n948:     return SwarmStateWithTriangulation(\n949:         x=state_after_clone.x,\n950:         v=state_after_clone.v,\n951:         reward=state_after_clone.reward,\n952:         virtual_reward=state_after_clone.virtual_reward,\n953:         DT=DT_new,\n954:         VT=VT_new,\n955:         CST=state_after_clone.CST\n956:     )\n957: ```\n958: \n959: **Key Changes**:\n960: - Triangulation is now **part of the state**, not recomputed from scratch\n961: - CST provides the update information automatically"
    },
    {
      "directive_type": "definition",
      "label": "def-geometric-query-api",
      "title": "Geometric Query Interface",
      "start_line": 965,
      "end_line": 1022,
      "header_lines": [
        966
      ],
      "content_start": 968,
      "content_end": 1021,
      "content": "968: :label: def-geometric-query-api\n969: \n970: **Proposed API** for accessing geometric information:\n971: \n972: ```python\n973: class GeometricAnalyzer:\n974:     \"\"\"Provides geometric and topological queries on the maintained triangulation.\"\"\"\n975: \n976:     def __init__(self, state: SwarmStateWithTriangulation):\n977:         self.state = state\n978: \n979:     def curvature_at_walker(self, walker_id: int) -> float:\n980:         \"\"\"Ricci scalar curvature at a walker's position.\"\"\"\n981:         cell = self.state.VT.get_cell(walker_id)\n982:         return compute_ricci_scalar_from_cell(cell)\n983: \n984:     def local_dimension(self, walker_id: int, radius: float) -> float:\n985:         \"\"\"Local intrinsic dimension in a neighborhood.\"\"\"\n986:         neighbors = self.state.DT.get_neighbors_within(walker_id, radius)\n987:         return estimate_local_dimension(neighbors)\n988: \n989:     def geodesic_distance(self, walker_i: int, walker_j: int) -> float:\n990:         \"\"\"Geodesic distance on the emergent manifold.\"\"\"\n991:         path = self.state.DT.shortest_path(walker_i, walker_j)\n992:         return compute_path_length(path)\n993: \n994:     def betti_numbers(self) -> dict:\n995:         \"\"\"Topological invariants (number of holes, voids, etc.).\"\"\"\n996:         complex = build_simplicial_complex(self.state.DT)\n997:         return compute_homology(complex)\n998: \n999:     def mean_field_potential(self, x: Tensor) -> Tensor:\n1000:         \"\"\"Mean-field potential \u03a6(x) interpolated from walker densities.\"\"\"\n1001:         return interpolate_from_voronoi(self.state.VT, x)\n1002: ```\n1003: \n1004: **Usage Example**:\n1005: \n1006: ```python\n1007: gas = EuclideanGas(params)\n1008: state = gas.initialize(N=10000)\n1009: \n1010: analyzer = GeometricAnalyzer(state)\n1011: \n1012: for t in range(num_steps):\n1013:     state = gas.step(state)  # Triangulation updated online\n1014: \n1015:     # Query geometric properties efficiently (no recomputation)\n1016:     avg_curvature = np.mean([\n1017:         analyzer.curvature_at_walker(i) for i in range(N)\n1018:     ])\n1019: \n1020:     avg_dimension = analyzer.local_dimension(0, radius=1.0)\n1021: ",
      "metadata": {
        "label": "def-geometric-query-api"
      },
      "section": "## 8. Integration with the Fragile Framework",
      "raw_directive": "965: ### 8.2 API for Geometric Queries\n966: \n967: :::{prf:definition} Geometric Query Interface\n968: :label: def-geometric-query-api\n969: \n970: **Proposed API** for accessing geometric information:\n971: \n972: ```python\n973: class GeometricAnalyzer:\n974:     \"\"\"Provides geometric and topological queries on the maintained triangulation.\"\"\"\n975: \n976:     def __init__(self, state: SwarmStateWithTriangulation):\n977:         self.state = state\n978: \n979:     def curvature_at_walker(self, walker_id: int) -> float:\n980:         \"\"\"Ricci scalar curvature at a walker's position.\"\"\"\n981:         cell = self.state.VT.get_cell(walker_id)\n982:         return compute_ricci_scalar_from_cell(cell)\n983: \n984:     def local_dimension(self, walker_id: int, radius: float) -> float:\n985:         \"\"\"Local intrinsic dimension in a neighborhood.\"\"\"\n986:         neighbors = self.state.DT.get_neighbors_within(walker_id, radius)\n987:         return estimate_local_dimension(neighbors)\n988: \n989:     def geodesic_distance(self, walker_i: int, walker_j: int) -> float:\n990:         \"\"\"Geodesic distance on the emergent manifold.\"\"\"\n991:         path = self.state.DT.shortest_path(walker_i, walker_j)\n992:         return compute_path_length(path)\n993: \n994:     def betti_numbers(self) -> dict:\n995:         \"\"\"Topological invariants (number of holes, voids, etc.).\"\"\"\n996:         complex = build_simplicial_complex(self.state.DT)\n997:         return compute_homology(complex)\n998: \n999:     def mean_field_potential(self, x: Tensor) -> Tensor:\n1000:         \"\"\"Mean-field potential \u03a6(x) interpolated from walker densities.\"\"\"\n1001:         return interpolate_from_voronoi(self.state.VT, x)\n1002: ```\n1003: \n1004: **Usage Example**:\n1005: \n1006: ```python\n1007: gas = EuclideanGas(params)\n1008: state = gas.initialize(N=10000)\n1009: \n1010: analyzer = GeometricAnalyzer(state)\n1011: \n1012: for t in range(num_steps):\n1013:     state = gas.step(state)  # Triangulation updated online\n1014: \n1015:     # Query geometric properties efficiently (no recomputation)\n1016:     avg_curvature = np.mean([\n1017:         analyzer.curvature_at_walker(i) for i in range(N)\n1018:     ])\n1019: \n1020:     avg_dimension = analyzer.local_dimension(0, radius=1.0)\n1021: \n1022:     print(f\"t={t}: R_avg={avg_curvature:.3f}, d_avg={avg_dimension:.2f}\")"
    }
  ],
  "validation": {
    "ok": true,
    "errors": []
  }
}