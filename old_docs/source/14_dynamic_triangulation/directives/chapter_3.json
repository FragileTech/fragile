{
  "chapter_index": 3,
  "section_id": "## 3. The Online Delaunay/Voronoi Algorithm",
  "directive_count": 6,
  "hints": [
    {
      "directive_type": "algorithm",
      "label": "alg-online-triangulation",
      "title": "Online Scutoid-Guided Triangulation Update",
      "start_line": 138,
      "end_line": 257,
      "header_lines": [
        139
      ],
      "content_start": 141,
      "content_end": 256,
      "content": "141: :label: alg-online-triangulation\n142: \n143: **Data Structures to Maintain:**\n144: - `DT`: The current Delaunay triangulation of the N walker positions\n145: - `VT`: The dual Voronoi tessellation\n146: - `VertexMap`: Map from walker_id \u2192 vertex in DT\n147: \n148: **Initialization (at t=0):**\n149: 1. Compute the initial Delaunay triangulation `DT(0)` from starting positions {x_i(0)}\n150: 2. Compute dual Voronoi tessellation `VT(0)`\n151: 3. Initialize `VertexMap`\n152: \n153: **Cost**: O(N log N) (one-time only)\n154: \n155: **For each timestep t \u2192 t+\u0394t:**\n156: \n157: **Step 1: Identify Perturbed Walkers (Cost: O(N))**\n158: \n159: Iterate through all walkers using the CST edges from time t to t+\u0394t:\n160: \n161: ```python\n162: MovedWalkers = []      # List of (walker_id, old_pos, new_pos)\n163: ClonedWalkers = []     # List of (dead_id, new_pos, parent_id)\n164: \n165: for walker_id in range(N):\n166:     edge = CST.get_edge(walker_id, t, t+\u0394t)\n167: \n168:     if edge.type == \"SDE_evolution\":\n169:         # Type 1: Local move (prismatic scutoid)\n170:         MovedWalkers.append((walker_id, edge.source_pos, edge.target_pos))\n171: \n172:     elif edge.type == \"cloning\":\n173:         # Type 2: Teleport (non-prismatic scutoid)\n174:         ClonedWalkers.append((walker_id, edge.new_pos, edge.parent_id))\n175: ```\n176: \n177: **Step 2: Update for Locally Moved Walkers (Amortized O(1) per walker)**\n178: \n179: For each walker that moved via SDE:\n180: \n181: ```python\n182: for (walker_id, x_old, x_new) in MovedWalkers:\n183:     vertex = VertexMap[walker_id]\n184: \n185:     # Update vertex position in DT\n186:     vertex.position = x_new\n187: \n188:     # Restore Delaunay property using Lawson flips\n189:     LawsonFlip(DT, vertex)\n190: \n191:     # Update corresponding Voronoi cell\n192:     UpdateVoronoiCell(VT, vertex)\n193: ```\n194: \n195: **The Lawson Flip Algorithm:**\n196: - The movement of x_i might make some incident simplices non-Delaunay\n197: - Iteratively \"flip\" diagonals of adjacent simplices until the Delaunay criterion (empty circumsphere) is restored\n198: - For a small move, the number of flips is **O(1) on average** (independent of N)\n199: \n200: **Total Cost**: |MovedWalkers| \u00b7 O(1) \u2248 O(N)\n201: \n202: **Step 3: Update for Cloned Walkers (Amortized O(log N) per walker)**\n203: \n204: For each cloned walker (delete-and-insert):\n205: \n206: ```python\n207: for (dead_id, new_pos, parent_id) in ClonedWalkers:\n208:     # Phase A: Delete dead walker\n209:     dead_vertex = VertexMap[dead_id]\n210:     incident_simplices = DT.get_incident_simplices(dead_vertex)\n211:     DT.remove_vertex(dead_vertex)\n212: \n213:     # Re-triangulate the \"hole\" left by removal\n214:     # (Uses incremental algorithm on the boundary of the hole)\n215:     boundary = get_boundary_of_hole(incident_simplices)\n216:     retriangulate_hole(DT, boundary)  # Cost: O(k\u00b2) where k = |boundary| = O(1) avg\n217: \n218:     # Phase B: Insert new walker\n219:     # Find the simplex containing new_pos\n220:     containing_simplex = DT.locate(new_pos)  # Cost: O(log N) using jump-and-walk\n221: \n222:     # Split the simplex and restore Delaunay property\n223:     new_vertex = DT.insert_vertex(new_pos, containing_simplex)\n224:     LawsonFlip(DT, new_vertex)  # Cost: O(1) amortized\n225: \n226:     # Update VertexMap\n227:     # Note: The dead walker's ID is recycled for the new walker,\n228:     # ensuring constant N walkers with stable ID assignment\n229:     VertexMap[dead_id] = new_vertex\n230: \n231:     # Update Voronoi tessellation\n232:     UpdateVoronoiCell(VT, new_vertex)\n233: ```\n234: \n235: **ID Management Note**: The ID of the dead walker is immediately reassigned to the newly created walker, ensuring the total number of walkers and their IDs remains constant at N. The `VertexMap` maintains the mapping from walker IDs to vertex handles in the triangulation data structure.\n236: \n237: **Total Cost**: |ClonedWalkers| \u00b7 O(log N)\n238: \n239: **Step 4: Return Updated Triangulation**\n240: \n241: ```python\n242: return DT, VT\n243: ```\n244: \n245: **Total Complexity per Timestep:**\n246: \n247: $$\n248: T(N) = O(N) + O(p_{\\text{clone}} \\cdot N \\cdot \\log N)\n249: \n250: $$\n251: \n252: where:\n253: - O(N): Cost for moved walkers (Type 1 scutoids)\n254: - O(p_clone \u00b7 N \u00b7 log N): Cost for cloned walkers (Type 2 scutoids)\n255: \n256: **Since p_clone is typically small (e.g., 0.01-0.1), the average complexity is dominated by the O(N) term.**",
      "metadata": {
        "label": "alg-online-triangulation"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "138: We maintain the triangulation and its dual Voronoi diagram as the swarm evolves, using the CST to guide updates.\n139: \n140: :::{prf:algorithm} Online Scutoid-Guided Triangulation Update\n141: :label: alg-online-triangulation\n142: \n143: **Data Structures to Maintain:**\n144: - `DT`: The current Delaunay triangulation of the N walker positions\n145: - `VT`: The dual Voronoi tessellation\n146: - `VertexMap`: Map from walker_id \u2192 vertex in DT\n147: \n148: **Initialization (at t=0):**\n149: 1. Compute the initial Delaunay triangulation `DT(0)` from starting positions {x_i(0)}\n150: 2. Compute dual Voronoi tessellation `VT(0)`\n151: 3. Initialize `VertexMap`\n152: \n153: **Cost**: O(N log N) (one-time only)\n154: \n155: **For each timestep t \u2192 t+\u0394t:**\n156: \n157: **Step 1: Identify Perturbed Walkers (Cost: O(N))**\n158: \n159: Iterate through all walkers using the CST edges from time t to t+\u0394t:\n160: \n161: ```python\n162: MovedWalkers = []      # List of (walker_id, old_pos, new_pos)\n163: ClonedWalkers = []     # List of (dead_id, new_pos, parent_id)\n164: \n165: for walker_id in range(N):\n166:     edge = CST.get_edge(walker_id, t, t+\u0394t)\n167: \n168:     if edge.type == \"SDE_evolution\":\n169:         # Type 1: Local move (prismatic scutoid)\n170:         MovedWalkers.append((walker_id, edge.source_pos, edge.target_pos))\n171: \n172:     elif edge.type == \"cloning\":\n173:         # Type 2: Teleport (non-prismatic scutoid)\n174:         ClonedWalkers.append((walker_id, edge.new_pos, edge.parent_id))\n175: ```\n176: \n177: **Step 2: Update for Locally Moved Walkers (Amortized O(1) per walker)**\n178: \n179: For each walker that moved via SDE:\n180: \n181: ```python\n182: for (walker_id, x_old, x_new) in MovedWalkers:\n183:     vertex = VertexMap[walker_id]\n184: \n185:     # Update vertex position in DT\n186:     vertex.position = x_new\n187: \n188:     # Restore Delaunay property using Lawson flips\n189:     LawsonFlip(DT, vertex)\n190: \n191:     # Update corresponding Voronoi cell\n192:     UpdateVoronoiCell(VT, vertex)\n193: ```\n194: \n195: **The Lawson Flip Algorithm:**\n196: - The movement of x_i might make some incident simplices non-Delaunay\n197: - Iteratively \"flip\" diagonals of adjacent simplices until the Delaunay criterion (empty circumsphere) is restored\n198: - For a small move, the number of flips is **O(1) on average** (independent of N)\n199: \n200: **Total Cost**: |MovedWalkers| \u00b7 O(1) \u2248 O(N)\n201: \n202: **Step 3: Update for Cloned Walkers (Amortized O(log N) per walker)**\n203: \n204: For each cloned walker (delete-and-insert):\n205: \n206: ```python\n207: for (dead_id, new_pos, parent_id) in ClonedWalkers:\n208:     # Phase A: Delete dead walker\n209:     dead_vertex = VertexMap[dead_id]\n210:     incident_simplices = DT.get_incident_simplices(dead_vertex)\n211:     DT.remove_vertex(dead_vertex)\n212: \n213:     # Re-triangulate the \"hole\" left by removal\n214:     # (Uses incremental algorithm on the boundary of the hole)\n215:     boundary = get_boundary_of_hole(incident_simplices)\n216:     retriangulate_hole(DT, boundary)  # Cost: O(k\u00b2) where k = |boundary| = O(1) avg\n217: \n218:     # Phase B: Insert new walker\n219:     # Find the simplex containing new_pos\n220:     containing_simplex = DT.locate(new_pos)  # Cost: O(log N) using jump-and-walk\n221: \n222:     # Split the simplex and restore Delaunay property\n223:     new_vertex = DT.insert_vertex(new_pos, containing_simplex)\n224:     LawsonFlip(DT, new_vertex)  # Cost: O(1) amortized\n225: \n226:     # Update VertexMap\n227:     # Note: The dead walker's ID is recycled for the new walker,\n228:     # ensuring constant N walkers with stable ID assignment\n229:     VertexMap[dead_id] = new_vertex\n230: \n231:     # Update Voronoi tessellation\n232:     UpdateVoronoiCell(VT, new_vertex)\n233: ```\n234: \n235: **ID Management Note**: The ID of the dead walker is immediately reassigned to the newly created walker, ensuring the total number of walkers and their IDs remains constant at N. The `VertexMap` maintains the mapping from walker IDs to vertex handles in the triangulation data structure.\n236: \n237: **Total Cost**: |ClonedWalkers| \u00b7 O(log N)\n238: \n239: **Step 4: Return Updated Triangulation**\n240: \n241: ```python\n242: return DT, VT\n243: ```\n244: \n245: **Total Complexity per Timestep:**\n246: \n247: $$\n248: T(N) = O(N) + O(p_{\\text{clone}} \\cdot N \\cdot \\log N)\n249: \n250: $$\n251: \n252: where:\n253: - O(N): Cost for moved walkers (Type 1 scutoids)\n254: - O(p_clone \u00b7 N \u00b7 log N): Cost for cloned walkers (Type 2 scutoids)\n255: \n256: **Since p_clone is typically small (e.g., 0.01-0.1), the average complexity is dominated by the O(N) term.**\n257: "
    },
    {
      "directive_type": "assumption",
      "label": "assump-point-regularity",
      "title": "Regularity of Walker Point Sets",
      "start_line": 263,
      "end_line": 294,
      "header_lines": [
        264
      ],
      "content_start": 266,
      "content_end": 293,
      "content": "266: :label: assump-point-regularity\n267: \n268: The walker positions {x_i(t)} generated by the Fragile Gas dynamics satisfy the following regularity conditions almost surely:\n269: \n270: **R1. Bounded Local Degree**: The expected number of Delaunay neighbors for any walker is O(1) (independent of N):\n271: \n272: $$\n273: \\mathbb{E}[\\text{deg}_{\\text{DT}}(x_i)] = O(1)\n274: \n275: $$\n276: \n277: where deg_DT(x_i) is the number of edges incident to vertex x_i in the Delaunay triangulation.\n278: \n279: **R2. Non-Degeneracy**: The walker positions avoid degenerate configurations (e.g., all walkers on a lower-dimensional manifold, cocircular/cospherical sets of d+2 or more points) with probability 1.\n280: \n281: **R3. Density Regularity**: The empirical density \u03c1_N(x) = (1/N) \u03a3_i \u03b4_{x_i(t)} converges to a smooth quasi-stationary distribution (QSD) \u03c1_QSD(x) that is bounded away from zero and infinity on the domain of interest:\n282: \n283: $$\n284: 0 < \\rho_{\\min} \\leq \\rho_{\\text{QSD}}(x) \\leq \\rho_{\\max} < \\infty\n285: \n286: $$\n287: \n288: **R4. Small Displacement**: For SDE-evolved walkers (Type 1 updates), the displacement in one timestep is small relative to the local Delaunay edge length:\n289: \n290: $$\n291: \\mathbb{E}[\\|x_i(t+\\Delta t) - x_i(t)\\|] = O(v \\cdot \\Delta t) \\ll \\ell_{\\text{local}}\n292: \n293: $$",
      "metadata": {
        "label": "assump-point-regularity"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "263: The O(N) complexity analysis relies on the assumption that the walker configuration satisfies certain regularity properties. We formalize these assumptions:\n264: \n265: :::{prf:assumption} Regularity of Walker Point Sets\n266: :label: assump-point-regularity\n267: \n268: The walker positions {x_i(t)} generated by the Fragile Gas dynamics satisfy the following regularity conditions almost surely:\n269: \n270: **R1. Bounded Local Degree**: The expected number of Delaunay neighbors for any walker is O(1) (independent of N):\n271: \n272: $$\n273: \\mathbb{E}[\\text{deg}_{\\text{DT}}(x_i)] = O(1)\n274: \n275: $$\n276: \n277: where deg_DT(x_i) is the number of edges incident to vertex x_i in the Delaunay triangulation.\n278: \n279: **R2. Non-Degeneracy**: The walker positions avoid degenerate configurations (e.g., all walkers on a lower-dimensional manifold, cocircular/cospherical sets of d+2 or more points) with probability 1.\n280: \n281: **R3. Density Regularity**: The empirical density \u03c1_N(x) = (1/N) \u03a3_i \u03b4_{x_i(t)} converges to a smooth quasi-stationary distribution (QSD) \u03c1_QSD(x) that is bounded away from zero and infinity on the domain of interest:\n282: \n283: $$\n284: 0 < \\rho_{\\min} \\leq \\rho_{\\text{QSD}}(x) \\leq \\rho_{\\max} < \\infty\n285: \n286: $$\n287: \n288: **R4. Small Displacement**: For SDE-evolved walkers (Type 1 updates), the displacement in one timestep is small relative to the local Delaunay edge length:\n289: \n290: $$\n291: \\mathbb{E}[\\|x_i(t+\\Delta t) - x_i(t)\\|] = O(v \\cdot \\Delta t) \\ll \\ell_{\\text{local}}\n292: \n293: $$\n294: "
    },
    {
      "directive_type": "proposition",
      "label": "prop-regularity-justified",
      "title": "Justification of Regularity Assumptions",
      "start_line": 296,
      "end_line": 322,
      "header_lines": [
        297
      ],
      "content_start": 299,
      "content_end": 321,
      "content": "299: :label: prop-regularity-justified\n300: \n301: The Fragile Gas dynamics naturally produce point sets satisfying Assumption {prf:ref}`assump-point-regularity` due to the following mechanisms:\n302: \n303: **For R1 (Bounded Degree)**:\n304: - The stochastic noise in the Langevin SDE prevents walkers from forming highly regular lattices (which can have unbounded degree)\n305: - The cloning operator introduces randomness that breaks any emerging crystalline order\n306: - Empirical observation: random point sets in \u211d^d have average degree \u0398(1) in their Delaunay triangulation\n307: \n308: **For R2 (Non-Degeneracy)**:\n309: - Continuous Brownian noise ensures walkers occupy full d-dimensional volume with probability 1\n310: - Measure-theoretic argument: the set of degenerate configurations has measure zero in \u211d^(d\u00b7N)\n311: - In practice, floating-point precision and symbolic perturbation techniques eliminate degeneracies\n312: \n313: **For R3 (Density Regularity)**:\n314: - The confining potential ensures walkers remain in a bounded domain\n315: - The mean-field adaptive forces and virtual reward mechanism drive convergence to a QSD (see [04_convergence.md](04_convergence.md))\n316: - The QSD inherits smoothness from the smoothness of the potential U(x) and reward r(x)\n317: \n318: **For R4 (Small Displacement)**:\n319: - The timestep \u0394t is chosen to satisfy numerical stability criteria (CFL condition)\n320: - For typical parameters: v ~ O(1), \u0394t ~ O(0.01), local edge length ~ O(N^(-1/d))\n321: - As N \u2192 \u221e, the displacement \u0394t remains fixed while the local mesh size shrinks, ensuring the ratio remains small",
      "metadata": {
        "label": "prop-regularity-justified"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "296: :::\n297: \n298: :::{prf:proposition} Justification of Regularity Assumptions\n299: :label: prop-regularity-justified\n300: \n301: The Fragile Gas dynamics naturally produce point sets satisfying Assumption {prf:ref}`assump-point-regularity` due to the following mechanisms:\n302: \n303: **For R1 (Bounded Degree)**:\n304: - The stochastic noise in the Langevin SDE prevents walkers from forming highly regular lattices (which can have unbounded degree)\n305: - The cloning operator introduces randomness that breaks any emerging crystalline order\n306: - Empirical observation: random point sets in \u211d^d have average degree \u0398(1) in their Delaunay triangulation\n307: \n308: **For R2 (Non-Degeneracy)**:\n309: - Continuous Brownian noise ensures walkers occupy full d-dimensional volume with probability 1\n310: - Measure-theoretic argument: the set of degenerate configurations has measure zero in \u211d^(d\u00b7N)\n311: - In practice, floating-point precision and symbolic perturbation techniques eliminate degeneracies\n312: \n313: **For R3 (Density Regularity)**:\n314: - The confining potential ensures walkers remain in a bounded domain\n315: - The mean-field adaptive forces and virtual reward mechanism drive convergence to a QSD (see [04_convergence.md](04_convergence.md))\n316: - The QSD inherits smoothness from the smoothness of the potential U(x) and reward r(x)\n317: \n318: **For R4 (Small Displacement)**:\n319: - The timestep \u0394t is chosen to satisfy numerical stability criteria (CFL condition)\n320: - For typical parameters: v ~ O(1), \u0394t ~ O(0.01), local edge length ~ O(N^(-1/d))\n321: - As N \u2192 \u221e, the displacement \u0394t remains fixed while the local mesh size shrinks, ensuring the ratio remains small\n322: "
    },
    {
      "directive_type": "algorithm",
      "label": "alg-lawson-flip",
      "title": "Lawson Flip for 3D Delaunay Triangulation",
      "start_line": 339,
      "end_line": 394,
      "header_lines": [
        340
      ],
      "content_start": 342,
      "content_end": 393,
      "content": "342: :label: alg-lawson-flip\n343: \n344: **Input**: Delaunay triangulation DT, vertex v whose position was just updated\n345: \n346: **Output**: Restored Delaunay triangulation\n347: \n348: **Procedure**:\n349: \n350: ```python\n351: def LawsonFlip(DT, v):\n352:     # Initialize queue with simplices incident to v\n353:     Q = Queue()\n354:     for simplex in DT.get_incident_simplices(v):\n355:         Q.enqueue(simplex)\n356: \n357:     marked = set()\n358: \n359:     while not Q.empty():\n360:         S = Q.dequeue()\n361: \n362:         if S in marked:\n363:             continue\n364:         marked.add(S)\n365: \n366:         # Check if S satisfies Delaunay criterion\n367:         # (all vertices opposite to each face are outside the circumsphere)\n368:         if is_delaunay(S):\n369:             continue\n370: \n371:         # Find a face F of S that violates the criterion\n372:         F = find_violated_face(S)\n373: \n374:         # Let S' be the simplex adjacent to S across face F\n375:         S_prime = DT.get_adjacent_simplex(S, F)\n376: \n377:         if S_prime is None:\n378:             continue  # F is on the boundary\n379: \n380:         # Perform a \"flip\": remove S and S', add new simplices\n381:         # In 3D, this is a 2-3 flip or 3-2 flip\n382:         new_simplices = perform_flip(DT, S, S_prime, F)\n383: \n384:         # Enqueue affected simplices\n385:         for new_S in new_simplices:\n386:             Q.enqueue(new_S)\n387: ```\n388: \n389: **Key Property**: For a small vertex displacement, the number of flips is **O(1) on average**.\n390: \n391: **Proof Sketch**:\n392: - A vertex move by distance \u03b4 affects only simplices within distance ~\u03b4\n393: - The number of such simplices is O(1) for small \u03b4",
      "metadata": {
        "label": "alg-lawson-flip"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "339: #### 3.3.1 The Lawson Flip Algorithm\n340: \n341: :::{prf:algorithm} Lawson Flip for 3D Delaunay Triangulation\n342: :label: alg-lawson-flip\n343: \n344: **Input**: Delaunay triangulation DT, vertex v whose position was just updated\n345: \n346: **Output**: Restored Delaunay triangulation\n347: \n348: **Procedure**:\n349: \n350: ```python\n351: def LawsonFlip(DT, v):\n352:     # Initialize queue with simplices incident to v\n353:     Q = Queue()\n354:     for simplex in DT.get_incident_simplices(v):\n355:         Q.enqueue(simplex)\n356: \n357:     marked = set()\n358: \n359:     while not Q.empty():\n360:         S = Q.dequeue()\n361: \n362:         if S in marked:\n363:             continue\n364:         marked.add(S)\n365: \n366:         # Check if S satisfies Delaunay criterion\n367:         # (all vertices opposite to each face are outside the circumsphere)\n368:         if is_delaunay(S):\n369:             continue\n370: \n371:         # Find a face F of S that violates the criterion\n372:         F = find_violated_face(S)\n373: \n374:         # Let S' be the simplex adjacent to S across face F\n375:         S_prime = DT.get_adjacent_simplex(S, F)\n376: \n377:         if S_prime is None:\n378:             continue  # F is on the boundary\n379: \n380:         # Perform a \"flip\": remove S and S', add new simplices\n381:         # In 3D, this is a 2-3 flip or 3-2 flip\n382:         new_simplices = perform_flip(DT, S, S_prime, F)\n383: \n384:         # Enqueue affected simplices\n385:         for new_S in new_simplices:\n386:             Q.enqueue(new_S)\n387: ```\n388: \n389: **Key Property**: For a small vertex displacement, the number of flips is **O(1) on average**.\n390: \n391: **Proof Sketch**:\n392: - A vertex move by distance \u03b4 affects only simplices within distance ~\u03b4\n393: - The number of such simplices is O(1) for small \u03b4\n394: - Each flip may propagate to O(1) neighbors"
    },
    {
      "directive_type": "algorithm",
      "label": "alg-jump-and-walk",
      "title": "Jump-and-Walk Point Location",
      "start_line": 398,
      "end_line": 433,
      "header_lines": [
        399
      ],
      "content_start": 401,
      "content_end": 432,
      "content": "401: :label: alg-jump-and-walk\n402: \n403: **Input**: Delaunay triangulation DT, query point q\n404: \n405: **Output**: The simplex containing q\n406: \n407: **Procedure**:\n408: \n409: ```python\n410: def locate(DT, q):\n411:     # Phase 1: Jump to a nearby simplex\n412:     # Use spatial hashing or a recent simplex as starting point\n413:     current_simplex = get_hint_simplex(DT, q)\n414: \n415:     # Phase 2: Walk from current_simplex to the target\n416:     while True:\n417:         # Check if q is inside current_simplex\n418:         if contains(current_simplex, q):\n419:             return current_simplex\n420: \n421:         # Find the face that q is \"beyond\"\n422:         F = find_exit_face(current_simplex, q)\n423: \n424:         # Move to the adjacent simplex across face F\n425:         current_simplex = DT.get_adjacent_simplex(current_simplex, F)\n426: \n427:         if current_simplex is None:\n428:             # q is outside the convex hull\n429:             return None\n430: ```\n431: \n432: **Complexity**: O(log N) expected time for random Delaunay triangulations",
      "metadata": {
        "label": "alg-jump-and-walk"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "398: #### 3.3.2 Point Location in 3D Delaunay Triangulation\n399: \n400: :::{prf:algorithm} Jump-and-Walk Point Location\n401: :label: alg-jump-and-walk\n402: \n403: **Input**: Delaunay triangulation DT, query point q\n404: \n405: **Output**: The simplex containing q\n406: \n407: **Procedure**:\n408: \n409: ```python\n410: def locate(DT, q):\n411:     # Phase 1: Jump to a nearby simplex\n412:     # Use spatial hashing or a recent simplex as starting point\n413:     current_simplex = get_hint_simplex(DT, q)\n414: \n415:     # Phase 2: Walk from current_simplex to the target\n416:     while True:\n417:         # Check if q is inside current_simplex\n418:         if contains(current_simplex, q):\n419:             return current_simplex\n420: \n421:         # Find the face that q is \"beyond\"\n422:         F = find_exit_face(current_simplex, q)\n423: \n424:         # Move to the adjacent simplex across face F\n425:         current_simplex = DT.get_adjacent_simplex(current_simplex, F)\n426: \n427:         if current_simplex is None:\n428:             # q is outside the convex hull\n429:             return None\n430: ```\n431: \n432: **Complexity**: O(log N) expected time for random Delaunay triangulations\n433: "
    },
    {
      "directive_type": "observation",
      "label": "obs-voronoi-delaunay-duality",
      "title": "Voronoi-Delaunay Duality for Online Updates",
      "start_line": 439,
      "end_line": 454,
      "header_lines": [
        440
      ],
      "content_start": 442,
      "content_end": 453,
      "content": "442: :label: obs-voronoi-delaunay-duality\n443: \n444: **Key Dualities**:\n445: 1. **Vertex \u2194 Cell**: Each Delaunay vertex (walker position) corresponds to a Voronoi cell\n446: 2. **Edge \u2194 Face**: Each Delaunay edge corresponds to a Voronoi face (shared boundary between two cells)\n447: 3. **Face \u2194 Edge**: Each Delaunay face corresponds to a Voronoi edge\n448: 4. **Simplex \u2194 Vertex**: Each Delaunay simplex corresponds to a Voronoi vertex (the simplex's circumcenter)\n449: \n450: **Update Rule**:\n451: - When a Delaunay vertex moves, recompute the circumcenters of all incident simplices\n452: - These circumcenters are the Voronoi vertices that define the Voronoi cell\n453: - When a Delaunay simplex is flipped, the corresponding Voronoi vertices/edges are updated",
      "metadata": {
        "label": "obs-voronoi-delaunay-duality"
      },
      "section": "## 3. The Online Delaunay/Voronoi Algorithm",
      "raw_directive": "439: The dual Voronoi tessellation is updated efficiently using the duality relationship:\n440: \n441: :::{prf:observation} Voronoi-Delaunay Duality for Online Updates\n442: :label: obs-voronoi-delaunay-duality\n443: \n444: **Key Dualities**:\n445: 1. **Vertex \u2194 Cell**: Each Delaunay vertex (walker position) corresponds to a Voronoi cell\n446: 2. **Edge \u2194 Face**: Each Delaunay edge corresponds to a Voronoi face (shared boundary between two cells)\n447: 3. **Face \u2194 Edge**: Each Delaunay face corresponds to a Voronoi edge\n448: 4. **Simplex \u2194 Vertex**: Each Delaunay simplex corresponds to a Voronoi vertex (the simplex's circumcenter)\n449: \n450: **Update Rule**:\n451: - When a Delaunay vertex moves, recompute the circumcenters of all incident simplices\n452: - These circumcenters are the Voronoi vertices that define the Voronoi cell\n453: - When a Delaunay simplex is flipped, the corresponding Voronoi vertices/edges are updated\n454: "
    }
  ],
  "validation": {
    "ok": true,
    "errors": []
  }
}