[
  {
    "label": "def-single-swarm-space",
    "type": "definition",
    "title": "Single-Walker and Swarm State Spaces",
    "term": "Single-Walker and Swarm State Spaces",
    "object_type": "state space",
    "nl_definition": "A walker is a tuple combining position (and velocity in the Euclidean Gas) with survival status; a swarm is an N-tuple of such walker states, and the single-swarm state space is the Cartesian product of individual walker state spaces.",
    "content_markdown": ":label: def-single-swarm-space\n\n1.  A **walker** is a tuple $(x, s)$, where $x \\in \\mathcal{X}$ is its position in a state space and $s \\in \\{0, 1\\}$ is its survival status. For the Euclidean Gas, this is extended to include a velocity component, making the **full state** of a single walker a tuple $(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}$. We refer to $(x,v)$ as the **kinematic state**.\n\n2.  A **swarm configuration**, $S$, is an N-tuple of walker states:\n\n\n\n$$\nS := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)\n$$\n\n3.  The **single-swarm state space**, denoted $\\Sigma_N$, is the Cartesian product of the per-walker state spaces:\n\n\n\n$$\n\\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N.\n$$",
    "raw_directive": "106: The fundamental unit of the system is the walker, and a collection of these walkers constitutes a swarm. We begin by defining their state spaces abstractly, in a manner consistent with the Fragile Gas framework.\n107: \n108: :::{prf:definition} Single-Walker and Swarm State Spaces\n109: :label: def-single-swarm-space\n110: \n111: 1.  A **walker** is a tuple $(x, s)$, where $x \\in \\mathcal{X}$ is its position in a state space and $s \\in \\{0, 1\\}$ is its survival status. For the Euclidean Gas, this is extended to include a velocity component, making the **full state** of a single walker a tuple $(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}$. We refer to $(x,v)$ as the **kinematic state**.\n112: \n113: 2.  A **swarm configuration**, $S$, is an N-tuple of walker states:\n114: \n115: \n116: \n117: $$\n118: S := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)\n119: $$\n120: \n121: 3.  The **single-swarm state space**, denoted $\\Sigma_N$, is the Cartesian product of the per-walker state spaces:\n122: \n123: \n124: \n125: $$\n126: \\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N.\n127: $$\n128: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "A walker is a tuple (x, s) where x ∈ \\mathcal{X} is position and s ∈ {0, 1} is survival status.",
        "latex": "(x, s),\\ x \\in \\mathcal{X},\\ s \\in \\{0, 1\\}"
      },
      {
        "type": null,
        "text": "In the Euclidean Gas, the full state is (x, v, s) ∈ ℝ^d × ℝ^d × {0, 1}, with kinematic state (x, v).",
        "latex": "(x, v, s) \\in \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\}"
      },
      {
        "type": null,
        "text": "A swarm configuration S is an N-tuple of walker states.",
        "latex": "S := \\left( (x_1, v_1, s_1), (x_2, v_2, s_2), \\dots, (x_N, v_N, s_N) \\right)"
      },
      {
        "type": null,
        "text": "The single-swarm state space Σ_N is the Cartesian product.",
        "latex": "\\Sigma_N := \\left( \\mathbb{R}^d \\times \\mathbb{R}^d \\times \\{0, 1\\} \\right)^N"
      }
    ],
    "properties": [
      {
        "name": "Cartesian product structure",
        "description": "The swarm state space is the product of individual walker state spaces, allowing independent variation of each walker's state."
      },
      {
        "name": "Finite dimensionality",
        "description": "For fixed N and d, Σ_N is a finite-dimensional space with 2^N possible survival configurations."
      }
    ],
    "parameters": [
      {
        "symbol": "N",
        "name": "number of walkers",
        "description": "The number of walkers in the swarm configuration",
        "constraints": [
          "N is a positive integer"
        ],
        "tags": [
          "swarm size"
        ]
      },
      {
        "symbol": "d",
        "name": "spatial dimension",
        "description": "The dimension of the position and velocity spaces in the Euclidean Gas",
        "constraints": [
          "d is a positive integer"
        ],
        "tags": [
          "dimension"
        ]
      },
      {
        "symbol": "\\mathcal{X}",
        "name": "position space",
        "description": "General state space for walker position in the abstract Fragile Gas",
        "constraints": [
          "\\mathcal{X} is a measurable space"
        ],
        "tags": [
          "position",
          "abstract"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "The definition is abstract for the Fragile Gas framework using general \\mathcal{X}, but specialized to Euclidean Gas with velocity in ℝ^d."
      },
      {
        "type": "extension",
        "text": "The kinematic state (x, v) captures position and velocity, relevant for motion dynamics in the Euclidean case."
      }
    ],
    "related_refs": [],
    "tags": [
      "walker",
      "swarm",
      "state space",
      "survival status",
      "kinematic state",
      "Euclidean Gas",
      "Fragile Gas"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 106,
      "end_line": 128,
      "content_start": 109,
      "content_end": 127,
      "header_lines": [
        107
      ]
    },
    "references": [
      "def-barycentres-and-centered-vectors",
      "def-coupled-state-space",
      "def-swarm-aggregation-operator"
    ],
    "metadata": {
      "label": "def-single-swarm-space"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-coupled-state-space",
    "type": "definition",
    "title": "The Coupled State Space",
    "term": "coupled state space",
    "object_type": "set",
    "nl_definition": "The Cartesian product of the state space Σ_N with itself, consisting of ordered pairs (S₁, S₂) where each S_i is a configuration of N particles with positions, velocities, and spins.",
    "content_markdown": ":label: def-coupled-state-space\n\nThe **coupled state space** for the Euclidean Gas is the Cartesian product $\\Sigma_N \\times \\Sigma_N$, where $\\Sigma_N$ is defined in {prf:ref}`def-single-swarm-space`. An element of this space is an ordered pair of swarm configurations, $(S_1, S_2)$, where:\n\n$$\nS_1 = \\left( (x_{1,1}, v_{1,1}, s_{1,1}), \\dots, (x_{1,N}, v_{1,N}, s_{1,N}) \\right) \\in \\Sigma_N,\n$$\n\n$$\nS_2 = \\left( (x_{2,1}, v_{2,1}, s_{2,1}), \\dots, (x_{2,N}, v_{2,N}, s_{2,N}) \\right) \\in \\Sigma_N.\n$$\n\nThe convergence analysis proceeds by tracking the evolution of a Lyapunov function $V(S_1, S_2)$ across this coupled space.",
    "raw_directive": "145: This synchronous coupling is chosen because it is designed to minimize the distance between the two trajectories, making it the most suitable choice for proving a contraction. All expectations $\\mathbb{E}[\\cdot]$ in the subsequent analysis are taken with respect to this single, shared source of randomness.\n146: \n147: :::{prf:definition} The Coupled State Space\n148: :label: def-coupled-state-space\n149: \n150: The **coupled state space** for the Euclidean Gas is the Cartesian product $\\Sigma_N \\times \\Sigma_N$, where $\\Sigma_N$ is defined in {prf:ref}`def-single-swarm-space`. An element of this space is an ordered pair of swarm configurations, $(S_1, S_2)$, where:\n151: \n152: $$\n153: S_1 = \\left( (x_{1,1}, v_{1,1}, s_{1,1}), \\dots, (x_{1,N}, v_{1,N}, s_{1,N}) \\right) \\in \\Sigma_N,\n154: $$\n155: \n156: $$\n157: S_2 = \\left( (x_{2,1}, v_{2,1}, s_{2,1}), \\dots, (x_{2,N}, v_{2,N}, s_{2,N}) \\right) \\in \\Sigma_N.\n158: $$\n159: \n160: The convergence analysis proceeds by tracking the evolution of a Lyapunov function $V(S_1, S_2)$ across this coupled space.\n161: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "S₁ ∈ Σ_N and S₂ ∈ Σ_N",
        "latex": "S_1 \\in \\Sigma_N, \\; S_2 \\in \\Sigma_N"
      },
      {
        "type": null,
        "text": "Each S_i = ((x_{i,1}, v_{i,1}, s_{i,1}), …, (x_{i,N}, v_{i,N}, s_{i,N}))",
        "latex": "S_i = \\left( (x_{i,1}, v_{i,1}, s_{i,1}), \\dots, (x_{i,N}, v_{i,N}, s_{i,N}) \\right) \\in \\Sigma_N \\; (i=1,2)"
      }
    ],
    "properties": [
      {
        "name": "product structure",
        "description": "Direct product of two identical state spaces for comparing trajectories"
      },
      {
        "name": "element composition",
        "description": "Pairs of N-tuples, each tuple containing position x, velocity v, and spin s for particles"
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "Used in synchronous coupling to minimize distance between trajectories; expectations taken w.r.t. shared randomness"
      }
    ],
    "related_refs": [],
    "tags": [
      "coupled state space",
      "Euclidean gas",
      "Cartesian product",
      "swarm configuration",
      "synchronous coupling"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 145,
      "end_line": 161,
      "content_start": 148,
      "content_end": 160,
      "header_lines": [
        146
      ]
    },
    "references": [
      "def-single-swarm-space",
      "def-coupled-cloning-expectation"
    ],
    "metadata": {
      "label": "def-coupled-state-space"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-state-difference-vectors",
    "type": "definition",
    "title": "State Difference Vectors",
    "term": "state difference vectors",
    "object_type": "vectors",
    "nl_definition": "For a pair of swarm states (S₁, S₂) in Σ_N × Σ_N, the state difference vectors consist of the position difference Δx_i = x_{1,i} - x_{2,i} and velocity difference Δv_i = v_{1,i} - v_{2,i} for each walker i from 1 to N, each in ℝ^d.",
    "content_markdown": ":label: def-state-difference-vectors\n\nFor any element $(S_1, S_2) \\in \\Sigma_N \\times \\Sigma_N$, we define the **state difference vectors** for each walker index $i \\in \\{1, \\ldots, N\\}$ as follows:\n\n1.  The **position difference vector** for walker $i$ is:\n\n\n\n$$\n\\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d\n$$\n\n2.  The **velocity difference vector** for walker $i$ is:\n\n\n\n$$\n\\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d\n$$\n\nThe entire drift analysis will be formulated in terms of the norms and inner products of these $2N$ difference vectors. The objective is to show that, in expectation, the magnitudes of these vectors decrease over time, driving the two swarm trajectories together.",
    "raw_directive": "167: The core of the hypocoercive analysis is not the absolute state of the swarms, but the *difference* between them (measured element-wise). We formally define the vectors that capture this relative configuration.\n168: \n169: :::{prf:definition} State Difference Vectors\n170: :label: def-state-difference-vectors\n171: \n172: For any element $(S_1, S_2) \\in \\Sigma_N \\times \\Sigma_N$, we define the **state difference vectors** for each walker index $i \\in \\{1, \\ldots, N\\}$ as follows:\n173: \n174: 1.  The **position difference vector** for walker $i$ is:\n175: \n176: \n177: \n178: $$\n179: \\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d\n180: $$\n181: \n182: 2.  The **velocity difference vector** for walker $i$ is:\n183: \n184: \n185: \n186: $$\n187: \\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d\n188: $$\n189: \n190: The entire drift analysis will be formulated in terms of the norms and inner products of these $2N$ difference vectors. The objective is to show that, in expectation, the magnitudes of these vectors decrease over time, driving the two swarm trajectories together.\n191: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Position difference vector",
        "latex": "\\Delta x_i := x_{1,i} - x_{2,i} \\in \\mathbb{R}^d"
      },
      {
        "type": null,
        "text": "Velocity difference vector",
        "latex": "\\Delta v_i := v_{1,i} - v_{2,i} \\in \\mathbb{R}^d"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Index of the walker in the swarm",
        "constraints": [
          "i ∈ {1, …, N}"
        ],
        "tags": [
          "index",
          "walker"
        ]
      },
      {
        "symbol": "N",
        "name": "number of walkers",
        "description": "Total number of walkers in each swarm",
        "constraints": [
          "N ≥ 1"
        ],
        "tags": [
          "dimension",
          "size"
        ]
      },
      {
        "symbol": "d",
        "name": "spatial dimension",
        "description": "Dimension of the position and velocity spaces",
        "constraints": [
          "d ≥ 1"
        ],
        "tags": [
          "dimension",
          "space"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "state difference",
      "position difference",
      "velocity difference",
      "swarm",
      "walker",
      "hypocoercivity"
    ],
    "document_id": "03_cloning",
    "section": "## 2. The Coupled State Space and State Differences",
    "span": {
      "start_line": 167,
      "end_line": 191,
      "content_start": 170,
      "content_end": 190,
      "header_lines": [
        168
      ]
    },
    "references": [
      "def-location-error-component"
    ],
    "metadata": {
      "label": "def-state-difference-vectors"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Coupled State Space and State Differences"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-barycentres-and-centered-vectors",
    "type": "definition",
    "title": "Barycentres and Centered Vectors (Alive Walkers Only)",
    "term": "barycentres and centered vectors",
    "object_type": "centers and deviations",
    "nl_definition": "For each swarm in a coupled state, the barycentres are the average positions and velocities computed only over alive walkers, and the centered vectors are the individual alive walkers' positions and velocities relative to these swarm barycentres.",
    "content_markdown": ":label: def-barycentres-and-centered-vectors\n\nFor each swarm $k \\in \\{1, 2\\}$ (see {prf:ref}`def-single-swarm-space`) in a coupled state $(S_1, S_2)$, let $\\mathcal{A}(S_k)$ denote the set of alive walker indices and let $k_{\\text{alive}} := |\\mathcal{A}(S_k)|$ denote the number of alive walkers in swarm $k$. We define:\n\n1.  The **positional center of mass** (barycentre) **computed over alive walkers only**:\n\n\n\n$$\n\\mu_{x,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}\n$$\n\n2.  The **velocity center of mass** **computed over alive walkers only**:\n\n\n\n$$\n\\mu_{v,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}\n$$\n\nThe **centered vectors** represent the state of each **alive** walker relative to its swarm's center of mass:\n\n1.  The **centered position vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n\n\n\n$$\n\\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}\n$$\n\n2.  The **centered velocity vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n\n\n\n$$\n\\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}\n$$\n\n**Convention**: Dead walkers ($i \\notin \\mathcal{A}(S_k)$) do not contribute to barycentres, variances, or any statistical quantities. By construction, the centered vectors for alive walkers in any swarm sum to zero: $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0$ and $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0$.\n\n:::{admonition} Rationale for Alive-Walker-Only Statistics\n:class: important\n\nDead walkers retain their last known position $(x_i, v_i)$ but have status $s_i = 0$. Including them in statistical calculations would distort the geometric properties:\n\n1. **Physical Interpretation**: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution.\n\n2. **Cloning Operator Target**: The cloning operator $\\Psi_{\\text{clone}}$ acts on the fitness and geometric distribution of **alive** walkers. The variance it contracts is specifically the variance of the alive population.\n\n3. **Measurement Consistency**: Distance-to-companion measurements ([](#sec:distance-measurement)) are computed from the alive-walker distribution. For consistency, all variance and barycentre calculations must use the same population.",
    "raw_directive": "373: We begin by formally defining the mathematical objects required for this decomposition.\n374: \n375: :::{prf:definition} Barycentres and Centered Vectors (Alive Walkers Only)\n376: :label: def-barycentres-and-centered-vectors\n377: \n378: For each swarm $k \\in \\{1, 2\\}$ (see {prf:ref}`def-single-swarm-space`) in a coupled state $(S_1, S_2)$, let $\\mathcal{A}(S_k)$ denote the set of alive walker indices and let $k_{\\text{alive}} := |\\mathcal{A}(S_k)|$ denote the number of alive walkers in swarm $k$. We define:\n379: \n380: 1.  The **positional center of mass** (barycentre) **computed over alive walkers only**:\n381: \n382: \n383: \n384: $$\n385: \\mu_{x,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}\n386: $$\n387: \n388: 2.  The **velocity center of mass** **computed over alive walkers only**:\n389: \n390: \n391: \n392: $$\n393: \\mu_{v,k} := \\frac{1}{k_{\\text{alive}}}\\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}\n394: $$\n395: \n396: The **centered vectors** represent the state of each **alive** walker relative to its swarm's center of mass:\n397: \n398: 1.  The **centered position vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n399: \n400: \n401: \n402: $$\n403: \\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}\n404: $$\n405: \n406: 2.  The **centered velocity vector** for alive walker $i \\in \\mathcal{A}(S_k)$:\n407: \n408: \n409: \n410: $$\n411: \\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}\n412: $$\n413: \n414: **Convention**: Dead walkers ($i \\notin \\mathcal{A}(S_k)$) do not contribute to barycentres, variances, or any statistical quantities. By construction, the centered vectors for alive walkers in any swarm sum to zero: $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0$ and $\\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0$.\n415: \n416: :::{admonition} Rationale for Alive-Walker-Only Statistics\n417: :class: important\n418: \n419: Dead walkers retain their last known position $(x_i, v_i)$ but have status $s_i = 0$. Including them in statistical calculations would distort the geometric properties:\n420: \n421: 1. **Physical Interpretation**: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution.\n422: \n423: 2. **Cloning Operator Target**: The cloning operator $\\Psi_{\\text{clone}}$ acts on the fitness and geometric distribution of **alive** walkers. The variance it contracts is specifically the variance of the alive population.\n424: \n425: 3. **Measurement Consistency**: Distance-to-companion measurements ([](#sec:distance-measurement)) are computed from the alive-walker distribution. For consistency, all variance and barycentre calculations must use the same population.\n426: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\mu_{x,k} := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} x_{k,i}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\mu_{v,k} := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} v_{k,i}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\delta_{x,k,i} := x_{k,i} - \\mu_{x,k}"
      },
      {
        "type": null,
        "text": null,
        "latex": "\\delta_{v,k,i} := v_{k,i} - \\mu_{v,k}"
      }
    ],
    "properties": [
      {
        "name": "Sum to zero",
        "description": "By construction, the centered vectors for alive walkers in any swarm sum to zero: \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{x,k,i} = 0 and \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{v,k,i} = 0."
      },
      {
        "name": "Alive walkers only",
        "description": "Dead walkers do not contribute to the barycentres, variances, or any statistical quantities."
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "convention",
        "text": "Dead walkers (i \\notin \\mathcal{A}(S_k)) do not contribute to barycentres, variances, or any statistical quantities."
      },
      {
        "type": "important",
        "text": "Dead walkers retain their last known position (x_i, v_i) but have status s_i = 0. Including them in statistical calculations would distort the geometric properties: (1) Physical Interpretation: Dead walkers represent \"failed\" exploration paths. Their positions are historical artifacts, not part of the current active swarm distribution. (2) Cloning Operator Target: The cloning operator \\Psi_{\\text{clone}} acts on the fitness and geometric distribution of alive walkers. The variance it contracts is specifically the variance of the alive population."
      }
    ],
    "related_refs": [],
    "tags": [
      "barycentre",
      "centered vectors",
      "alive walkers",
      "center of mass",
      "swarm statistics",
      "deviations"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 373,
      "end_line": 426,
      "content_start": 376,
      "content_end": 425,
      "header_lines": [
        374,
        415
      ]
    },
    "references": [
      "def-single-swarm-space",
      "def-full-synergistic-lyapunov-function",
      "def-structural-error-component"
    ],
    "metadata": {
      "label": "def-barycentres-and-centered-vectors",
      "class": "important"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-location-error-component",
    "type": "definition",
    "title": "The Location Error Component ($V_{\\text{loc}}$)",
    "term": "location error component",
    "object_type": "quadratic form",
    "nl_definition": "For any pair of swarm configurations with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$, the location error component $V_{\\text{loc}}$ measures the hypocoercive quadratic error between the differences $\\Delta\\mu_x = \\mu_{x,1} - \\mu_{x,2}$ and $\\Delta\\mu_v = \\mu_{v,1} - \\mu_{v,2}$.",
    "content_markdown": ":label: def-location-error-component\n\nFor any pair of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$ (derived from {prf:ref}`def-state-difference-vectors`), the **location error component** is defined as:\n\n$$\nV_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle\n$$",
    "raw_directive": "437: The distance between the swarms' centers of mass is an intrinsically permutation-invariant quantity. We define the location error as the hypocoercive quadratic form applied to the difference between the barycenters of the two swarms.\n438: \n439: :::{prf:definition} The Location Error Component ($V_{\\text{loc}}$)\n440: :label: def-location-error-component\n441: \n442: For any pair of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$ (derived from {prf:ref}`def-state-difference-vectors`), the **location error component** is defined as:\n443: \n444: $$\n445: V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle\n446: $$\n447: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Defined for pairs of swarm configurations $(S_1, S_2)$ with barycenters $(\\mu_{x,1}, \\mu_{v,1})$ and $(\\mu_{x,2}, \\mu_{v,2})$",
        "latex": null
      },
      {
        "type": null,
        "text": "$V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v \\|\\Delta\\mu_v\\|^2 + b \\langle \\Delta\\mu_x, \\Delta\\mu_v \\rangle$ where $\\Delta\\mu_x = \\mu_{x,1} - \\mu_{x,2}$ and $\\Delta\\mu_v = \\mu_{v,1} - \\mu_{v,2}$",
        "latex": "V_{\\text{loc}} := \\|\\Delta\\mu_x\\|^2 + \\lambda_v\\|\\Delta\\mu_v\\|^2 + b\\langle\\Delta\\mu_x, \\Delta\\mu_v\\rangle"
      }
    ],
    "properties": [
      {
        "name": "permutation-invariant",
        "description": "Invariant under permutations of particles within each swarm, as it depends only on the centers of mass."
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "The distance between the swarms' centers of mass is an intrinsically permutation-invariant quantity. We define the location error as the hypocoercive quadratic form applied to the difference between the barycenters of the two swarms."
      }
    ],
    "related_refs": [],
    "tags": [
      "location error",
      "barycenter",
      "swarm configuration",
      "quadratic form",
      "hypocoercive",
      "permutation invariant",
      "energy component"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 437,
      "end_line": 447,
      "content_start": 440,
      "content_end": 446,
      "header_lines": [
        438
      ]
    },
    "references": [
      "def-state-difference-vectors"
    ],
    "metadata": {
      "label": "def-location-error-component"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-structural-error-component",
    "type": "definition",
    "title": "The Structural Error Component ($V_{\\text{struct}}$)",
    "term": "structural error component",
    "object_type": "error measure",
    "nl_definition": "The structural error component $V_{\\text{struct}}$ is the squared hypocoercive Wasserstein distance between the centered empirical measures $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ of two swarms $S_1$ and $S_2$, computed over alive walkers only.",
    "content_markdown": ":label: def-structural-error-component\n\nLet $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ be the centered empirical measures of swarms $S_1$ and $S_2$ **computed over alive walkers only**:\n\n$$\n\\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\n$$\n\nwhere $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ is the number of alive walkers in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n\nThe **structural error component** $V_{\\text{struct}}$ is defined as the squared hypocoercive Wasserstein distance between these centered measures:\n\n$$\nV_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})\n$$",
    "raw_directive": "453: The structural error measures the mismatch between the \"shapes\" of the two swarms. The shape of a swarm is described by the set of its centered vectors, $\\{\\delta_{z,k,i}\\}$. To compare these shapes in a permutation-invariant way, we find the **optimal matching** between the centered vectors of the two swarms and measure the residual error of that matching. This is equivalent to the hypocoercive Wasserstein distance between the *centered empirical measures*.\n454: \n455: :::{prf:definition} The Structural Error Component ($V_{\\text{struct}}$)\n456: :label: def-structural-error-component\n457: \n458: Let $\\tilde{\\mu}_1$ and $\\tilde{\\mu}_2$ be the centered empirical measures of swarms $S_1$ and $S_2$ **computed over alive walkers only**:\n459: \n460: $$\n461: \\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\n462: $$\n463: \n464: where $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ is the number of alive walkers in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n465: \n466: The **structural error component** $V_{\\text{struct}}$ is defined as the squared hypocoercive Wasserstein distance between these centered measures:\n467: \n468: $$\n469: V_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})\n470: $$\n471: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\tilde{\\mu}_k := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\delta_{(\\delta_{x,k,i}, \\delta_{v,k,i})}\\quad k_{\\text{alive}} = |\\mathcal{A}(S_k)|"
      },
      {
        "type": null,
        "text": null,
        "latex": "V_{\\text{struct}} := W_h^2(\\tilde{\\mu}_1, \\tilde{\\mu}_2) = \\inf_{\\gamma \\in \\Gamma(\\tilde{\\mu}_1, \\tilde{\\mu}_2)} \\int c(\\delta_{z,1}, \\delta_{z,2}) \\, d\\gamma(\\delta_{z,1}, \\delta_{z,2})"
      }
    ],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "The structural error measures the mismatch between the \"shapes\" of the two swarms. The shape of a swarm is described by the set of its centered vectors, $\\{\\delta_{z,k,i}\\}$. To compare these shapes in a permutation-invariant way, we find the optimal matching between the centered vectors of the two swarms and measure the residual error of that matching. This is equivalent to the hypocoercive Wasserstein distance between the centered empirical measures."
      }
    ],
    "related_refs": [
      "def-barycentres-and-centered-vectors"
    ],
    "tags": [
      "structural error",
      "wasserstein distance",
      "hypocoercive",
      "swarms",
      "centered measures",
      "empirical measures",
      "optimal matching"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 453,
      "end_line": 471,
      "content_start": 456,
      "content_end": 470,
      "header_lines": [
        454
      ]
    },
    "references": [
      "def-barycentres-and-centered-vectors"
    ],
    "metadata": {
      "label": "def-structural-error-component"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-full-synergistic-lyapunov-function",
    "type": "definition",
    "title": "The Full Synergistic Hypocoercive Lyapunov Function",
    "term": "total synergistic Lyapunov function",
    "object_type": "Lyapunov function",
    "nl_definition": "A permutation-invariant function measuring the combined inter-swarm distance, intra-swarm dispersion in position and velocity (over alive walkers, normalized by total swarm size N), and boundary proximity penalty for alive walkers in paired swarm configurations.",
    "content_markdown": ":label: def-full-synergistic-lyapunov-function\n\nFor any pair of swarm configurations $(S_1, S_2)$ with corresponding empirical measures $(\\mu_1, \\mu_2)$, the **total synergistic Lyapunov function** is defined as:\n\n$$\nV_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)\n$$\n\nwhere the intra-swarm variance term explicitly decomposes into positional and velocity components **summed over alive walkers only, but normalized by the total swarm size $N$**:\n\n$$\nV_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)\n$$\n\nwith:\n\n$$\n\\begin{align*}\nV_{Var,x}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2 \\\\\nV_{Var,v}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2\n\\end{align*}\n$$\n\nwhere $N$ is the total swarm size, $\\mathcal{A}(S_k)$ is the set of alive walker indices in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n\nThe function is a sum of three components:\n\n1.  **The Inter-Swarm Error ($W_h^2$):** The squared hypocoercive 2-Wasserstein distance between the swarms' full empirical measures. This term quantifies the total permutation-invariant distance between the two swarms in phase space. As established in {prf:ref}`lem-wasserstein-decomposition`, this component can be exactly decomposed into:\n    *   A **Location Component ($V_{\\text{loc}}$)**, measuring the error between the swarm centers of mass.\n    *   A **Structural Component ($V_{\\text{struct}}$)**, measuring the mismatch in swarm shapes.\n\n2.  **The Intra-Swarm Error ($V_{\\text{Var}}$):** The sum of the internal hypocoercive variances of each swarm. This term quantifies the internal dispersion or \"shape error\" *within* each individual swarm in phase space, measuring their lack of internal convergence in both position and velocity. This component is the primary target of the **synergistic dissipation framework**:\n    *   The **cloning operator** ($\\Psi_{\\text{clone}}$, analyzed in this document) provides powerful contraction of the positional variance component $V_{Var,x}$ but causes bounded expansion of the velocity variance component $V_{Var,v}$ through the velocity reset mechanism.\n    *   The **kinetic operator** ($\\Psi_{\\text{kin}}$, analyzed in the companion document) provides contraction of the velocity variance component $V_{Var,v}$ through Langevin dissipation but causes bounded expansion of the positional variance component $V_{Var,x}$ through diffusion.\n    *   When properly balanced, these two operators achieve **net contraction** of the total $V_{Var}$, enabling the system to converge in both position and velocity simultaneously.\n\n3.  **The Boundary Potential ($W_b$):** A term that penalizes **alive** walkers approaching the boundary, constructed from the smooth barrier function $\\varphi_{\\text{barrier}}(x)$ defined in {prf:ref}`prop-barrier-existence`.\n\n\n$$\nW_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n$$\n\n    where $N$ is the total swarm size and $\\mathcal{A}(S_k)$ denotes the set of alive walker indices in swarm $k$. Note that dead walkers do not contribute to the boundary potential.\n\nThe parameters $b$ and $\\lambda_v > 0$ are the **hypocoercive parameters**. The constants $c_V > 0$ and $c_B > 0$ are small, positive **coupling constants** used in the analysis to balance the contributions of the different error components in the final drift inequality.\n\n:::{admonition} Normalization by $N$ vs. $k_{\\text{alive}}$ in the Lyapunov Function\n:class: important\n\nThe Lyapunov function components $V_{\\text{Var}}$ and $W_b$ are normalized by the **total swarm size $N$**, not by the number of alive walkers $k_{\\text{alive}}$. This design choice is critical for mathematical tractability and deserves careful explanation:\n\n**Why This Choice Differs from Algorithm Internals:**\n\nThe algorithm's internal fitness calculations (z-scores, variance measurements used for cloning decisions) correctly use $k_{\\text{alive}}$-normalization to compute statistics over the current active population. This is the physically and statistically correct choice for **decision-making**, as it accurately characterizes the distribution of alive walkers at each step.\n\nHowever, the Lyapunov function serves a different purpose: it is an **analytical tool** designed to prove long-term stability through drift analysis. For this purpose, $N$-normalization is mathematically necessary.\n\n**The Mathematical Necessity:**\n\nConsider the one-step change in the variance component:\n\n$$\n\\Delta V_{\\text{Var}} = V_{\\text{Var}}(S_{t+1}) - V_{\\text{Var}}(S_t)\n$$\n\nIf $V_{\\text{Var}}$ were normalized by $k_{\\text{alive}}$, the drift calculation would become:\n\n$$\n\\mathbb{E}[\\Delta V_{\\text{Var}}] = \\mathbb{E}\\left[\\frac{1}{k_{t+1}} \\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\frac{1}{k_t} \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n$$\n\nThis expression involves the **ratio of correlated random variables**: both the sum of squares and the number of alive walkers change stochastically at each step, and these changes are strongly coupled (e.g., if a high-variance walker dies, both the numerator and denominator change). The expectation of such a ratio cannot be simplified, making rigorous drift bounds essentially impossible to derive.\n\nWith $N$-normalization, the constant factor $1/N$ factors out of the expectation:\n\n$$\n\\mathbb{E}[\\Delta V_{\\text{Var}}] = \\frac{1}{N} \\mathbb{E}\\left[\\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n$$\n\nThis allows the analysis to focus entirely on $\\mathbb{E}[\\Delta \\text{SumOfSquares}]$, which is the direct effect of the cloning and kinetic operators on the swarm's kinematic state. This is precisely what the Keystone Principle and the hypocoercive analysis are designed to bound.\n\n**The Mean-Field Interpretation:**\n\nThe $N$-normalized variance can be interpreted as:\n\n$$\nV_{\\text{Var},x}(S_k) = \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_{\\text{alive}}(S_k)\n$$\n\nThis represents the **mean-field contribution to system disorder per walker slot**. It scales with the fraction of alive walkers, which is exactly the correct behavior: if only a small fraction of walkers remain alive, the system's total disorder (as measured by the Lyapunov function) should reflect this reduced active mass.\n\n**The Viability Requirement:**\n\nThis normalization implicitly assumes that the swarm remains viable, meaning $k_{\\text{alive}}/N$ is bounded away from zero. This is guaranteed by the framework's design:\n- The Safe Harbor Axiom ensures existence of a desirable region away from boundaries\n- The contractive properties of the cloning operator (Keystone Principle) and the confining potential prevent swarm collapse\n- The Lyapunov analysis operates in the regime where the swarm is stable, with extinction probability exponentially small\n\n**Conclusion:**\n\nThe separation between algorithmic calculations (using $k_{\\text{alive}}$) and analytical tools (using $N$) is not a compromise but a hallmark of rigorous mean-field analysis. The algorithm uses the physically optimal metric for real-time decisions, while the Lyapunov function uses the mathematically tractable metric for proving convergence. Both serve their respective purposes correctly.",
    "raw_directive": "757: With the permutation-invariant decomposition of the inter-swarm error established, we now define the full Lyapunov function. This **synergistic** function is constructed as a weighted sum of three distinct error components (see {prf:ref}`prop-lyapunov-necessity` for why this structure is mathematically necessary). It is designed to capture not only the distance *between* the swarms, but also the internal disorder *within* each swarm, which is the primary target of the cloning operator.\n758: \n759: :::{prf:definition} The Full Synergistic Hypocoercive Lyapunov Function\n760: :label: def-full-synergistic-lyapunov-function\n761: \n762: For any pair of swarm configurations $(S_1, S_2)$ with corresponding empirical measures $(\\mu_1, \\mu_2)$, the **total synergistic Lyapunov function** is defined as:\n763: \n764: $$\n765: V_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)\n766: $$\n767: \n768: where the intra-swarm variance term explicitly decomposes into positional and velocity components **summed over alive walkers only, but normalized by the total swarm size $N$**:\n769: \n770: $$\n771: V_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)\n772: $$\n773: \n774: with:\n775: \n776: $$\n777: \\begin{align*}\n778: V_{Var,x}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2 \\\\\n779: V_{Var,v}(S_1, S_2) &:= \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2\n780: \\end{align*}\n781: $$\n782: \n783: where $N$ is the total swarm size, $\\mathcal{A}(S_k)$ is the set of alive walker indices in swarm $k$, and $\\delta_{x,k,i}, \\delta_{v,k,i}$ are the centered vectors defined in {prf:ref}`def-barycentres-and-centered-vectors`.\n784: \n785: The function is a sum of three components:\n786: \n787: 1.  **The Inter-Swarm Error ($W_h^2$):** The squared hypocoercive 2-Wasserstein distance between the swarms' full empirical measures. This term quantifies the total permutation-invariant distance between the two swarms in phase space. As established in {prf:ref}`lem-wasserstein-decomposition`, this component can be exactly decomposed into:\n788:     *   A **Location Component ($V_{\\text{loc}}$)**, measuring the error between the swarm centers of mass.\n789:     *   A **Structural Component ($V_{\\text{struct}}$)**, measuring the mismatch in swarm shapes.\n790: \n791: 2.  **The Intra-Swarm Error ($V_{\\text{Var}}$):** The sum of the internal hypocoercive variances of each swarm. This term quantifies the internal dispersion or \"shape error\" *within* each individual swarm in phase space, measuring their lack of internal convergence in both position and velocity. This component is the primary target of the **synergistic dissipation framework**:\n792:     *   The **cloning operator** ($\\Psi_{\\text{clone}}$, analyzed in this document) provides powerful contraction of the positional variance component $V_{Var,x}$ but causes bounded expansion of the velocity variance component $V_{Var,v}$ through the velocity reset mechanism.\n793:     *   The **kinetic operator** ($\\Psi_{\\text{kin}}$, analyzed in the companion document) provides contraction of the velocity variance component $V_{Var,v}$ through Langevin dissipation but causes bounded expansion of the positional variance component $V_{Var,x}$ through diffusion.\n794:     *   When properly balanced, these two operators achieve **net contraction** of the total $V_{Var}$, enabling the system to converge in both position and velocity simultaneously.\n795: \n796: 3.  **The Boundary Potential ($W_b$):** A term that penalizes **alive** walkers approaching the boundary, constructed from the smooth barrier function $\\varphi_{\\text{barrier}}(x)$ defined in {prf:ref}`prop-barrier-existence`.\n797: \n798: \n799: $$\n800: W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n801: $$\n802: \n803:     where $N$ is the total swarm size and $\\mathcal{A}(S_k)$ denotes the set of alive walker indices in swarm $k$. Note that dead walkers do not contribute to the boundary potential.\n804: \n805: The parameters $b$ and $\\lambda_v > 0$ are the **hypocoercive parameters**. The constants $c_V > 0$ and $c_B > 0$ are small, positive **coupling constants** used in the analysis to balance the contributions of the different error components in the final drift inequality.\n806: \n807: :::{admonition} Normalization by $N$ vs. $k_{\\text{alive}}$ in the Lyapunov Function\n808: :class: important\n809: \n810: The Lyapunov function components $V_{\\text{Var}}$ and $W_b$ are normalized by the **total swarm size $N$**, not by the number of alive walkers $k_{\\text{alive}}$. This design choice is critical for mathematical tractability and deserves careful explanation:\n811: \n812: **Why This Choice Differs from Algorithm Internals:**\n813: \n814: The algorithm's internal fitness calculations (z-scores, variance measurements used for cloning decisions) correctly use $k_{\\text{alive}}$-normalization to compute statistics over the current active population. This is the physically and statistically correct choice for **decision-making**, as it accurately characterizes the distribution of alive walkers at each step.\n815: \n816: However, the Lyapunov function serves a different purpose: it is an **analytical tool** designed to prove long-term stability through drift analysis. For this purpose, $N$-normalization is mathematically necessary.\n817: \n818: **The Mathematical Necessity:**\n819: \n820: Consider the one-step change in the variance component:\n821: \n822: $$\n823: \\Delta V_{\\text{Var}} = V_{\\text{Var}}(S_{t+1}) - V_{\\text{Var}}(S_t)\n824: $$\n825: \n826: If $V_{\\text{Var}}$ were normalized by $k_{\\text{alive}}$, the drift calculation would become:\n827: \n828: $$\n829: \\mathbb{E}[\\Delta V_{\\text{Var}}] = \\mathbb{E}\\left[\\frac{1}{k_{t+1}} \\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\frac{1}{k_t} \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n830: $$\n831: \n832: This expression involves the **ratio of correlated random variables**: both the sum of squares and the number of alive walkers change stochastically at each step, and these changes are strongly coupled (e.g., if a high-variance walker dies, both the numerator and denominator change). The expectation of such a ratio cannot be simplified, making rigorous drift bounds essentially impossible to derive.\n833: \n834: With $N$-normalization, the constant factor $1/N$ factors out of the expectation:\n835: \n836: $$\n837: \\mathbb{E}[\\Delta V_{\\text{Var}}] = \\frac{1}{N} \\mathbb{E}\\left[\\sum_{i} \\|\\delta_{x,i}\\|^2_{t+1} - \\sum_{i} \\|\\delta_{x,i}\\|^2_t\\right]\n838: $$\n839: \n840: This allows the analysis to focus entirely on $\\mathbb{E}[\\Delta \\text{SumOfSquares}]$, which is the direct effect of the cloning and kinetic operators on the swarm's kinematic state. This is precisely what the Keystone Principle and the hypocoercive analysis are designed to bound.\n841: \n842: **The Mean-Field Interpretation:**\n843: \n844: The $N$-normalized variance can be interpreted as:\n845: \n846: $$\n847: V_{\\text{Var},x}(S_k) = \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_{\\text{alive}}(S_k)\n848: $$\n849: \n850: This represents the **mean-field contribution to system disorder per walker slot**. It scales with the fraction of alive walkers, which is exactly the correct behavior: if only a small fraction of walkers remain alive, the system's total disorder (as measured by the Lyapunov function) should reflect this reduced active mass.\n851: \n852: **The Viability Requirement:**\n853: \n854: This normalization implicitly assumes that the swarm remains viable, meaning $k_{\\text{alive}}/N$ is bounded away from zero. This is guaranteed by the framework's design:\n855: - The Safe Harbor Axiom ensures existence of a desirable region away from boundaries\n856: - The contractive properties of the cloning operator (Keystone Principle) and the confining potential prevent swarm collapse\n857: - The Lyapunov analysis operates in the regime where the swarm is stable, with extinction probability exponentially small\n858: \n859: **Conclusion:**\n860: \n861: The separation between algorithmic calculations (using $k_{\\text{alive}}$) and analytical tools (using $N$) is not a compromise but a hallmark of rigorous mean-field analysis. The algorithm uses the physically optimal metric for real-time decisions, while the Lyapunov function uses the mathematically tractable metric for proving convergence. Both serve their respective purposes correctly.\n862: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Defined for swarm configurations (S₁, S₂) with empirical measures (μ₁, μ₂)",
        "latex": null
      },
      {
        "type": null,
        "text": "V_total(S₁, S₂) = W_h²(μ₁, μ₂) + c_V V_Var(S₁, S₂) + c_B W_b(S₁, S₂)",
        "latex": "V_{\\mathrm{total}}(S_1, S_2) := W_h^2(\\mu_1, \\mu_2) + c_V V_{Var}(S_1, S_2) + c_B W_b(S_1, S_2)"
      },
      {
        "type": null,
        "text": "V_Var(S₁, S₂) = V_Var,x(S₁, S₂) + λ_v V_Var,v(S₁, S₂)",
        "latex": "V_{Var}(S_1, S_2) = V_{Var,x}(S_1, S_2) + \\lambda_v V_{Var,v}(S_1, S_2)"
      },
      {
        "type": null,
        "text": "V_Var,x(S₁, S₂) = (1/N) ∑_{i ∈ A(S₁)} ||δ_{x,1,i}||² + (1/N) ∑_{i ∈ A(S₂)} ||δ_{x,2,i}||²",
        "latex": "V_{Var,x}(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{x,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{x,2,i}\\|^2"
      },
      {
        "type": null,
        "text": "V_Var,v(S₁, S₂) = (1/N) ∑_{i ∈ A(S₁)} ||δ_{v,1,i}||² + (1/N) ∑_{i ∈ A(S₂)} ||δ_{v,2,i}||²",
        "latex": "V_{Var,v}(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\|\\delta_{v,1,i}\\|^2 + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\|\\delta_{v,2,i}\\|^2"
      },
      {
        "type": null,
        "text": "W_b(S₁, S₂) = (1/N) ∑_{i ∈ A(S₁)} φ_barrier(x_{1,i}) + (1/N) ∑_{i ∈ A(S₂)} φ_barrier(x_{2,i})",
        "latex": "W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})"
      }
    ],
    "properties": [
      {
        "name": "Inter-Swarm Error Component",
        "description": "Squared hypocoercive 2-Wasserstein distance W_h²(μ₁, μ₂), decomposable into location (V_loc) and structural (V_struct) errors measuring permutation-invariant phase-space distance between swarms."
      },
      {
        "name": "Intra-Swarm Error Component",
        "description": "Variance term V_Var capturing internal dispersion within each swarm, targeting synergistic contraction via cloning (positional) and kinetic (velocity) operators, summed over alive walkers and normalized by N."
      },
      {
        "name": "Boundary Potential Component",
        "description": "Penalty term W_b using barrier function φ_barrier to discourage alive walkers from approaching boundaries, normalized by N and excluding dead walkers."
      },
      {
        "name": "Normalization",
        "description": "All variance and boundary terms normalized by total swarm size N for analytical tractability in drift analysis, scaling with alive fraction k_alive/N."
      }
    ],
    "parameters": [
      {
        "symbol": "λ_v",
        "name": "velocity variance weight",
        "description": "Positive weighting factor for the velocity component in the intra-swarm variance.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "weight",
          "velocity"
        ]
      },
      {
        "symbol": "c_V",
        "name": "variance coupling constant",
        "description": "Positive constant balancing the intra-swarm variance term in the Lyapunov function.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "coupling",
          "variance"
        ]
      },
      {
        "symbol": "c_B",
        "name": "boundary coupling constant",
        "description": "Positive constant balancing the boundary potential term in the Lyapunov function.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "coupling",
          "boundary"
        ]
      },
      {
        "symbol": "b",
        "name": "hypocoercive parameter",
        "description": "Hypocoercive parameter used in the definition of the hypocoercive Wasserstein distance.",
        "constraints": [],
        "tags": [
          "hypocoercive",
          "parameter"
        ]
      },
      {
        "symbol": "N",
        "name": "total swarm size",
        "description": "Fixed total number of walkers in each swarm, used for normalization.",
        "constraints": [
          "> 0",
          "integer"
        ],
        "tags": [
          "swarm",
          "normalization"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "important",
        "text": "Normalization by N vs. k_alive: Uses total swarm size N for mathematical simplicity in expectations, avoiding ratios of random variables; interprets as mean-field disorder per walker slot, assuming viability with k_alive/N bounded away from zero via axioms and contractive properties."
      },
      {
        "type": "see-also",
        "text": "W_h² decomposes per Lemma on Wasserstein decomposition; δ vectors from definition of barycenters and centered vectors; φ_barrier from barrier existence proposition."
      },
      {
        "type": "analysis",
        "text": "Designed for hypocoercive drift analysis; parameters b, λ_v for hypocoercivity; c_V, c_B as small coupling constants for balancing in inequalities."
      }
    ],
    "related_refs": [
      "def-barycentres-and-centered-vectors",
      "lem-wasserstein-decomposition",
      "prop-barrier-existence"
    ],
    "tags": [
      "lyapunov-function",
      "synergistic",
      "hypocoercive",
      "swarm-dynamics",
      "wasserstein-distance",
      "intra-swarm-variance",
      "boundary-potential"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 757,
      "end_line": 862,
      "content_start": 760,
      "content_end": 861,
      "header_lines": [
        758,
        806
      ]
    },
    "references": [
      "def-barycentres-and-centered-vectors",
      "lem-wasserstein-decomposition",
      "prop-barrier-existence",
      "def-boundary-potential-recall"
    ],
    "metadata": {
      "label": "def-full-synergistic-lyapunov-function",
      "class": "important"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-variance-conversions",
    "type": "definition",
    "title": "Variance Notation Conversion Formulas",
    "term": "variance notation conversions",
    "object_type": "conversion formulas",
    "nl_definition": "Formulas defining and converting between three variance measures for a swarm k: the un-normalized sum of squared positional deviations S_k, the physical internal variance Var_k(x) normalized by the number of alive walkers, and the Lyapunov variance component V_{Var,x}(S_k) normalized by total walker slots N.",
    "content_markdown": ":label: def-variance-conversions\n\nFor a swarm $k$ with $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ alive walkers out of $N$ total walker slots:\n\n**1. Un-normalized Sum of Squared Deviations:**\n\n$$\nS_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2\n$$\n\nThis is the total positional variance without any normalization.\n\n**2. Physical Internal Variance ($k$-normalized):**\n\n$$\n\\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}\n$$\n\nThis is the average squared deviation per alive walker - the standard statistical variance.\n\n**3. Lyapunov Variance Component ($N$-normalized):**\n\n$$\nV_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}\n$$\n\nThis is the mean-field contribution to system disorder per walker slot.\n\n**Conversion Formulas:**\n\n$$\n\\begin{aligned}\nS_k &= k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k) \\\\\nV_{\\text{Var},x}(S_k) &= \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x) \\\\\n\\text{Var}_k(x) &= \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)\n\\end{aligned}\n$$\n\n**When converting between notations in proofs:**\n- From $S_k$ to $V_{\\text{Var},x}$: **divide by $N$**",
    "raw_directive": "869: To ensure clarity throughout the proofs, we explicitly state the relationships between the three variance concepts used in this document:\n870: \n871: :::{prf:definition} Variance Notation Conversion Formulas\n872: :label: def-variance-conversions\n873: \n874: For a swarm $k$ with $k_{\\text{alive}} = |\\mathcal{A}(S_k)|$ alive walkers out of $N$ total walker slots:\n875: \n876: **1. Un-normalized Sum of Squared Deviations:**\n877: \n878: $$\n879: S_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2\n880: $$\n881: \n882: This is the total positional variance without any normalization.\n883: \n884: **2. Physical Internal Variance ($k$-normalized):**\n885: \n886: $$\n887: \\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}\n888: $$\n889: \n890: This is the average squared deviation per alive walker - the standard statistical variance.\n891: \n892: **3. Lyapunov Variance Component ($N$-normalized):**\n893: \n894: $$\n895: V_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}\n896: $$\n897: \n898: This is the mean-field contribution to system disorder per walker slot.\n899: \n900: **Conversion Formulas:**\n901: \n902: $$\n903: \\begin{aligned}\n904: S_k &= k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k) \\\\\n905: V_{\\text{Var},x}(S_k) &= \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x) \\\\\n906: \\text{Var}_k(x) &= \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)\n907: \\end{aligned}\n908: $$\n909: \n910: **When converting between notations in proofs:**\n911: - From $S_k$ to $V_{\\text{Var},x}$: **divide by $N$**\n912: - From $\\text{Var}_k(x)$ to $V_{\\text{Var},x}$: **multiply by $\\frac{k_{\\text{alive}}}{N}$**",
    "formal_conditions": [
      {
        "type": null,
        "text": "Un-normalized Sum of Squared Deviations",
        "latex": "S_k := \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2"
      },
      {
        "type": null,
        "text": "Physical Internal Variance (k-normalized)",
        "latex": "\\text{Var}_k(x) := \\frac{1}{k_{\\text{alive}}} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{k_{\\text{alive}}}"
      },
      {
        "type": null,
        "text": "Lyapunov Variance Component (N-normalized)",
        "latex": "V_{\\text{Var},x}(S_k) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_k)} \\|\\delta_{x,k,i}\\|^2 = \\frac{S_k}{N}"
      },
      {
        "type": null,
        "text": "Basic Conversion",
        "latex": "S_k = k_{\\text{alive}} \\cdot \\text{Var}_k(x) = N \\cdot V_{\\text{Var},x}(S_k)"
      },
      {
        "type": null,
        "text": "From physical to Lyapunov",
        "latex": "V_{\\text{Var},x}(S_k) = \\frac{k_{\\text{alive}}}{N} \\cdot \\text{Var}_k(x)"
      },
      {
        "type": null,
        "text": "From Lyapunov to physical",
        "latex": "\\text{Var}_k(x) = \\frac{N}{k_{\\text{alive}}} \\cdot V_{\\text{Var},x}(S_k)"
      }
    ],
    "properties": [
      {
        "name": "Un-normalized Sum of Squared Deviations",
        "description": "Total positional variance without any normalization."
      },
      {
        "name": "Physical Internal Variance",
        "description": "Average squared deviation per alive walker - the standard statistical variance."
      },
      {
        "name": "Lyapunov Variance Component",
        "description": "Mean-field contribution to system disorder per walker slot."
      }
    ],
    "parameters": [
      {
        "symbol": "N",
        "name": "Total walker slots",
        "description": "Total number of walker slots in the swarm",
        "constraints": [
          "positive integer"
        ],
        "tags": [
          "swarm",
          "total"
        ]
      },
      {
        "symbol": "k_alive",
        "name": "Number of alive walkers",
        "description": "Number of alive walkers in swarm k, equal to |A(S_k)|",
        "constraints": [
          "integer",
          "0 <= k_alive <= N"
        ],
        "tags": [
          "swarm",
          "alive"
        ]
      },
      {
        "symbol": "S_k",
        "name": "Un-normalized Sum of Squared Deviations",
        "description": "Total positional variance without normalization",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "unnormalized"
        ]
      },
      {
        "symbol": "Var_k(x)",
        "name": "Physical Internal Variance",
        "description": "k-normalized average squared deviation per alive walker",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "internal"
        ]
      },
      {
        "symbol": "V_{Var,x}(S_k)",
        "name": "Lyapunov Variance Component",
        "description": "N-normalized mean-field contribution to system disorder per walker slot",
        "constraints": [
          "non-negative real"
        ],
        "tags": [
          "variance",
          "lyapunov"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "conversion guide",
        "text": "When converting between notations in proofs: - From S_k to V_{Var,x}(S_k): divide by N - From Var_k(x) to V_{Var,x}(S_k): multiply by k_alive / N"
      }
    ],
    "related_refs": [],
    "tags": [
      "variance",
      "notation",
      "conversion",
      "swarm",
      "normalization",
      "lyapunov",
      "walkers",
      "deviations"
    ],
    "document_id": "03_cloning",
    "section": "## 3. The Augmented Hypocoercive Lyapunov Function",
    "span": {
      "start_line": 869,
      "end_line": 912,
      "content_start": 872,
      "content_end": 911,
      "header_lines": [
        870
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-variance-conversions"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Augmented Hypocoercive Lyapunov Function"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-algorithmic-distance-metric",
    "type": "definition",
    "title": "Algorithmic Distance for Companion Selection",
    "term": "algorithmic distance",
    "object_type": "metric",
    "nl_definition": "The squared algorithmic distance between two walkers is the sum of the squared Euclidean norm of their position difference and a weighted squared Euclidean norm of their velocity difference.",
    "content_markdown": ":label: def-algorithmic-distance-metric\n\nFor any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$, the **algorithmic distance** between them is defined as:\n\n$$\nd_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2\n$$\n\nwhere $\\lambda_{\\text{alg}} \\geq 0$ is a fixed algorithmic parameter that controls the relative importance of velocity similarity in the pairing and selection processes.",
    "raw_directive": "1365: Before defining the measurement operators, we must first establish the fundamental metric that quantifies proximity between walkers. This metric is central to all intra-swarm measurements in the algorithm, including companion selection for diversity measurement and companion selection for cloning.\n1366: \n1367: :::{prf:definition} Algorithmic Distance for Companion Selection\n1368: :label: def-algorithmic-distance-metric\n1369: \n1370: For any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$, the **algorithmic distance** between them is defined as:\n1371: \n1372: $$\n1373: d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2\n1374: $$\n1375: \n1376: where $\\lambda_{\\text{alg}} \\geq 0$ is a fixed algorithmic parameter that controls the relative importance of velocity similarity in the pairing and selection processes.\n1377: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "For any two walkers $i$ and $j$ with states $(x_i, v_i)$ and $(x_j, v_j)$",
        "latex": null
      },
      {
        "type": null,
        "text": null,
        "latex": "d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "\\lambda_{\\text{alg}}",
        "name": "lambda_alg",
        "description": "Weighting factor for the velocity difference component in the algorithmic distance metric.",
        "constraints": [],
        "tags": [
          "weight",
          "parameter",
          "velocity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This metric quantifies proximity between walkers and is central to intra-swarm measurements, including companion selection for diversity and cloning."
      }
    ],
    "related_refs": [],
    "tags": [
      "distance",
      "metric",
      "algorithmic",
      "companion-selection",
      "walkers",
      "position",
      "velocity",
      "euclidean"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1365,
      "end_line": 1377,
      "content_start": 1368,
      "content_end": 1376,
      "header_lines": [
        1366
      ]
    },
    "references": [
      "def-greedy-pairing-algorithm",
      "def-spatial-pairing-operator-diversity"
    ],
    "metadata": {
      "label": "def-algorithmic-distance-metric"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-spatial-pairing-operator-diversity",
    "type": "definition",
    "title": "Spatially-Aware Pairing Operator (Idealized Model)",
    "term": "Spatially-Aware Pairing Operator",
    "object_type": "operator",
    "nl_definition": "An operator that maps the alive set of walkers to a probability distribution over all possible perfect matchings, where probabilities are assigned based on the product of edge weights computed from exponential decay of squared algorithmic distances between paired walkers, normalized by the partition function.",
    "content_markdown": ":label: def-spatial-pairing-operator-diversity\n\nLet $\\mathcal{S}_t$ be the current swarm state with alive set $\\mathcal{A}_t$ of size $k = |\\mathcal{A}_t|$. The idealized **Spatially-Aware Pairing Operator**, denoted $\\mathbb{P}_{\\text{pair}}$, maps the alive set $\\mathcal{A}_t$ to a probability distribution over the set of all possible perfect matchings, $\\mathcal{M}_k$.\n\n**Inputs:**\n*   The alive set of walkers, $\\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\}$.\n*   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n\n**Operation:**\n1.  For every pair of distinct walkers $(w_i, w_j)$, an edge weight is assigned based on their phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n\n\n$$\nw_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n$$\n\n2.  The \"quality\" of a specific perfect matching `M` is the product of the weights of the edges it contains:\n\n\n$$\nW(M) := \\prod_{(i,j) \\in M} w_{ij}\n$$\n\n3.  The probability of selecting a specific matching `M` is given by its quality normalized by the sum of qualities over all possible matchings (the partition function):\n\n\n$$\nP(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}",
    "raw_directive": "1409: For the purposes of theoretical analysis, it is useful to model the pairing as a single, collective draw from a probability distribution over all possible perfect matchings of the alive set. This idealized model captures the physical intent of the operator—to strongly favor pairings between walkers that are close in the algorithmic space.\n1410: \n1411: :::{prf:definition} Spatially-Aware Pairing Operator (Idealized Model)\n1412: :label: def-spatial-pairing-operator-diversity\n1413: \n1414: Let $\\mathcal{S}_t$ be the current swarm state with alive set $\\mathcal{A}_t$ of size $k = |\\mathcal{A}_t|$. The idealized **Spatially-Aware Pairing Operator**, denoted $\\mathbb{P}_{\\text{pair}}$, maps the alive set $\\mathcal{A}_t$ to a probability distribution over the set of all possible perfect matchings, $\\mathcal{M}_k$.\n1415: \n1416: **Inputs:**\n1417: *   The alive set of walkers, $\\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\}$.\n1418: *   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n1419: \n1420: **Operation:**\n1421: 1.  For every pair of distinct walkers $(w_i, w_j)$, an edge weight is assigned based on their phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n1422: \n1423: \n1424: $$\n1425: w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n1426: $$\n1427: \n1428: 2.  The \"quality\" of a specific perfect matching `M` is the product of the weights of the edges it contains:\n1429: \n1430: \n1431: $$\n1432: W(M) := \\prod_{(i,j) \\in M} w_{ij}\n1433: $$\n1434: \n1435: 3.  The probability of selecting a specific matching `M` is given by its quality normalized by the sum of qualities over all possible matchings (the partition function):\n1436: \n1437: \n1438: $$\n1439: P(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}\n1440: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Edge weight assignment",
        "latex": "w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)"
      },
      {
        "type": null,
        "text": "Quality of a matching M",
        "latex": "W(M) := \\prod_{(i,j) \\in M} w_{ij}"
      },
      {
        "type": null,
        "text": "Probability of selecting matching M",
        "latex": "P(M) = \\frac{W(M)}{\\sum_{M' \\in \\mathcal{M}_k} W(M')}"
      },
      {
        "type": null,
        "text": "Input alive set size",
        "latex": "k = |\\mathcal{A}_t|"
      },
      {
        "type": null,
        "text": "Domain",
        "latex": "\\mathbb{P}_{\\text{pair}}: \\mathcal{A}_t \\to \\text{Dist}(\\mathcal{M}_k)"
      }
    ],
    "properties": [
      {
        "name": "Inputs",
        "description": "The alive set of walkers \\mathcal{A}_t = \\{w_1, w_2, \\dots, w_k\\} and \\varepsilon_d > 0 (Interaction Range for Diversity)."
      },
      {
        "name": "Output",
        "description": "A probability distribution over the set of all possible perfect matchings \\mathcal{M}_k."
      },
      {
        "name": "Weight Function",
        "description": "Gaussian-like weight based on algorithmic distance d_{\\text{alg}}(i,j)."
      },
      {
        "name": "Normalization",
        "description": "Probabilities sum to 1 via the partition function \\sum_{M' \\in \\mathcal{M}_k} W(M')."
      }
    ],
    "parameters": [
      {
        "symbol": "\\varepsilon_d",
        "name": "Interaction Range for Diversity",
        "description": "The Interaction Range for Diversity.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "diversity",
          "range",
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "For the purposes of theoretical analysis, it is useful to model the pairing as a single, collective draw from a probability distribution over all possible perfect matchings of the alive set. This idealized model captures the physical intent of the operator—to strongly favor pairings between walkers that are close in the algorithmic space."
      }
    ],
    "related_refs": [],
    "tags": [
      "spatial",
      "pairing",
      "operator",
      "idealized",
      "diversity",
      "probability",
      "matching",
      "swarm",
      "walkers"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1409,
      "end_line": 1440,
      "content_start": 1412,
      "content_end": 1439,
      "header_lines": [
        1410
      ]
    },
    "references": [
      "def-algorithmic-distance-metric"
    ],
    "metadata": {
      "label": "def-spatial-pairing-operator-diversity"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-greedy-pairing-algorithm",
    "type": "definition",
    "title": "Sequential Stochastic Greedy Pairing Operator",
    "term": "Sequential Stochastic Greedy Pairing Operator",
    "object_type": "algorithm",
    "nl_definition": "An iterative stochastic algorithm that constructs a matching among alive walkers by sequentially selecting an unpaired walker, computing proximity-based probabilities over remaining unpaired walkers, sampling a companion, and updating the companion map until at most one walker remains unpaired.",
    "content_markdown": ":label: def-greedy-pairing-algorithm\n\nLet `A_t` be the set of `k` alive walkers at time `t`. The pairing operator generates a **Companion Map**, `c: A_t → A_t`, which is a perfect matching if `k` is even, or a maximal matching if `k` is odd.\n\n**Inputs:**\n*   The set of alive walkers, `A_t = {w_1, w_2, ..., w_k}`.\n*   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n\n**Operation:**\n1.  Initialize a set of unpaired walkers `U ← A_t` and an empty companion map `c`.\n2.  While `|U| > 1`:\n    a. Select and remove an arbitrary walker `i` from `U`.\n    b. For each remaining walker $j \\in U$, calculate the selection weight based on phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n\n\n$$\nw_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n$$\n\n    c. Form a probability distribution over $j \\in U$ where $P(\\text{choose } j) = w_{ij} / (\\sum_{l \\in U} w_{il})$.\n    d. Sample a companion `c_i` for `i` from this distribution.\n    e. Remove `c_i` from `U`.\n    f. Set the pairing in the companion map: `c(i) ← c_i` and `c(c_i) ← i`.\n3.  Return the completed companion map `c`.\n\n**Complexity:** The outer loop runs `k/2` times. In each iteration, the weights and normalization factor are computed over the remaining walkers (at most `k-1`). The complexity is therefore `O(k^2)`, which is a feasible computation.",
    "raw_directive": "1448: This algorithm builds the matching iteratively. It selects an unpaired walker, computes a probability distribution over all other currently unpaired walkers based on proximity, samples a companion, and removes the new pair from the pool. This reduces the computational complexity from factorial to quadratic, making it practical for large swarms.\n1449: \n1450: :::{prf:definition} Sequential Stochastic Greedy Pairing Operator\n1451: :label: def-greedy-pairing-algorithm\n1452: \n1453: Let `A_t` be the set of `k` alive walkers at time `t`. The pairing operator generates a **Companion Map**, `c: A_t → A_t`, which is a perfect matching if `k` is even, or a maximal matching if `k` is odd.\n1454: \n1455: **Inputs:**\n1456: *   The set of alive walkers, `A_t = {w_1, w_2, ..., w_k}`.\n1457: *   $\\varepsilon_d > 0$ (The Interaction Range for Diversity).\n1458: \n1459: **Operation:**\n1460: 1.  Initialize a set of unpaired walkers `U ← A_t` and an empty companion map `c`.\n1461: 2.  While `|U| > 1`:\n1462:     a. Select and remove an arbitrary walker `i` from `U`.\n1463:     b. For each remaining walker $j \\in U$, calculate the selection weight based on phase-space proximity using the algorithmic distance metric (see {prf:ref}`def-algorithmic-distance-metric`):\n1464: \n1465: \n1466: $$\n1467: w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)\n1468: $$\n1469: \n1470:     c. Form a probability distribution over $j \\in U$ where $P(\\text{choose } j) = w_{ij} / (\\sum_{l \\in U} w_{il})$.\n1471:     d. Sample a companion `c_i` for `i` from this distribution.\n1472:     e. Remove `c_i` from `U`.\n1473:     f. Set the pairing in the companion map: `c(i) ← c_i` and `c(c_i) ← i`.\n1474: 3.  Return the completed companion map `c`.\n1475: \n1476: **Complexity:** The outer loop runs `k/2` times. In each iteration, the weights and normalization factor are computed over the remaining walkers (at most `k-1`). The complexity is therefore `O(k^2)`, which is a feasible computation.\n1477: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Initialize unpaired set U ← A_t and empty companion map c.",
        "latex": null
      },
      {
        "type": null,
        "text": "While |U| > 1: Select arbitrary i from U and remove it.",
        "latex": null
      },
      {
        "type": null,
        "text": "For each j in U, compute weight w_{ij} = exp(-d_alg(i, j)^2 / (2 ε_d^2)).",
        "latex": "w_{ij} := \\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_d^2}\\right)"
      },
      {
        "type": null,
        "text": "Form probability P(choose j) = w_{ij} / sum_{l in U} w_{il}.",
        "latex": null
      },
      {
        "type": null,
        "text": "Sample c_i from this distribution, remove c_i from U.",
        "latex": null
      },
      {
        "type": null,
        "text": "Set c(i) ← c_i and c(c_i) ← i.",
        "latex": null
      },
      {
        "type": null,
        "text": "Return companion map c.",
        "latex": null
      }
    ],
    "properties": [
      {
        "name": "Output",
        "description": "Generates a companion map c: A_t → A_t, a perfect matching if k even, or maximal matching if k odd."
      },
      {
        "name": "Complexity",
        "description": "Reduces computational complexity from factorial to quadratic by iterative greedy selection."
      },
      {
        "name": "Stochasticity",
        "description": "Companion selection is probabilistic based on proximity weights."
      }
    ],
    "parameters": [
      {
        "symbol": "A_t",
        "name": "Set of Alive Walkers",
        "description": "The set of k alive walkers at time t.",
        "constraints": [
          "finite set",
          "|A_t| = k"
        ],
        "tags": [
          "walkers",
          "set"
        ]
      },
      {
        "symbol": "\\varepsilon_d",
        "name": "Interaction Range for Diversity",
        "description": "Positive parameter controlling the scale of proximity in selection weights.",
        "constraints": [
          "\\varepsilon_d > 0"
        ],
        "tags": [
          "range",
          "diversity",
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "motivation",
        "text": "This algorithm builds the matching iteratively. It selects an unpaired walker, computes a probability distribution over all other currently unpaired walkers based on proximity, samples a companion, and removes the new pair from the pool. This reduces the computational complexity from factorial to quadratic, making it practical for large swarms."
      }
    ],
    "related_refs": [],
    "tags": [
      "greedy",
      "pairing",
      "stochastic",
      "sequential",
      "algorithm",
      "matching",
      "walkers",
      "proximity"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1448,
      "end_line": 1477,
      "content_start": 1451,
      "content_end": 1476,
      "header_lines": [
        1449
      ]
    },
    "references": [
      "def-algorithmic-distance-metric",
      "lem-greedy-preserves-signal",
      "thm-geometry-guarantees-variance"
    ],
    "metadata": {
      "label": "def-greedy-pairing-algorithm"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-geometric-partition",
    "type": "definition",
    "title": "Geometric Partitioning of High-Variance Swarms",
    "term": "geometric partitioning",
    "object_type": "partition",
    "nl_definition": "A phase-space partitioning of a high-variance swarm (with Var(x) > R_var^2) into two non-empty N-uniform sets: a high-error set of kinematically isolated walkers and a low-error set forming dense local clusters, for a given interaction range ε.",
    "content_markdown": ":label: def-geometric-partition\n\nFor a given interaction range $\\varepsilon$, we define a swarm's phase-space structure based on local and global properties. As will be proven in **{prf:ref}`cor-vvarx-to-high-error-fraction`**, any swarm with sufficiently high variance (`Var(x) > R^{2}_var`) can be partitioned into two non-empty, N-uniform sets:\n1.  A **high-error set** `H_k`, whose members are **kinematically isolated** in phase space. This implies the existence of a distance $D_H(\\varepsilon) > 0$ such that for any $i \\in H_k$, all other walkers `j` are at an algorithmic distance $d_alg(i, j) > D_H(\\varepsilon)$.\n2.  A **low-error set** `L_k`, whose members are part of dense clusters in phase space. For any $j \\in L_k$, there is a non-empty subset of other walkers `C_j ⊂ L_k` of size $|C_j| \\geq f_c k$ (for some N-uniform `f_c > 0`) located within an algorithmic radius $R_L(\\varepsilon) < D_H(\\varepsilon)$.\n\nThe existence and N-uniformity of these sets, their fractions, and their characteristic distances are the central results of the geometric analysis in Chapter 6. For this section, we take these as given structural properties of a high-variance swarm.",
    "raw_directive": "1536: First, we must formalize the geometric partitioning of the swarm that is guaranteed to exist in a high-variance state, a result that will be proven in full detail in Chapter 6.\n1537: \n1538: :::{prf:definition} Geometric Partitioning of High-Variance Swarms\n1539: :label: def-geometric-partition\n1540: \n1541: For a given interaction range $\\varepsilon$, we define a swarm's phase-space structure based on local and global properties. As will be proven in **{prf:ref}`cor-vvarx-to-high-error-fraction`**, any swarm with sufficiently high variance (`Var(x) > R^{2}_var`) can be partitioned into two non-empty, N-uniform sets:\n1542: 1.  A **high-error set** `H_k`, whose members are **kinematically isolated** in phase space. This implies the existence of a distance $D_H(\\varepsilon) > 0$ such that for any $i \\in H_k$, all other walkers `j` are at an algorithmic distance $d_alg(i, j) > D_H(\\varepsilon)$.\n1543: 2.  A **low-error set** `L_k`, whose members are part of dense clusters in phase space. For any $j \\in L_k$, there is a non-empty subset of other walkers `C_j ⊂ L_k` of size $|C_j| \\geq f_c k$ (for some N-uniform `f_c > 0`) located within an algorithmic radius $R_L(\\varepsilon) < D_H(\\varepsilon)$.\n1544: \n1545: The existence and N-uniformity of these sets, their fractions, and their characteristic distances are the central results of the geometric analysis in Chapter 6. For this section, we take these as given structural properties of a high-variance swarm.\n1546: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "The swarm S satisfies Var(x) > R_var^2, where x denotes positions.",
        "latex": "\\operatorname{Var}(x) > R_{\\var}^2"
      },
      {
        "type": null,
        "text": "S is partitioned into non-empty, N-uniform sets H_k and L_k (disjoint union).",
        "latex": "S = H_k \\sqcup L_k, \\, |H_k| \\geq cN, \\, |L_k| \\geq cN \\, (c > 0 \\, N\\text{-uniform})"
      },
      {
        "type": null,
        "text": "For H_k (high-error): exists D_H(ε) > 0 such that ∀ i ∈ H_k, ∀ j ≠ i, d_alg(i, j) > D_H(ε) (kinematically isolated).",
        "latex": "\\exists D_H(\\varepsilon) > 0: \\, \\forall i \\in H_k, \\, \\forall j \\neq i, \\, d_{\\alg}(i,j) > D_H(\\varepsilon)"
      },
      {
        "type": null,
        "text": "For L_k (low-error): ∀ j ∈ L_k, ∃ C_j ⊂ L_k non-empty with |C_j| ≥ f_c k (f_c > 0 N-uniform) s.t. all in C_j within algorithmic radius R_L(ε) < D_H(ε) from j.",
        "latex": "\\forall j \\in L_k, \\, \\exists C_j \\subset L_k, \\, |C_j| \\geq f_c k \\, (f_c > 0 \\, N\\text{-uniform}), \\, \\forall i \\in C_j, \\, d_{\\alg}(i,j) \\leq R_L(\\varepsilon) < D_H(\\varepsilon)"
      }
    ],
    "properties": [
      {
        "name": "High-Error Set H_k",
        "description": "Consists of kinematically isolated walkers, separated from all others by at least D_H(ε) in algorithmic distance."
      },
      {
        "name": "Low-Error Set L_k",
        "description": "Consists of walkers each belonging to a dense local cluster of at least f_c k others within R_L(ε)."
      },
      {
        "name": "N-Uniformity",
        "description": "Both H_k and L_k are non-empty with sizes bounded below by a positive fraction of the total swarm size N."
      },
      {
        "name": "Phase-Space Basis",
        "description": "Defined using local (cluster isolation) and global (variance) properties for interaction range ε."
      }
    ],
    "parameters": [
      {
        "symbol": "\\varepsilon",
        "name": "interaction range",
        "description": "The given interaction range defining the swarm's phase-space structure.",
        "constraints": [],
        "tags": [
          "range",
          "interaction"
        ]
      },
      {
        "symbol": "R_{\\var}^2",
        "name": "variance threshold",
        "description": "Threshold determining high-variance state: Var(x) > R_{\\var}^2.",
        "constraints": [
          "R_{\\var}^2 > 0"
        ],
        "tags": [
          "threshold",
          "variance"
        ]
      },
      {
        "symbol": "k",
        "name": "set index",
        "description": "Index parameterizing the partitioned sets H_k and L_k.",
        "constraints": [],
        "tags": [
          "index",
          "partition"
        ]
      },
      {
        "symbol": "f_c",
        "name": "cluster fraction",
        "description": "Positive N-uniform fraction bounding the minimum size of local clusters in L_k.",
        "constraints": [
          "f_c > 0",
          "N-uniform"
        ],
        "tags": [
          "fraction",
          "cluster"
        ]
      },
      {
        "symbol": "D_H(\\varepsilon)",
        "name": "isolation distance",
        "description": "Positive distance ensuring kinematic isolation for members of H_k.",
        "constraints": [
          "D_H(\\varepsilon) > 0"
        ],
        "tags": [
          "distance",
          "isolation"
        ]
      },
      {
        "symbol": "R_L(\\varepsilon)",
        "name": "cluster radius",
        "description": "Algorithmic radius for dense clusters in L_k, smaller than the isolation distance.",
        "constraints": [
          "R_L(\\varepsilon) < D_H(\\varepsilon)"
        ],
        "tags": [
          "radius",
          "cluster"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "proof-reference",
        "text": "Existence guaranteed by cor-vvarx-to-high-error-fraction."
      },
      {
        "type": "future-proof",
        "text": "Full detailed proof provided in Chapter 6."
      },
      {
        "type": "context",
        "text": "Applies to swarms in high-variance states based on phase-space structure."
      }
    ],
    "related_refs": [
      "cor-vvarx-to-high-error-fraction"
    ],
    "tags": [
      "geometric-partitioning",
      "high-variance-swarms",
      "phase-space-structure",
      "high-error-set",
      "low-error-set",
      "kinematic-isolation",
      "dense-clusters",
      "N-uniform"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1536,
      "end_line": 1546,
      "content_start": 1539,
      "content_end": 1545,
      "header_lines": [
        1537
      ]
    },
    "references": [
      "cor-vvarx-to-high-error-fraction",
      "lem-greedy-preserves-signal"
    ],
    "metadata": {
      "label": "def-geometric-partition"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-raw-value-operators",
    "type": "definition",
    "title": "Raw Value Operators",
    "term": "Raw Value Operators",
    "object_type": "Operators",
    "nl_definition": "Operators that deterministically measure raw reward and paired distance for alive walkers after fixing the companion map.",
    "content_markdown": ":label: def-raw-value-operators\n\n1.  **The Reward Measurement Operator ($V_R$):** The raw reward for each alive walker `i` is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components:\n\n\n$$\nr_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v\\_reg} \\|v_i\\|^2\n$$\n\n    where $R_{\\text{pos}}(x_i)$ is the positional reward and $c_{v\\_reg} > 0$ is the velocity regularization coefficient from {prf:ref}`axiom-velocity-regularization`.\n\n2.  **The Paired Distance Measurement Operator ($V_D$):** Given the Companion Map `c(i)` generated by the pairing operator, the raw distance for each alive walker `i` is deterministically defined as the algorithmic distance to its assigned companion:\n\n\n$$\nd_i := d_{\\text{alg}}(i, c(i))\n$$\n\nFor any walker `j` that is dead, its raw values are deterministically zero: $r_j = 0$ and $d_j = 0$.",
    "raw_directive": "1763: Once the Companion Map `c(i)` is fixed for the timestep by the pairing operator, the measurement of raw values for each walker becomes a deterministic process.\n1764: \n1765: :::{prf:definition} Raw Value Operators\n1766: :label: def-raw-value-operators\n1767: \n1768: 1.  **The Reward Measurement Operator ($V_R$):** The raw reward for each alive walker `i` is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components:\n1769: \n1770: \n1771: $$\n1772: r_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v\\_reg} \\|v_i\\|^2\n1773: $$\n1774: \n1775:     where $R_{\\text{pos}}(x_i)$ is the positional reward and $c_{v\\_reg} > 0$ is the velocity regularization coefficient from {prf:ref}`axiom-velocity-regularization`.\n1776: \n1777: 2.  **The Paired Distance Measurement Operator ($V_D$):** Given the Companion Map `c(i)` generated by the pairing operator, the raw distance for each alive walker `i` is deterministically defined as the algorithmic distance to its assigned companion:\n1778: \n1779: \n1780: $$\n1781: d_i := d_{\\text{alg}}(i, c(i))\n1782: $$\n1783: \n1784: For any walker `j` that is dead, its raw values are deterministically zero: $r_j = 0$ and $d_j = 0$.\n1785: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "The Reward Measurement Operator (V_R): The raw reward for each alive walker i is its direct, individual measurement of the reward function, which explicitly includes both positional and velocity components: r_i := R(x_i, v_i) = R_pos(x_i) - c_{v_reg} ||v_i||^2 where R_pos(x_i) is the positional reward and c_{v_reg} > 0 is the velocity regularization coefficient from Axiom EG-4.",
        "latex": "r_i := R(x_i, v_i) = R_{\\text{pos}}(x_i) - c_{v_{\\reg}} \\|v_i\\|^2"
      },
      {
        "type": null,
        "text": "The Paired Distance Measurement Operator (V_D): Given the Companion Map c(i) generated by the pairing operator, the raw distance for each alive walker i is deterministically defined as the algorithmic distance to its assigned companion: d_i := d_alg(i, c(i))",
        "latex": "d_i := d_{\\text{alg}}(i, c(i))"
      }
    ],
    "properties": [
      {
        "name": "Deterministic",
        "description": "Measurements are deterministic once the companion map is fixed by the pairing operator."
      },
      {
        "name": "Individual",
        "description": "Reward measurement is direct and individual for each walker, including position and velocity components."
      },
      {
        "name": "Paired",
        "description": "Distance measurement uses the assigned companion from the map."
      }
    ],
    "parameters": [
      {
        "symbol": "c_{v_reg}",
        "name": "velocity regularization coefficient",
        "description": "Positive coefficient penalizing walker velocity in reward function",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "regularization",
          "velocity",
          "coefficient"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "introductory",
        "text": "Once the Companion Map c(i) is fixed for the timestep by the pairing operator, the measurement of raw values for each walker becomes a deterministic process."
      }
    ],
    "related_refs": [],
    "tags": [
      "raw-value",
      "operators",
      "reward",
      "distance",
      "measurement",
      "walkers",
      "pairing"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1763,
      "end_line": 1785,
      "content_start": 1766,
      "content_end": 1784,
      "header_lines": [
        1764
      ]
    },
    "references": [
      "axiom-velocity-regularization",
      "def-measurement-operator"
    ],
    "metadata": {
      "label": "def-raw-value-operators"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-swarm-aggregation-operator",
    "type": "definition",
    "title": "Swarm Aggregation Operator",
    "term": "Swarm Aggregation Operator",
    "object_type": "operator",
    "nl_definition": "An operator that processes raw reward and distance vectors from the k alive walkers to compute summary statistics, specifically the mean and standard deviation, for subsequent standardization.",
    "content_markdown": ":label: def-swarm-aggregation-operator\n\nA **Swarm Aggregation Operator**, $M$, maps the `k`-dimensional raw value vector $\\mathbf{v}_{\\mathcal{A}}$ from the alive set of a swarm state $\\mathcal{S}$ (see {prf:ref}`def-single-swarm-space`) to a probability measure on $\\mathbb{R}$, $\\mu_{\\mathbf{v}} = M(\\mathcal{S}, \\mathbf{v}_{\\mathcal{A}})$. The moments of this measure define the swarm's collective statistics.",
    "raw_directive": "1803: This stage distills the raw reward and distance vectors from the `k` alive walkers into the summary statistics (mean and standard deviation) required for standardization.\n1804: \n1805: :::{prf:definition} Swarm Aggregation Operator\n1806: :label: def-swarm-aggregation-operator\n1807: \n1808: A **Swarm Aggregation Operator**, $M$, maps the `k`-dimensional raw value vector $\\mathbf{v}_{\\mathcal{A}}$ from the alive set of a swarm state $\\mathcal{S}$ (see {prf:ref}`def-single-swarm-space`) to a probability measure on $\\mathbb{R}$, $\\mu_{\\mathbf{v}} = M(\\mathcal{S}, \\mathbf{v}_{\\mathcal{A}})$. The moments of this measure define the swarm's collective statistics.\n1809: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [
      {
        "symbol": "k",
        "name": "k",
        "description": "The number of alive walkers providing the raw reward and distance vectors.",
        "constraints": [],
        "tags": [
          "walkers"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "swarm",
      "aggregation",
      "operator",
      "walkers",
      "reward",
      "distance",
      "standardization",
      "statistics"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1803,
      "end_line": 1809,
      "content_start": 1806,
      "content_end": 1808,
      "header_lines": [
        1804
      ]
    },
    "references": [
      "def-single-swarm-space",
      "def-standardization-operator"
    ],
    "metadata": {
      "label": "def-swarm-aggregation-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-patched-std-dev-function",
    "type": "definition",
    "title": "Patched Standard Deviation Function",
    "term": "\\sigma'_{\\text{patch}}",
    "object_type": "function",
    "nl_definition": "A C^1 smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero, defined piecewise in terms of the raw variance V.",
    "content_markdown": ":label: def-patched-std-dev-function\n\nThe **Patched Standard Deviation Function**, $\\sigma'_{\\text{patch}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$, is a $C^1$ smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero. It is defined piecewise in terms of the raw variance, $V := \\operatorname{Var}[\\mu_{\\mathbf{v}}]$:\n\n$$\n\\sigma'_{\\text{patch}}(V) :=\n\\begin{cases}\n\\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\mathrm{std}}^2}, & V \\le \\kappa_{\\text{var,min}} \\\\\nP(V), & \\kappa_{\\text{var,min}} < V < 2\\kappa_{\\text{var,min}} \\\\\n\\sqrt{V + \\varepsilon_{\\mathrm{std}}^2}, & V \\ge 2\\kappa_{\\text{var,min}}\n\\end{cases}\n$$",
    "raw_directive": "1818: A critical component of this stage is the use of a robust, smooth function (see {prf:ref}`def-patched-std-dev-function`) to compute the standard deviation, which is essential for the stability of the entire pipeline.\n1819: \n1820: :::{prf:definition} Patched Standard Deviation Function\n1821: :label: def-patched-std-dev-function\n1822: \n1823: The **Patched Standard Deviation Function**, $\\sigma'_{\\text{patch}}: \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}_{>0}$, is a $C^1$ smooth replacement for the standard square-root function, designed to be globally Lipschitz and bounded away from zero. It is defined piecewise in terms of the raw variance, $V := \\operatorname{Var}[\\mu_{\\mathbf{v}}]$:\n1824: \n1825: $$\n1826: \\sigma'_{\\text{patch}}(V) :=\n1827: \\begin{cases}\n1828: \\sqrt{\\kappa_{\\text{var,min}} + \\varepsilon_{\\mathrm{std}}^2}, & V \\le \\kappa_{\\text{var,min}} \\\\\n1829: P(V), & \\kappa_{\\text{var,min}} < V < 2\\kappa_{\\text{var,min}} \\\\\n1830: \\sqrt{V + \\varepsilon_{\\mathrm{std}}^2}, & V \\ge 2\\kappa_{\\text{var,min}}\n1831: \\end{cases}\n1832: $$\n1833: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [
      {
        "symbol": "\\kappa_{\\text{var,min}}",
        "name": "minimum variance threshold",
        "description": "The lower bound threshold for variance to ensure stability.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "threshold",
          "variance",
          "minimum"
        ]
      },
      {
        "symbol": "\\varepsilon_{\\mathrm{std}}",
        "name": "standard deviation epsilon",
        "description": "Regularization parameter added to prevent zero or near-zero standard deviation.",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "epsilon",
          "regularization",
          "stability"
        ]
      },
      {
        "symbol": "P",
        "name": "smoothing polynomial",
        "description": "A C^1 smooth polynomial used for interpolation in the transition region.",
        "constraints": [
          "C^1 smooth"
        ],
        "tags": [
          "polynomial",
          "interpolation",
          "smooth"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "standard-deviation",
      "patched",
      "smooth-function",
      "lipschitz",
      "variance"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1818,
      "end_line": 1833,
      "content_start": 1821,
      "content_end": 1832,
      "header_lines": [
        1819
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-patched-std-dev-function"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-standardization-operator",
    "type": "definition",
    "title": "N-Dimensional Standardization Operator",
    "term": "N-Dimensional Standardization Operator",
    "object_type": "operator",
    "nl_definition": "The N-Dimensional Standardization Operator, denoted z, maps a swarm state S, a raw value vector v, and an aggregation operator M to an N-dimensional vector of standardized Z-scores.",
    "content_markdown": ":label: def-standardization-operator\n\nThe **N-Dimensional Standardization Operator**, $z$, maps a swarm state `S`, a raw value vector `v`, and an aggregation operator `M` to an N-dimensional vector of Z-scores.\n\n**Operation:**\n1.  Aggregate the alive components `v_A` using operator M (see {prf:ref}`def-swarm-aggregation-operator`) to get a measure $\\mu_v = M(S, v_A)$.\n2.  Compute the mean $\\mu_A = \\mathbb{E}[\\mu_v]$ and the **patched** standard deviation $\\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])$ using the patching function (see {prf:ref}`lem-patching-properties`).\n3.  For each alive walker `i`, compute its Z-score: $z_i = (v_i - \\mu_A) / \\sigma'_A$.\n4.  Assemble the final N-dimensional vector, setting components for dead walkers to zero.",
    "raw_directive": "1844: This operator uses the robust statistics from the previous stage to convert the raw value vectors into standardized Z-scores.\n1845: \n1846: :::{prf:definition} N-Dimensional Standardization Operator\n1847: :label: def-standardization-operator\n1848: \n1849: The **N-Dimensional Standardization Operator**, $z$, maps a swarm state `S`, a raw value vector `v`, and an aggregation operator `M` to an N-dimensional vector of Z-scores.\n1850: \n1851: **Operation:**\n1852: 1.  Aggregate the alive components `v_A` using operator M (see {prf:ref}`def-swarm-aggregation-operator`) to get a measure $\\mu_v = M(S, v_A)$.\n1853: 2.  Compute the mean $\\mu_A = \\mathbb{E}[\\mu_v]$ and the **patched** standard deviation $\\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])$ using the patching function (see {prf:ref}`lem-patching-properties`).\n1854: 3.  For each alive walker `i`, compute its Z-score: $z_i = (v_i - \\mu_A) / \\sigma'_A$.\n1855: 4.  Assemble the final N-dimensional vector, setting components for dead walkers to zero.\n1856: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Aggregate the alive components v_A to get a measure μ_v = M(S, v_A).",
        "latex": "\\mu_v = M(S, v_A)"
      },
      {
        "type": null,
        "text": "Compute the mean μ_A = E[μ_v] and the patched standard deviation σ'_A = σ'_patch(Var[μ_v]).",
        "latex": "\\mu_A = \\mathbb{E}[\\mu_v], \\quad \\sigma'_A = \\sigma'_{\\text{patch}}(\\text{Var}[\\mu_v])"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute its Z-score: z_i = (v_i - μ_A) / σ'_A.",
        "latex": "z_i = \\frac{v_i - \\mu_A}{\\sigma'_A}"
      }
    ],
    "properties": [
      {
        "name": "Input Dependencies",
        "description": "Relies on alive components from swarm state S and aggregation via M."
      },
      {
        "name": "Output Type",
        "description": "Produces N-dimensional vector of Z-scores for alive walkers."
      },
      {
        "name": "Robustness",
        "description": "Uses patched standard deviation for handling variance in robust statistics."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm state",
        "description": "The current state of the swarm, including information about alive components.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "v",
        "name": "raw value vector",
        "description": "The N-dimensional vector of raw values for the walkers.",
        "constraints": [],
        "tags": [
          "vector",
          "raw",
          "values"
        ]
      },
      {
        "symbol": "M",
        "name": "aggregation operator",
        "description": "The operator used to aggregate values from alive components.",
        "constraints": [],
        "tags": [
          "aggregation",
          "operator"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This operator uses the robust statistics from the previous stage to convert the raw value vectors into standardized Z-scores."
      }
    ],
    "related_refs": [],
    "tags": [
      "standardization",
      "z-score",
      "operator",
      "swarm-state",
      "aggregation",
      "robust-statistics",
      "normalization"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1844,
      "end_line": 1856,
      "content_start": 1847,
      "content_end": 1855,
      "header_lines": [
        1845
      ]
    },
    "references": [
      "def-swarm-aggregation-operator",
      "lem-patching-properties",
      "def-measurement-operator"
    ],
    "metadata": {
      "label": "def-standardization-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-logistic-rescale",
    "type": "definition",
    "title": "Canonical Logistic Rescale Function",
    "term": "Canonical Logistic Rescale Function",
    "object_type": "function",
    "nl_definition": "A function from the real numbers to the open interval (0, 2) given by the formula g_A(z) = 2 / (1 + e^{-z}).",
    "content_markdown": ":label: def-logistic-rescale\n\nThe **Canonical Logistic Rescale Function**, $g_A: \\mathbb{R} \\to (0, 2)$, is defined as:\n\n$$\ng_A(z) := \\frac{2}{1 + e^{-z}}",
    "raw_directive": "1872: :::\n1873: \n1874: :::{prf:definition} Canonical Logistic Rescale Function\n1875: :label: def-logistic-rescale\n1876: \n1877: The **Canonical Logistic Rescale Function**, $g_A: \\mathbb{R} \\to (0, 2)$, is defined as:\n1878: \n1879: $$\n1880: g_A(z) := \\frac{2}{1 + e^{-z}}\n1881: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "g_A(z) := \\frac{2}{1 + e^{-z}}"
      },
      {
        "type": null,
        "text": "Domain and codomain",
        "latex": "g_A: \\mathbb{R} \\to (0, 2)"
      }
    ],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "logistic",
      "rescale",
      "canonical",
      "sigmoid",
      "function",
      "exponential"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1872,
      "end_line": 1881,
      "content_start": 1875,
      "content_end": 1880,
      "header_lines": [
        1873
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-logistic-rescale"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-fitness-potential-operator",
    "type": "definition",
    "title": "Fitness Potential Operator",
    "term": "Fitness Potential Operator",
    "object_type": "operator",
    "nl_definition": "The Fitness Potential Operator Φ_pipeline maps a swarm state S and raw measurement vectors r and d to an N-dimensional fitness potential vector V_fit by computing Z-scores for rewards and diversity, rescaling them with a floor η, and combining via weighted powers using α and β.",
    "content_markdown": ":label: def-fitness-potential-operator\n\nThe **Fitness Potential Operator**, $\\Phi_{\\text{pipeline}}$, maps a swarm state `S` and its raw measurement vectors `r` and `d` to the final N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$.\n\n**Operation:**\n1.  Compute reward Z-scores: $\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})$.\n2.  Compute distance Z-scores: $\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)$.\n3.  For each alive walker `i`, compute the rescaled components with the floor $\\eta$ using the Canonical Logistic Rescale Function (see {prf:ref}`lem-logistic-properties`):\n    *   $r'_i := g_A(z_{r,i}) + \\eta$\n    *   $d'_i := g_A(z_{d,i}) + \\eta$\n4.  Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n\n\n\n$$\nV_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha\n$$",
    "raw_directive": "1892: The final stage of the pipeline assembles the rescaled components from both the reward and diversity channels into the final fitness potential vector.\n1893: \n1894: :::{prf:definition} Fitness Potential Operator\n1895: :label: def-fitness-potential-operator\n1896: \n1897: The **Fitness Potential Operator**, $\\Phi_{\\text{pipeline}}$, maps a swarm state `S` and its raw measurement vectors `r` and `d` to the final N-dimensional fitness potential vector $\\mathbf{V}_{\\text{fit}}$.\n1898: \n1899: **Operation:**\n1900: 1.  Compute reward Z-scores: $\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})$.\n1901: 2.  Compute distance Z-scores: $\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)$.\n1902: 3.  For each alive walker `i`, compute the rescaled components with the floor $\\eta$ using the Canonical Logistic Rescale Function (see {prf:ref}`lem-logistic-properties`):\n1903:     *   $r'_i := g_A(z_{r,i}) + \\eta$\n1904:     *   $d'_i := g_A(z_{d,i}) + \\eta$\n1905: 4.  Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n1906: \n1907: \n1908: \n1909: $$\n1910: V_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha\n1911: $$\n1912: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Compute reward Z-scores: z_r = z(S, r, R_agg)",
        "latex": "\\mathbf{z}_r = z(S, \\mathbf{r}, R_{agg})"
      },
      {
        "type": null,
        "text": "Compute diversity Z-scores: z_d = z(S, d, M_D)",
        "latex": "\\mathbf{z}_d = z(S, \\mathbf{d}, M_D)"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute rescaled reward: r'_i := g_A(z_{r,i}) + η",
        "latex": "r'_i := g_A(z_{r,i}) + \\eta"
      },
      {
        "type": null,
        "text": "For each alive walker i, compute rescaled diversity: d'_i := g_A(z_{d,i}) + η",
        "latex": "d'_i := g_A(z_{d,i}) + \\eta"
      },
      {
        "type": null,
        "text": "For each alive walker i, combine: V_i := (d'_i)^β · (r'_i)^α",
        "latex": "V_i := (d'_i)^\\beta \\cdot (r'_i)^\\alpha"
      }
    ],
    "properties": [
      {
        "name": "Input Dependencies",
        "description": "Depends on swarm state S for contextual Z-scoring and raw vectors r, d of dimension N."
      },
      {
        "name": "Output",
        "description": "N-dimensional vector V_fit, with components defined only for alive walkers."
      },
      {
        "name": "Positivity",
        "description": "Ensured by adding floor η to rescaled components before exponentiation."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm State",
        "description": "The current state of the swarm, used in Z-score computations.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "r",
        "name": "Reward Vector",
        "description": "Raw N-dimensional reward measurement vector.",
        "constraints": [],
        "tags": [
          "reward",
          "vector"
        ]
      },
      {
        "symbol": "d",
        "name": "Diversity Vector",
        "description": "Raw N-dimensional diversity measurement vector.",
        "constraints": [],
        "tags": [
          "diversity",
          "vector"
        ]
      },
      {
        "symbol": "R_agg",
        "name": "Reward Aggregation",
        "description": "Aggregation parameter for reward Z-score computation.",
        "constraints": [],
        "tags": [
          "aggregation",
          "reward"
        ]
      },
      {
        "symbol": "M_D",
        "name": "Diversity Metric",
        "description": "Metric parameter for diversity Z-score computation.",
        "constraints": [],
        "tags": [
          "metric",
          "diversity"
        ]
      },
      {
        "symbol": "η",
        "name": "Floor Value",
        "description": "Minimum additive value for rescaled components to ensure positivity.",
        "constraints": [
          "η ≥ 0"
        ],
        "tags": [
          "floor",
          "positivity"
        ]
      },
      {
        "symbol": "α",
        "name": "Reward Weight",
        "description": "Exponent weighting the reward component in the final combination.",
        "constraints": [],
        "tags": [
          "weight",
          "exponent",
          "reward"
        ]
      },
      {
        "symbol": "β",
        "name": "Diversity Weight",
        "description": "Exponent weighting the diversity component in the final combination.",
        "constraints": [],
        "tags": [
          "weight",
          "exponent",
          "diversity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "Computations are performed only for alive walkers in the swarm; dead walkers may have V_i = 0 or undefined."
      },
      {
        "type": "dependency",
        "text": "Relies on prior definitions of Z-score function z and rescaling function g_A."
      }
    ],
    "related_refs": [],
    "tags": [
      "fitness",
      "potential",
      "operator",
      "swarm",
      "z-score",
      "rescaling",
      "reward",
      "diversity",
      "pipeline"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1892,
      "end_line": 1912,
      "content_start": 1895,
      "content_end": 1911,
      "header_lines": [
        1893
      ]
    },
    "references": [
      "lem-logistic-properties"
    ],
    "metadata": {
      "label": "def-fitness-potential-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-companion-operator",
    "type": "definition",
    "title": "Companion Selection Operator for Cloning",
    "term": "Companion Selection Operator for Cloning",
    "object_type": "operator",
    "nl_definition": "An operator that, for each walker i in a swarm state S, defines a probability measure C_i(S) to sample a companion c_i independently, using phase-space-aware softmax selection for alive walkers or uniform selection over alive walkers for dead walkers, parameterized by interaction range ε_c.",
    "content_markdown": ":label: def-cloning-companion-operator\n\nThe first step of the cloning action is to select a companion. The **Companion Selection Operator for Cloning** defines, for each walker `i`, a probability measure $\\mathcal{C}_i(S)$ from which a companion `c_i` is sampled independently. This is a hybrid operator that uses the best available information for each type of walker.\n\n**Inputs:**\n*   The swarm state `S`, which defines the set of alive walkers, $\\mathcal{A}_k$, and the set of dead walkers, $\\mathcal{D}_k$.\n*   The interaction range for cloning, $\\varepsilon_c > 0$.\n\n**Operation:**\nThe definition of the measure $\\mathcal{C}_i(S)$ depends on the status of walker `i`:\n\n1.  **If `i` is an ALIVE walker ($i \\in \\mathcal{A}_k$):**\n    The selection is phase-space-aware and restricted to other alive walkers. For any other alive walker $j \\in \\mathcal{A}_k \\setminus \\{i\\}$, the probability of selection is given by a softmax distribution based on algorithmic distance:\n\n\n$$\nP(c_i=j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}\n$$\n\n2.  **If `i` is a DEAD walker ($i \\in \\mathcal{D}_k$):**\n    The selection is a uniform random choice from the entire set of `k` alive walkers. For any alive walker $j \\in \\mathcal{A}_k$:\n\n\n$$\nP(c_i=j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}\n$$",
    "raw_directive": "1962: \n1963: #### 5.7.1 Companion Selection Operator for Cloning\n1964: :::{prf:definition} Companion Selection Operator for Cloning\n1965: :label: def-cloning-companion-operator\n1966: \n1967: The first step of the cloning action is to select a companion. The **Companion Selection Operator for Cloning** defines, for each walker `i`, a probability measure $\\mathcal{C}_i(S)$ from which a companion `c_i` is sampled independently. This is a hybrid operator that uses the best available information for each type of walker.\n1968: \n1969: **Inputs:**\n1970: *   The swarm state `S`, which defines the set of alive walkers, $\\mathcal{A}_k$, and the set of dead walkers, $\\mathcal{D}_k$.\n1971: *   The interaction range for cloning, $\\varepsilon_c > 0$.\n1972: \n1973: **Operation:**\n1974: The definition of the measure $\\mathcal{C}_i(S)$ depends on the status of walker `i`:\n1975: \n1976: 1.  **If `i` is an ALIVE walker ($i \\in \\mathcal{A}_k$):**\n1977:     The selection is phase-space-aware and restricted to other alive walkers. For any other alive walker $j \\in \\mathcal{A}_k \\setminus \\{i\\}$, the probability of selection is given by a softmax distribution based on algorithmic distance:\n1978: \n1979: \n1980: $$\n1981: P(c_i=j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}\n1982: $$\n1983: \n1984: 2.  **If `i` is a DEAD walker ($i \\in \\mathcal{D}_k$):**\n1985:     The selection is a uniform random choice from the entire set of `k` alive walkers. For any alive walker $j \\in \\mathcal{A}_k$:\n1986: \n1987: \n1988: $$\n1989: P(c_i=j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}\n1990: $$\n1991: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "If i \\in \\mathcal{A}_k: P(c_i = j \\mid i \\in \\mathcal{A}_k) := \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(i, j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{l \\in \\mathcal{A}_k \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(i, l)^2}{2\\epsilon_c^2}\\right)}, \\quad \\forall j \\in \\mathcal{A}_k \\setminus \\{i\\}"
      },
      {
        "type": null,
        "text": null,
        "latex": "If i \\in \\mathcal{D}_k: P(c_i = j \\mid i \\in \\mathcal{D}_k) := \\frac{1}{k}, \\quad \\forall j \\in \\mathcal{A}_k"
      }
    ],
    "properties": [
      {
        "name": "Inputs",
        "description": "Swarm state S (defining \\mathcal{A}_k and \\mathcal{D}_k) and interaction range \\varepsilon_c > 0."
      },
      {
        "name": "Operation for alive walkers",
        "description": "Phase-space-aware selection via softmax on algorithmic distances to other alive walkers."
      },
      {
        "name": "Operation for dead walkers",
        "description": "Uniform random selection from all k alive walkers."
      },
      {
        "name": "Independence",
        "description": "Companions c_i are sampled independently for each i."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm state",
        "description": "Current state of the swarm, defining alive and dead walkers.",
        "constraints": [],
        "tags": [
          "swarm",
          "state"
        ]
      },
      {
        "symbol": "ε_c",
        "name": "interaction range",
        "description": "Positive parameter controlling the cloning interaction range.",
        "constraints": [
          "ε_c > 0"
        ],
        "tags": [
          "range",
          "cloning",
          "positive"
        ]
      },
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Index of the walker for which the companion is selected.",
        "constraints": [],
        "tags": [
          "walker",
          "index"
        ]
      },
      {
        "symbol": "k",
        "name": "number of alive walkers",
        "description": "Size of the set of alive walkers A_k.",
        "constraints": [
          "k ≥ 1"
        ],
        "tags": [
          "alive",
          "count"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "cloning",
      "companion",
      "selection",
      "operator",
      "probability",
      "measure",
      "softmax",
      "uniform",
      "alive",
      "dead"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1962,
      "end_line": 1991,
      "content_start": 1965,
      "content_end": 1990,
      "header_lines": [
        1963
      ]
    },
    "references": [
      "def-decision-operator"
    ],
    "metadata": {
      "label": "def-cloning-companion-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-score",
    "type": "definition",
    "title": "The Canonical Cloning Score",
    "term": "Canonical Cloning Score",
    "object_type": "score function",
    "nl_definition": "Once a companion c_i has been selected for walker i, the Canonical Cloning Score S_i(c_i) is calculated as the normalized difference between the fitness of the companion and the walker, adjusted by a small epsilon term.",
    "content_markdown": ":label: def-cloning-score\n\nOnce a companion `c_i` has been selected for walker `i`, the **Canonical Cloning Score**, $S_i(c_i)$, is calculated as:\n\n$$\nS_i(c_i) := \\frac{V_{\\text{fit},{c_i}} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}\n$$\n\nwhere $V_{\\text{fit},i}$ is the fitness of walker `i`, $V_{\\text{fit},{c_i}}$ is the fitness of its chosen companion, and $\\varepsilon_{\\mathrm{clone}} > 0$ is a small regularization constant.",
    "raw_directive": "1994: \n1995: #### 5.7.2 Cloning Score\n1996: :::{prf:definition} The Canonical Cloning Score\n1997: :label: def-cloning-score\n1998: \n1999: Once a companion `c_i` has been selected for walker `i`, the **Canonical Cloning Score**, $S_i(c_i)$, is calculated as:\n2000: \n2001: $$\n2002: S_i(c_i) := \\frac{V_{\\text{fit},{c_i}} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}\n2003: $$\n2004: \n2005: where $V_{\\text{fit},i}$ is the fitness of walker `i`, $V_{\\text{fit},{c_i}}$ is the fitness of its chosen companion, and $\\varepsilon_{\\mathrm{clone}} > 0$ is a small regularization constant.\n2006: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Definition formula",
        "latex": "S_i(c_i) := \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\mathrm{clone}}}"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "S_i(c_i)",
        "name": "cloning_score",
        "description": "The canonical cloning score for walker i and companion c_i",
        "constraints": [],
        "tags": [
          "score"
        ]
      },
      {
        "symbol": "V_{fit,c_i}",
        "name": "companion_fitness",
        "description": "Fitness value of the selected companion c_i",
        "constraints": [],
        "tags": [
          "fitness"
        ]
      },
      {
        "symbol": "V_{fit,i}",
        "name": "walker_fitness",
        "description": "Fitness value of walker i",
        "constraints": [],
        "tags": [
          "fitness"
        ]
      },
      {
        "symbol": "\\varepsilon_{clone}",
        "name": "clone_epsilon",
        "description": "Small epsilon parameter for cloning to avoid division by zero",
        "constraints": [],
        "tags": [
          "epsilon",
          "regularization"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "cloning score",
      "canonical",
      "fitness",
      "walker",
      "companion",
      "selection"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 1994,
      "end_line": 2006,
      "content_start": 1997,
      "content_end": 2005,
      "header_lines": [
        1995
      ]
    },
    "references": [
      "def-cloning-decision",
      "def-cloning-probability"
    ],
    "metadata": {
      "label": "def-cloning-score"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-probability",
    "type": "definition",
    "title": "Total Cloning Probability",
    "term": "total cloning probability",
    "object_type": "probability",
    "nl_definition": "The total cloning probability p_i for a walker i is its unconditional probability of being marked for cloning, computed as the expectation over the random selection of companion c_i and threshold T_i.",
    "content_markdown": ":label: def-cloning-probability\n\nThe **total cloning probability**, $p_i$, for a walker `i` is its unconditional probability of being marked for cloning. This is the expectation of the cloning event taken over the random draws of both the companion `c_i` and the threshold `T_i`, where the score is defined by {prf:ref}`def-cloning-score`.\n\n$$\np_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]\n$$\n\nThe inner probability, for a fixed companion, evaluates to $\\min(1, \\max(0, S_i(c_i)/p_{\\max}))$. This gives the final expression for the total cloning probability as an expectation over the choice of companion:\n\n$$\np_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]\n$$",
    "raw_directive": "2008: :::\n2009: \n2010: :::{prf:definition} Total Cloning Probability\n2011: :label: def-cloning-probability\n2012: \n2013: The **total cloning probability**, $p_i$, for a walker `i` is its unconditional probability of being marked for cloning. This is the expectation of the cloning event taken over the random draws of both the companion `c_i` and the threshold `T_i`, where the score is defined by {prf:ref}`def-cloning-score`.\n2014: \n2015: $$\n2016: p_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]\n2017: $$\n2018: \n2019: The inner probability, for a fixed companion, evaluates to $\\min(1, \\max(0, S_i(c_i)/p_{\\max}))$. This gives the final expression for the total cloning probability as an expectation over the choice of companion:\n2020: \n2021: $$\n2022: p_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]\n2023: $$\n2024: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "p_i := E_{c_i ~ C_i(S)} [ P_{T_i ~ U(0, p_max)} ( S_i(c_i) > T_i ) ]",
        "latex": "p_i := \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)} \\left[ \\mathbb{P}_{T_i \\sim U(0,p_{\\max})} \\left( S_i(c_i) > T_i \\right) \\right]"
      },
      {
        "type": null,
        "text": "p_i = E_{c_i ~ C_i(S)} [ min(1, max(0, S_i(c_i) / p_max )) ]",
        "latex": "p_i = \\mathbb{E}_{c_i \\sim \\mathcal{C}_i(S)}\\left[\\min\\left(1, \\max\\left(0, \\frac{S_i(c_i)}{p_{\\max}}\\right)\\right)\\right]"
      }
    ],
    "properties": [
      {
        "name": "unconditional probability",
        "description": "Marginalizes over companion selection and threshold randomness"
      },
      {
        "name": "bounded",
        "description": "Always satisfies 0 ≤ p_i ≤ 1 due to min-max clipping"
      }
    ],
    "parameters": [
      {
        "symbol": "p_i",
        "name": "total cloning probability",
        "description": "Unconditional probability of walker i being marked for cloning",
        "constraints": [
          "0 ≤ p_i ≤ 1"
        ],
        "tags": [
          "probability"
        ]
      },
      {
        "symbol": "i",
        "name": "walker index",
        "description": "Identifier for the walker",
        "constraints": [],
        "tags": [
          "walker",
          "index"
        ]
      },
      {
        "symbol": "c_i",
        "name": "companion",
        "description": "Randomly selected companion for walker i",
        "constraints": [],
        "tags": [
          "companion"
        ]
      },
      {
        "symbol": "S_i(c_i)",
        "name": "score",
        "description": "Score of companion c_i for walker i",
        "constraints": [],
        "tags": [
          "score"
        ]
      },
      {
        "symbol": "T_i",
        "name": "threshold",
        "description": "Random threshold drawn from uniform distribution",
        "constraints": [
          "0 < T_i < p_max"
        ],
        "tags": [
          "threshold"
        ]
      },
      {
        "symbol": "p_max",
        "name": "maximum probability",
        "description": "Upper bound for the threshold distribution",
        "constraints": [
          "0 < p_max ≤ 1"
        ],
        "tags": [
          "maximum",
          "bound"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "simplification",
        "text": "The inner probability for a fixed companion evaluates to min(1, max(0, S_i(c_i)/p_max))"
      },
      {
        "type": "interpretation",
        "text": "Represents the expected cloning rate for walker i across possible companions and thresholds"
      }
    ],
    "related_refs": [],
    "tags": [
      "cloning",
      "probability",
      "expectation",
      "walker",
      "companion",
      "threshold",
      "score"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 2008,
      "end_line": 2024,
      "content_start": 2011,
      "content_end": 2023,
      "header_lines": [
        2009
      ]
    },
    "references": [
      "def-cloning-score"
    ],
    "metadata": {
      "label": "def-cloning-probability"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-decision",
    "type": "definition",
    "title": "The Stochastic Cloning Decision",
    "term": "Stochastic Cloning Decision",
    "object_type": "decision process",
    "nl_definition": "A decision mechanism involving stochastic cloning, as introduced in section 5.7.3.",
    "content_markdown": ":label: def-cloning-decision",
    "raw_directive": "2036: #### 5.7.3  Cloning Decision\n2037: \n2038: :::{prf:definition} The Stochastic Cloning Decision\n2039: :label: def-cloning-decision\n2040: ",
    "formal_conditions": [],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "warning",
        "text": "The directive appears incomplete; no formal definition body is provided."
      }
    ],
    "related_refs": [],
    "tags": [
      "stochastic",
      "cloning",
      "decision",
      "probability",
      "reproduction"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 2036,
      "end_line": 2040,
      "content_start": 2039,
      "content_end": 2039,
      "header_lines": [
        2037
      ]
    },
    "references": [
      "def-cloning-score"
    ],
    "metadata": {
      "label": "def-cloning-decision"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-inelastic-collision-update",
    "type": "definition",
    "title": "The Inelastic Collision State Update",
    "term": "Inelastic Collision State Update",
    "object_type": "state update process",
    "nl_definition": "A simultaneous, momentum-conserving update for groups of cloners selecting the same companion, resetting cloner positions with jitter and applying an inelastic velocity collapse with tunable restitution to control kinetic energy dissipation.",
    "content_markdown": ":label: def-inelastic-collision-update\n\nLet the set of all walkers marked for cloning be `C_set`. For each cloner $i \\in C_set$, let `c_i` be its selected companion. The intermediate swarm state `S'` is constructed as follows.\n\nFirst, for each unique companion `c` in the swarm, we identify the set of all cloners that selected it:\n\n$$\nI_c := \\{j \\in C_{set} \\mid c_j = c\\}\n$$\n\nLet `M = |I_c|` be the number of walkers cloning from companion `c`. The update is then defined for each `(M+1)`-particle system consisting of the companion `c` and its set of cloners `I_c`.\n\n1.  **Position Updates:**\n    *   For each cloner $j \\in I_c$, its position is reset to that of its companion `c`, plus independent Gaussian jitter:\n\n\n$$\nx'_j := x_c + \\sigma_x \\zeta_j^x\n$$\n\n    *   The position of the companion `c` is unchanged by this interaction: `x'_c := x_c`.\n\n2.  **Velocity Updates (The Inelastic Collapse):**\n    The velocities of all `M+1` interacting walkers are updated simultaneously in a process that conserves the group's total momentum.\n\n    *   **a. Center-of-Mass Velocity:** First, compute the center-of-mass velocity of the `(M+1)`-particle interacting system. This quantity is conserved throughout the collision.\n\n\n$$\nV_{COM, c} := \\frac{1}{M+1} \\left( v_c + \\sum_{j \\in I_c} v_j \\right)\n$$\n\n    *   **b. Update Relative Velocities:** For each walker `k` in the system ($k \\in I_c \\cup {c}$), its velocity relative to the CoM is `u_k = v_k - V_{COM,c}`. The new relative velocities `u'_k` are defined by a random rotation and a frictional contraction.\n        Let $\\alpha_restitution \\in [0, 1]$ be a fixed algorithmic parameter representing the coefficient of restitution. For each `k`, let `R_k` be a random orthogonal transformation that isotropically rotates `u_k` (i.e., `R_k(u_k)` has the same magnitude as `u_k` but a uniformly random direction on the `(d-1)`-sphere). The new relative velocity is:\n\n\n$$\nu'_k := \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n$$\n\n    *   **c. Return to Lab Frame:** The final velocities for all interacting walkers are then reconstructed:\n\n\n$$\nv'_k := V_{COM, c} + u'_k\n$$\n\n3.  **Uninvolved Walkers:** Any walker `k` that is not a cloner and was not selected as a companion by any cloner has its state `(x_k, v_k)` unchanged.\n\n**Analysis of the Restitution Parameter $\\alpha_restitution$:**\n\nThis model introduces $\\alpha_restitution$ as a crucial hyperparameter that controls the velocity variance expansion caused by the velocity reset mechanism during cloning.\n\n*   If **$\\alpha_restitution = 1$**, the collision is **perfectly elastic**. The magnitudes of the relative velocities are preserved (`||u'_k|| = ||u_k||`), and the total kinetic energy of the interacting system is conserved. In this regime, cloning redistributes kinetic energy among walkers but does not directly dissipate it. However, the velocity reset mechanism still causes bounded expansion of $V_{\\text{Var},v}$ as walkers' velocities are reset based on their companions.\n\n*   If **$\\alpha_restitution = 0$**, the collision is **perfectly inelastic**. All new relative velocities are zero (`u'_k = 0`), meaning all `M+1` walkers emerge with the identical center-of-mass velocity, `v'_k = V_{COM,c}`. This corresponds to the **maximum possible dissipation** of the group's internal kinetic energy while still conserving total momentum. In this regime, the velocity variance expansion is minimized, as all walkers in a cloning group collapse to a single velocity.\n\n*   If **$\\alpha_restitution \\in (0, 1)$**, the cloning event has **intermediate dissipation**. The internal kinetic energy of the interacting group is reduced by a factor of $\\alpha_restitution^{2}$. This parameter provides a tunable mechanism for controlling the trade-off between maintaining kinetic diversity and bounding velocity variance expansion.",
    "raw_directive": "2048: This model handles the complex but common scenario where multiple \"cloners\" (either unfit alive walkers or dead walkers being revived) select the same high-fitness walker as their companion. Instead of a series of pairwise interactions, all cloners associated with a single companion are treated as a single interacting system that undergoes a simultaneous, momentum-conserving \"inelastic collapse.\" This process includes a tunable parameter for energy dissipation, allowing the cloning operator itself to act as a powerful mechanism for controlling the swarm's kinetic energy.\n2049: \n2050: :::{prf:definition} The Inelastic Collision State Update\n2051: :label: def-inelastic-collision-update\n2052: \n2053: Let the set of all walkers marked for cloning be `C_set`. For each cloner $i \\in C_set$, let `c_i` be its selected companion. The intermediate swarm state `S'` is constructed as follows.\n2054: \n2055: First, for each unique companion `c` in the swarm, we identify the set of all cloners that selected it:\n2056: \n2057: $$\n2058: I_c := \\{j \\in C_{set} \\mid c_j = c\\}\n2059: $$\n2060: \n2061: Let `M = |I_c|` be the number of walkers cloning from companion `c`. The update is then defined for each `(M+1)`-particle system consisting of the companion `c` and its set of cloners `I_c`.\n2062: \n2063: 1.  **Position Updates:**\n2064:     *   For each cloner $j \\in I_c$, its position is reset to that of its companion `c`, plus independent Gaussian jitter:\n2065: \n2066: \n2067: $$\n2068: x'_j := x_c + \\sigma_x \\zeta_j^x\n2069: $$\n2070: \n2071:     *   The position of the companion `c` is unchanged by this interaction: `x'_c := x_c`.\n2072: \n2073: 2.  **Velocity Updates (The Inelastic Collapse):**\n2074:     The velocities of all `M+1` interacting walkers are updated simultaneously in a process that conserves the group's total momentum.\n2075: \n2076:     *   **a. Center-of-Mass Velocity:** First, compute the center-of-mass velocity of the `(M+1)`-particle interacting system. This quantity is conserved throughout the collision.\n2077: \n2078: \n2079: $$\n2080: V_{COM, c} := \\frac{1}{M+1} \\left( v_c + \\sum_{j \\in I_c} v_j \\right)\n2081: $$\n2082: \n2083:     *   **b. Update Relative Velocities:** For each walker `k` in the system ($k \\in I_c \\cup {c}$), its velocity relative to the CoM is `u_k = v_k - V_{COM,c}`. The new relative velocities `u'_k` are defined by a random rotation and a frictional contraction.\n2084:         Let $\\alpha_restitution \\in [0, 1]$ be a fixed algorithmic parameter representing the coefficient of restitution. For each `k`, let `R_k` be a random orthogonal transformation that isotropically rotates `u_k` (i.e., `R_k(u_k)` has the same magnitude as `u_k` but a uniformly random direction on the `(d-1)`-sphere). The new relative velocity is:\n2085: \n2086: \n2087: $$\n2088: u'_k := \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n2089: $$\n2090: \n2091:     *   **c. Return to Lab Frame:** The final velocities for all interacting walkers are then reconstructed:\n2092: \n2093: \n2094: $$\n2095: v'_k := V_{COM, c} + u'_k\n2096: $$\n2097: \n2098: 3.  **Uninvolved Walkers:** Any walker `k` that is not a cloner and was not selected as a companion by any cloner has its state `(x_k, v_k)` unchanged.\n2099: \n2100: **Analysis of the Restitution Parameter $\\alpha_restitution$:**\n2101: \n2102: This model introduces $\\alpha_restitution$ as a crucial hyperparameter that controls the velocity variance expansion caused by the velocity reset mechanism during cloning.\n2103: \n2104: *   If **$\\alpha_restitution = 1$**, the collision is **perfectly elastic**. The magnitudes of the relative velocities are preserved (`||u'_k|| = ||u_k||`), and the total kinetic energy of the interacting system is conserved. In this regime, cloning redistributes kinetic energy among walkers but does not directly dissipate it. However, the velocity reset mechanism still causes bounded expansion of $V_{\\text{Var},v}$ as walkers' velocities are reset based on their companions.\n2105: \n2106: *   If **$\\alpha_restitution = 0$**, the collision is **perfectly inelastic**. All new relative velocities are zero (`u'_k = 0`), meaning all `M+1` walkers emerge with the identical center-of-mass velocity, `v'_k = V_{COM,c}`. This corresponds to the **maximum possible dissipation** of the group's internal kinetic energy while still conserving total momentum. In this regime, the velocity variance expansion is minimized, as all walkers in a cloning group collapse to a single velocity.\n2107: \n2108: *   If **$\\alpha_restitution \\in (0, 1)$**, the cloning event has **intermediate dissipation**. The internal kinetic energy of the interacting group is reduced by a factor of $\\alpha_restitution^{2}$. This parameter provides a tunable mechanism for controlling the trade-off between maintaining kinetic diversity and bounding velocity variance expansion.\n2109: ",
    "formal_conditions": [],
    "properties": [
      {
        "name": "Momentum Conservation",
        "description": "The total momentum of the (M+1)-particle interacting system is conserved through the center-of-mass velocity."
      },
      {
        "name": "Position Jitter",
        "description": "Cloners' positions are reset to the companion's position plus independent Gaussian noise."
      },
      {
        "name": "Tunable Dissipation",
        "description": "Internal kinetic energy reduced by factor α_restitution², allowing control over velocity variance expansion."
      },
      {
        "name": "Uninvolved Walkers",
        "description": "Walkers not participating in cloning remain unchanged."
      }
    ],
    "parameters": [
      {
        "symbol": "α_restitution",
        "name": "coefficient of restitution",
        "description": "Fixed algorithmic parameter in [0,1] representing the coefficient of restitution, controlling energy dissipation in the inelastic collapse.",
        "constraints": [
          "∈ [0,1]"
        ],
        "tags": [
          "restitution",
          "dissipation",
          "hyperparameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "analysis",
        "text": "If α_restitution = 1, perfectly elastic collision: magnitudes of relative velocities preserved, kinetic energy conserved, but velocity reset causes bounded variance expansion."
      },
      {
        "type": "analysis",
        "text": "If α_restitution = 0, perfectly inelastic: all walkers in group get identical V_{COM,c} velocity, maximizing dissipation of internal kinetic energy."
      },
      {
        "type": "analysis",
        "text": "For α_restitution ∈ (0,1), intermediate dissipation: internal kinetic energy reduced by α_restitution², balancing kinetic diversity and variance control."
      }
    ],
    "related_refs": [],
    "tags": [
      "inelastic-collision",
      "cloning-update",
      "momentum-conservation",
      "velocity-reset",
      "restitution-parameter"
    ],
    "document_id": "03_cloning",
    "section": "## 5. The Measurement and Interaction Pipeline",
    "span": {
      "start_line": 2048,
      "end_line": 2109,
      "content_start": 2051,
      "content_end": 2108,
      "header_lines": [
        2049
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-inelastic-collision-update"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 5,
      "chapter_file": "chapter_5.json",
      "section_id": "## 5. The Measurement and Interaction Pipeline"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-unified-high-low-error-sets",
    "type": "definition",
    "title": "The Unified High-Error and Low-Error Sets",
    "term": "Unified High-Error Set H_k(ε) and Low-Error Set L_k(ε)",
    "object_type": "sets",
    "nl_definition": "A partition of the alive set A_k into a high-error set H_k(ε), consisting of walkers in small invalid clusters or outlier clusters with high phase-space variance contribution, and a complementary low-error set L_k(ε), constructed via hierarchical clustering on phase-space distances with statistical validity and outlier detection.",
    "content_markdown": ":label: def-unified-high-low-error-sets\n\nFor a given swarm `k` with alive set $\\mathcal{A}_k$ ($k \\ge 2$), we define a partition into a unified high-error set $H_k(\\epsilon)$ and a unified low-error set $L_k(\\epsilon)$ using a **clustering-based approach** that applies uniformly across all interaction regimes. This unified approach captures both global outlier structure and local phase-space clustering through a single consistent mechanism.\n\n**Phase-Space Clustering Construction:**\n\nThe construction proceeds in four steps:\n\n1.  **Clustering:** Partition the alive set $\\mathcal{A}_k$ into disjoint clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with a maximum cluster diameter $D_{\\text{diam}}(\\epsilon) := c_d \\cdot \\epsilon$ (where $c_d > 0$ is a fixed constant, typically $c_d = 2$). Each cluster $G_m$ satisfies:\n\n$$\n\\text{diam}(G_m) := \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)\n$$\n\nwhere $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$ is the algorithmic phase-space distance.\n\n2.  **Statistical Validity Constraint:** To ensure that cluster-level statistics are meaningful, we impose a minimum cluster size requirement. Let $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$ be the minimum statistically valid cluster size. All clusters with $|G_m| < k_{\\min}$ are marked as **invalid** and their walkers are automatically included in the high-error set (as they represent statistically unreliable outlier configurations).\n\n3.  **Outlier Cluster Identification:** For each valid cluster $G_m$ (with $|G_m| \\ge k_{\\min}$), compute its center of mass in phase space: $(\\mu_{x,m}, \\mu_{v,m})$. Compute the between-cluster hypocoercive variance contribution:\n\n$$\n\\text{Contrib}(G_m) := |G_m| \\left(\\|\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\|\\mu_{v,m} - \\mu_v\\|^2\\right)\n$$\n\nwhere $(\\mu_x, \\mu_v)$ is the global center of mass. Sort valid clusters by $\\text{Contrib}(G_m)$ in descending order, and let $O_M \\subseteq \\{1, \\ldots, M\\}$ be the smallest set of cluster indices (among valid clusters) whose cumulative contribution meets or exceeds a fraction $(1-\\varepsilon_O)$ of the total contribution from valid clusters (where $\\varepsilon_O \\in (0, 1)$ is a fixed structural parameter, typically $\\varepsilon_O = 0.1$):\n\n$$\n\\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\\\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)\n$$\n\n4.  **Unified High-Error Set Construction:** The unified high-error set is the union of all walkers in outlier clusters plus all walkers in invalid clusters:\n\n$$\nH_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)\n$$\n\nThe **Unified Low-Error Set** is the complement:\n\n$$\nL_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)\n$$",
    "raw_directive": "2402: Therefore, this section formally defines these sets based on the swarm's full **phase-space configuration**. We will partition the swarm based on two distinct phase-space measures: global kinematic dispersion and local phase-space density. These definitions create the crucial link between the state of the swarm and the signals measured by the algorithm. The remainder of the Keystone analysis will then be dedicated to proving that high *positional* variance is a sufficient condition to force a non-trivial number of walkers into these *phase-space* defined error sets.\n2403: \n2404: :::{prf:definition} The Unified High-Error and Low-Error Sets\n2405: :label: def-unified-high-low-error-sets\n2406: \n2407: For a given swarm `k` with alive set $\\mathcal{A}_k$ ($k \\ge 2$), we define a partition into a unified high-error set $H_k(\\epsilon)$ and a unified low-error set $L_k(\\epsilon)$ using a **clustering-based approach** that applies uniformly across all interaction regimes. This unified approach captures both global outlier structure and local phase-space clustering through a single consistent mechanism.\n2408: \n2409: **Phase-Space Clustering Construction:**\n2410: \n2411: The construction proceeds in four steps:\n2412: \n2413: 1.  **Clustering:** Partition the alive set $\\mathcal{A}_k$ into disjoint clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with a maximum cluster diameter $D_{\\text{diam}}(\\epsilon) := c_d \\cdot \\epsilon$ (where $c_d > 0$ is a fixed constant, typically $c_d = 2$). Each cluster $G_m$ satisfies:\n2414: \n2415: $$\n2416: \\text{diam}(G_m) := \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)\n2417: $$\n2418: \n2419: where $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$ is the algorithmic phase-space distance.\n2420: \n2421: 2.  **Statistical Validity Constraint:** To ensure that cluster-level statistics are meaningful, we impose a minimum cluster size requirement. Let $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$ be the minimum statistically valid cluster size. All clusters with $|G_m| < k_{\\min}$ are marked as **invalid** and their walkers are automatically included in the high-error set (as they represent statistically unreliable outlier configurations).\n2422: \n2423: 3.  **Outlier Cluster Identification:** For each valid cluster $G_m$ (with $|G_m| \\ge k_{\\min}$), compute its center of mass in phase space: $(\\mu_{x,m}, \\mu_{v,m})$. Compute the between-cluster hypocoercive variance contribution:\n2424: \n2425: $$\n2426: \\text{Contrib}(G_m) := |G_m| \\left(\\|\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\|\\mu_{v,m} - \\mu_v\\|^2\\right)\n2427: $$\n2428: \n2429: where $(\\mu_x, \\mu_v)$ is the global center of mass. Sort valid clusters by $\\text{Contrib}(G_m)$ in descending order, and let $O_M \\subseteq \\{1, \\ldots, M\\}$ be the smallest set of cluster indices (among valid clusters) whose cumulative contribution meets or exceeds a fraction $(1-\\varepsilon_O)$ of the total contribution from valid clusters (where $\\varepsilon_O \\in (0, 1)$ is a fixed structural parameter, typically $\\varepsilon_O = 0.1$):\n2430: \n2431: $$\n2432: \\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\\\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)\n2433: $$\n2434: \n2435: 4.  **Unified High-Error Set Construction:** The unified high-error set is the union of all walkers in outlier clusters plus all walkers in invalid clusters:\n2436: \n2437: $$\n2438: H_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)\n2439: $$\n2440: \n2441: The **Unified Low-Error Set** is the complement:\n2442: \n2443: $$\n2444: L_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)\n2445: $$\n2446: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Partition A_k into clusters {G_1, ..., G_M} using complete-linkage hierarchical clustering with max diameter D_diam(ε) = c_d · ε, where diam(G_m) = max_{i,j ∈ G_m} d_alg(i,j) ≤ D_diam(ε) and d_alg(i,j)^2 = ||x_i - x_j||^2 + λ_alg ||v_i - v_j||^2.",
        "latex": "Partition $\\mathcal{A}_k$ into clusters $\\{G_1, \\ldots, G_M\\}$ using complete-linkage hierarchical clustering with max diameter $D_{\\text{diam}}(\\epsilon) = c_d \\cdot \\epsilon$, where $\\text{diam}(G_m) = \\max_{i,j \\in G_m} d_{\\text{alg}}(i, j) \\le D_{\\text{diam}}(\\epsilon)$ and $d_{\\text{alg}}(i, j)^2 := \\|x_i - x_j\\|^2 + \\lambda_{\\text{alg}} \\|v_i - v_j\\|^2$."
      },
      {
        "type": null,
        "text": "Impose minimum cluster size k_min = max(5, ⌈0.05k⌉); clusters with |G_m| < k_min are invalid and their walkers go to H_k(ε).",
        "latex": "Impose minimum cluster size $k_{\\min} := \\max(5, \\lceil 0.05k \\rceil)$; clusters with $|G_m| < k_{\\min}$ are invalid."
      },
      {
        "type": null,
        "text": "For valid clusters (|G_m| ≥ k_min), compute center (μ_{x,m}, μ_{v,m}) and Contrib(G_m) = |G_m| (||μ_{x,m} - μ_x||^2 + λ_v ||μ_{v,m} - μ_v||^2), where (μ_x, μ_v) is global center. Identify outlier indices O_M such that sum_{m ∈ O_M} Contrib(G_m) ≥ (1 - ε_O) total valid contribution.",
        "latex": "For valid clusters, compute $\\text{Contrib}(G_m) := |G_m| \\left(\\||\\mu_{x,m} - \\mu_x\\|^2 + \\lambda_v \\||\\mu_{v,m} - \\mu_v\\|^2\\right)$. Identify $O_M$ s.t. $\\sum_{m \\in O_M} \\text{Contrib}(G_m) \\ge (1-\\varepsilon_O) \\sum_{\\substack{m=1 \\ |G_m| \\ge k_{\\min}}}^M \\text{Contrib}(G_m)$."
      },
      {
        "type": null,
        "text": "H_k(ε) = union of G_m for m ∈ O_M and invalid m; L_k(ε) = A_k \\ H_k(ε).",
        "latex": "$H_k(\\epsilon) := \\left(\\bigcup_{m \\in O_M} G_m\\right) \\cup \\left(\\bigcup_{\\substack{m: |G_m| < k_{\\min}}} G_m\\right)$; $L_k(\\epsilon) := \\mathcal{A}_k \\setminus H_k(\\epsilon)$."
      }
    ],
    "properties": [
      {
        "name": "Partition Property",
        "description": "H_k(ε) and L_k(ε) form a partition of A_k: disjoint and their union is A_k."
      },
      {
        "name": "Unified Approach",
        "description": "Applies consistently across all interaction regimes, capturing global outliers and local clustering via phase-space measures."
      },
      {
        "name": "Statistical Validity",
        "description": "Invalid small clusters (|G_m| < k_min) are treated as high-error to ensure reliable statistics."
      },
      {
        "name": "Outlier Detection",
        "description": "Based on hypocoercive variance contribution, selecting clusters covering (1 - ε_O) of total valid contribution."
      }
    ],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "Index of the swarm step",
        "constraints": [
          "k ≥ 2"
        ],
        "tags": [
          "swarm",
          "step"
        ]
      },
      {
        "symbol": "ε",
        "name": "error parameter",
        "description": "Threshold parameter controlling cluster diameter and error scale",
        "constraints": [],
        "tags": [
          "error",
          "threshold"
        ]
      },
      {
        "symbol": "c_d",
        "name": "diameter constant",
        "description": "Fixed constant scaling the maximum cluster diameter D_diam(ε)",
        "constraints": [
          "c_d > 0",
          "typically c_d = 2"
        ],
        "tags": [
          "clustering",
          "diameter"
        ]
      },
      {
        "symbol": "k_min",
        "name": "minimum cluster size",
        "description": "Minimum size for statistically valid clusters, defined as max(5, ⌈0.05k⌉)",
        "constraints": [
          "k_min ≥ 5"
        ],
        "tags": [
          "cluster",
          "validity"
        ]
      },
      {
        "symbol": "ε_O",
        "name": "outlier fraction parameter",
        "description": "Structural parameter determining the fraction of total contribution for outlier clusters",
        "constraints": [
          "ε_O ∈ (0,1)",
          "typically ε_O = 0.1"
        ],
        "tags": [
          "outlier",
          "contribution"
        ]
      },
      {
        "symbol": "λ_alg",
        "name": "algorithmic velocity weight",
        "description": "Weight parameter in the phase-space distance d_alg",
        "constraints": [],
        "tags": [
          "distance",
          "velocity"
        ]
      },
      {
        "symbol": "λ_v",
        "name": "variance velocity weight",
        "description": "Weight parameter in the contribution variance calculation",
        "constraints": [],
        "tags": [
          "variance",
          "velocity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "construction",
        "text": "The clustering uses complete-linkage hierarchical method for phase-space partitioning."
      },
      {
        "type": "parameters",
        "text": "Constants like c_d=2, ε_O=0.1 are typical; λ_alg and λ_v are fixed algorithmic parameters."
      },
      {
        "type": "motivation",
        "text": "Links swarm state to algorithm signals via global kinematic dispersion and local phase-space density."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "phase-space",
      "clustering",
      "error-sets",
      "high-error",
      "low-error",
      "partition",
      "kinematic-dispersion"
    ],
    "document_id": "03_cloning",
    "section": "## 6. The Geometry of Error: From System Error to a Guaranteed Geometric Structure",
    "span": {
      "start_line": 2402,
      "end_line": 2446,
      "content_start": 2405,
      "content_end": 2445,
      "header_lines": [
        2403
      ]
    },
    "references": [
      "def-fitness-potential-operator",
      "def-geometric-partition"
    ],
    "metadata": {
      "label": "def-unified-high-low-error-sets"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 6,
      "chapter_file": "chapter_6.json",
      "section_id": "## 6. The Geometry of Error: From System Error to a Guaranteed Geometric Structure"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-max-patched-std",
    "type": "definition",
    "title": "Maximum Patched Standard Deviation",
    "term": "maximum patched standard deviation",
    "object_type": "bound",
    "nl_definition": "The maximum value that the patched standard deviation function can attain over its entire possible input domain.",
    "content_markdown": ":label: def-max-patched-std\n\nLet $V_{\\max}$ be the uniform upper bound on a raw measurement's absolute value (either $V_{\\max}^{(R)}$ for rewards or $D_{\\text{valid}}$ for distances). The **maximum patched standard deviation**, $\\sigma'_{\\max}$, is the maximum value that the patched standard deviation function can attain over its entire possible input domain.\n\n$$\n\\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)\n$$",
    "raw_directive": "3689: The first component we must bound is the denominator of the standardization formula. The following definition establishes a uniform upper bound on the patched standard deviation (see {prf:ref}`def-patched-std-dev-function`).\n3690: \n3691: :::{prf:definition} Maximum Patched Standard Deviation\n3692: :label: def-max-patched-std\n3693: \n3694: Let $V_{\\max}$ be the uniform upper bound on a raw measurement's absolute value (either $V_{\\max}^{(R)}$ for rewards or $D_{\\text{valid}}$ for distances). The **maximum patched standard deviation**, $\\sigma'_{\\max}$, is the maximum value that the patched standard deviation function can attain over its entire possible input domain.\n3695: \n3696: $$\n3697: \\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)\n3698: $$\n3699: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "σ'_max := sup_{0 ≤ V ≤ V_max^2} σ'_patch(V)",
        "latex": "\\sigma'_{\\max} := \\sup_{0 \\le V \\le V_{\\max}^2} \\sigma'_{\\mathrm{patch}}(V)"
      }
    ],
    "properties": [
      {
        "name": "upper bound",
        "description": "provides a uniform upper bound on the patched standard deviation σ'_patch(V) for all admissible V in [0, V_max^2]"
      }
    ],
    "parameters": [
      {
        "symbol": "V_{\\max}",
        "name": "V_max",
        "description": "uniform upper bound on a raw measurement's absolute value (either V_{\\max}^{(R)} for rewards or D_{\\text{valid}} for distances)",
        "constraints": [],
        "tags": [
          "upper bound",
          "measurement",
          "reward",
          "distance"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This definition establishes a uniform upper bound on the patched standard deviation for use in the denominator of the standardization formula."
      }
    ],
    "related_refs": [],
    "tags": [
      "patched",
      "standard deviation",
      "maximum",
      "bound",
      "supremum",
      "standardization"
    ],
    "document_id": "03_cloning",
    "section": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation",
    "span": {
      "start_line": 3689,
      "end_line": 3699,
      "content_start": 3692,
      "content_end": 3698,
      "header_lines": [
        3690
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-max-patched-std"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 7,
      "chapter_file": "chapter_7.json",
      "section_id": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-unfit-set",
    "type": "definition",
    "title": "The Unfit Set",
    "term": "Unfit Set",
    "object_type": "set",
    "nl_definition": "The unfit set of a swarm is the subset of its alive walkers whose individual fitness potentials are at most the swarm's average fitness potential.",
    "content_markdown": ":label: def-unfit-set\n\nFor a given swarm `k` with alive set $\\mathcal{A}_k$ and a calculated fitness potential vector $(V_{k,i})_{i \\in \\mathcal{A}_k}$, the **unfit set**, $U_k$, is the subset of alive walkers whose fitness potential is less than or equal to the swarm's mean fitness potential, $\\mu_{V,k} = \\frac{1}{k}\\sum_{j \\in \\mathcal{A}_k} V_{k,j}$.\n\n$$\nU_k := \\{i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k}\\}",
    "raw_directive": "4594: The first pillar of the overlap proof is to show that the fitness signal generated by a high-error swarm is a collective phenomenon. A large `V_struct` implies a large internal variance, which is guaranteed to produce a non-vanishing raw measurement variance ([](#thm-geometry-guarantees-variance)). This raw signal robustly propagates through the measurement pipeline to create a guaranteed microscopic gap in the final fitness potentials, ensuring a non-trivial overall fitness range, $\\kappa_V,gap(\\varepsilon) > 0$. The following lemma proves that such a gap cannot be explained by a single unusually fit or unfit walker; it necessitates a statistically significant imbalance in the fitness distribution of the entire population.\n4595: \n4596: :::{prf:definition} The Unfit Set\n4597: :label: def-unfit-set\n4598: \n4599: For a given swarm `k` with alive set $\\mathcal{A}_k$ and a calculated fitness potential vector $(V_{k,i})_{i \\in \\mathcal{A}_k}$, the **unfit set**, $U_k$, is the subset of alive walkers whose fitness potential is less than or equal to the swarm's mean fitness potential, $\\mu_{V,k} = \\frac{1}{k}\\sum_{j \\in \\mathcal{A}_k} V_{k,j}$.\n4600: \n4601: $$\n4602: U_k := \\{i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k}\\}\n4603: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "U_k := \\{ i \\in \\mathcal{A}_k \\mid V_{k,i} \\le \\mu_{V,k} \\}"
      },
      {
        "type": null,
        "text": "where \\mu_{V,k} = \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}",
        "latex": "\\mu_{V,k} = \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}"
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "Identifier for the swarm.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "\\mathcal{A}_k",
        "name": "alive set",
        "description": "The set of alive walkers in swarm k.",
        "constraints": [],
        "tags": [
          "alive",
          "walkers"
        ]
      },
      {
        "symbol": "V_{k,i}",
        "name": "fitness potential",
        "description": "Fitness potential of walker i in swarm k.",
        "constraints": [],
        "tags": [
          "fitness",
          "potential"
        ]
      },
      {
        "symbol": "\\mu_{V,k}",
        "name": "mean fitness potential",
        "description": "Average fitness potential across alive walkers in swarm k, defined as \\frac{1}{k} \\sum_{j \\in \\mathcal{A}_k} V_{k,j}.",
        "constraints": [],
        "tags": [
          "mean",
          "average"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "Used in proofs involving fitness distribution imbalances in swarms."
      }
    ],
    "related_refs": [
      "thm-geometry-guarantees-variance"
    ],
    "tags": [
      "unfit-set",
      "swarm",
      "fitness-potential",
      "mean-fitness",
      "alive-walkers",
      "population-subset"
    ],
    "document_id": "03_cloning",
    "section": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation",
    "span": {
      "start_line": 4594,
      "end_line": 4603,
      "content_start": 4597,
      "content_end": 4602,
      "header_lines": [
        4595
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-unfit-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 7,
      "chapter_file": "chapter_7.json",
      "section_id": "## 7. The Corrective Nature of Fitness: From Signal Generation to Intelligent Adaptation"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-critical-target-set",
    "type": "definition",
    "title": "The Critical Target Set",
    "term": "critical target set",
    "object_type": "set",
    "nl_definition": "For a state in the high-error regime, with k the index of the high-variance swarm, the critical target set I_target is the set of walkers that are simultaneously stably alive in both swarms, unfit in swarm k, and high-error in swarm k.",
    "content_markdown": ":label: def-critical-target-set\n\nFor a state in the high-error regime, let $k$ be the index of the high-variance swarm. The **critical target set**, $I_{\\text{target}}$, is the set of walkers that are simultaneously stably alive, unfit in swarm $k$, and high-error in swarm $k$.\n\n$$\nI_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)\n$$\n\nThe guaranteed existence of a substantial, non-vanishing overlap between the unfit and high-error sets, as proven in [](#thm-unfit-high-error-overlap-fraction), ensures that this critical target set is non-empty and contains a non-vanishing, N-uniform fraction of the alive population. The subsequent proofs will now proceed by demonstrating that the corrective cloning pressure is concentrated on this specific target set (Section 8.3) and that this same set is responsible for a substantial fraction of the total system error (Section 8.4).",
    "raw_directive": "4798: The analysis in Chapter 7 proved that this high-variance swarm $k$ contains a non-vanishing fraction of \"unfit\" walkers ($U_k$) and a non-vanishing fraction of \"high-error\" walkers ($H_k$), and that these two sets have a substantial overlap. The final step of the Keystone proof is to show that the corrective cloning action is concentrated on the walkers that are simultaneously members of all three critical sets: those that are alive in both swarms (and thus can contribute to the contractive force), those that are unfit (and thus targeted for cloning), and those that are high-error (and thus the source of the problem). We formally define this intersection as our target set.\n4799: \n4800: :::{prf:definition} The Critical Target Set\n4801: :label: def-critical-target-set\n4802: \n4803: For a state in the high-error regime, let $k$ be the index of the high-variance swarm. The **critical target set**, $I_{\\text{target}}$, is the set of walkers that are simultaneously stably alive, unfit in swarm $k$, and high-error in swarm $k$.\n4804: \n4805: $$\n4806: I_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)\n4807: $$\n4808: \n4809: The guaranteed existence of a substantial, non-vanishing overlap between the unfit and high-error sets, as proven in [](#thm-unfit-high-error-overlap-fraction), ensures that this critical target set is non-empty and contains a non-vanishing, N-uniform fraction of the alive population. The subsequent proofs will now proceed by demonstrating that the corrective cloning pressure is concentrated on this specific target set (Section 8.3) and that this same set is responsible for a substantial fraction of the total system error (Section 8.4).\n4810: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "I_target := I_11 ∩ U_k ∩ H_k(ε)",
        "latex": "I_{\\text{target}} := I_{11} \\cap U_k \\cap H_k(\\epsilon)"
      }
    ],
    "properties": [
      {
        "name": "intersection",
        "description": "intersection of sets of stably alive walkers (I_11), unfit walkers (U_k), and high-error walkers (H_k(ε))"
      }
    ],
    "parameters": [
      {
        "symbol": "k",
        "name": "swarm index",
        "description": "index of the high-variance swarm",
        "constraints": [
          "k is the index for the high-variance swarm in the high-error regime"
        ],
        "tags": [
          "swarm",
          "high-variance"
        ]
      },
      {
        "symbol": "\\epsilon",
        "name": "error parameter",
        "description": "parameter defining the high-error threshold in H_k",
        "constraints": [
          "\\epsilon > 0, small"
        ],
        "tags": [
          "error",
          "threshold"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "motivation",
        "text": "This set represents walkers that are alive in both swarms (contributing to contractive force), unfit (targeted for cloning), and high-error (source of the problem), concentrating the corrective cloning action."
      }
    ],
    "related_refs": [],
    "tags": [
      "critical target set",
      "high-variance swarm",
      "unfit walkers",
      "high-error walkers",
      "intersection",
      "stably alive",
      "corrective cloning"
    ],
    "document_id": "03_cloning",
    "section": "## 8. The N-Uniform Quantitative Keystone Lemma",
    "span": {
      "start_line": 4798,
      "end_line": 4810,
      "content_start": 4801,
      "content_end": 4809,
      "header_lines": [
        4799
      ]
    },
    "references": [
      "cor-cloning-pressure-target-set"
    ],
    "metadata": {
      "label": "def-critical-target-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 8,
      "chapter_file": "chapter_8.json",
      "section_id": "## 8. The N-Uniform Quantitative Keystone Lemma"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-operator-formal",
    "type": "definition",
    "title": "The Cloning Operator $\\Psi_{\\text{clone}}$",
    "term": "cloning operator $\\Psi_{\\text{clone}}$",
    "object_type": "Markov transition kernel",
    "nl_definition": "A stochastic operator that maps a swarm configuration with at least one alive walker to a probability distribution over new all-alive swarm configurations, defined as the composition of measure, fitness, decision, and update sub-operators.",
    "content_markdown": ":label: def-cloning-operator-formal\n\nThe **cloning operator** $\\Psi_{\\text{clone}}$ is a Markov transition kernel on the swarm state space $\\Sigma_N$. For any input swarm configuration $S \\in \\Sigma_N$, it produces a probability measure $\\Psi_{\\text{clone}}(S, \\cdot)$ on $\\Sigma_N$.\n\n**Domain and Range:**\n- **Input:** A swarm configuration $S = ((x_1, v_1, s_1), \\ldots, (x_N, v_N, s_N)) \\in \\Sigma_N$ with at least one alive walker ($|\\mathcal{A}(S)| \\geq 1$).\n- **Output:** A probability measure over swarm configurations $S' \\in \\Sigma_N$ where all walkers have status $s'_i = 1$ (the intermediate, all-alive configuration).\n\n**Stochastic Structure:**\n\nThe operator is defined by a composition of deterministic and stochastic sub-operators (see {prf:ref}`thm-cloning-operator-composition` for the rigorous compositional representation):\n\n$$\n\\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}\n$$\n\nwhere each sub-operator is defined in the subsequent sections.\n\n**Key Property - All-Alive Output:**\n\nBy construction, the output configuration $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$ satisfies:\n\n$$\ns'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n$$\n\nThis guarantees that the cloning stage produces a viable swarm ready for the subsequent kinetic evolution, with dead walkers either revived (if the input had dead walkers) or persisting (if already alive).",
    "raw_directive": "5846: We begin with the highest-level definition of the operator as a mathematical object.\n5847: \n5848: :::{prf:definition} The Cloning Operator $\\Psi_{\\text{clone}}$\n5849: :label: def-cloning-operator-formal\n5850: \n5851: The **cloning operator** $\\Psi_{\\text{clone}}$ is a Markov transition kernel on the swarm state space $\\Sigma_N$. For any input swarm configuration $S \\in \\Sigma_N$, it produces a probability measure $\\Psi_{\\text{clone}}(S, \\cdot)$ on $\\Sigma_N$.\n5852: \n5853: **Domain and Range:**\n5854: - **Input:** A swarm configuration $S = ((x_1, v_1, s_1), \\ldots, (x_N, v_N, s_N)) \\in \\Sigma_N$ with at least one alive walker ($|\\mathcal{A}(S)| \\geq 1$).\n5855: - **Output:** A probability measure over swarm configurations $S' \\in \\Sigma_N$ where all walkers have status $s'_i = 1$ (the intermediate, all-alive configuration).\n5856: \n5857: **Stochastic Structure:**\n5858: \n5859: The operator is defined by a composition of deterministic and stochastic sub-operators (see {prf:ref}`thm-cloning-operator-composition` for the rigorous compositional representation):\n5860: \n5861: $$\n5862: \\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}\n5863: $$\n5864: \n5865: where each sub-operator is defined in the subsequent sections.\n5866: \n5867: **Key Property - All-Alive Output:**\n5868: \n5869: By construction, the output configuration $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$ satisfies:\n5870: \n5871: $$\n5872: s'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n5873: $$\n5874: \n5875: This guarantees that the cloning stage produces a viable swarm ready for the subsequent kinetic evolution, with dead walkers either revived (if the input had dead walkers) or persisting (if already alive).\n5876: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input requires at least one alive walker",
        "latex": "$|\\mathcal{A}(S)| \\geq 1$"
      },
      {
        "type": null,
        "text": "Output configurations have all walkers alive",
        "latex": "$s'_i = 1$ for all $i \\in \\{1, \\ldots, N\\}$"
      },
      {
        "type": null,
        "text": "Operator composition",
        "latex": "$\\Psi_{\\text{clone}} = \\Psi_{\\text{update}} \\circ \\Psi_{\\text{decision}} \\circ \\Psi_{\\text{fitness}} \\circ \\Psi_{\\text{measure}}$"
      }
    ],
    "properties": [
      {
        "name": "Domain",
        "description": "Swarm configurations $S \\in \\Sigma_N$ with $|\\mathcal{A}(S)| \\geq 1$"
      },
      {
        "name": "Range",
        "description": "Probability measures on all-alive configurations in $\\Sigma_N$"
      },
      {
        "name": "Stochastic Structure",
        "description": "Composition of deterministic and stochastic sub-operators"
      },
      {
        "name": "All-Alive Output",
        "description": "By construction, all output walkers have status $s'_i = 1$"
      }
    ],
    "parameters": [],
    "examples": [],
    "notes": [
      {
        "type": "construction",
        "text": "The operator ensures all output configurations are intermediate all-alive states."
      }
    ],
    "related_refs": [],
    "tags": [
      "cloning",
      "operator",
      "Markov",
      "kernel",
      "swarm",
      "stochastic",
      "transition",
      "probability"
    ],
    "document_id": "03_cloning",
    "section": "## 9.2. The Cloning Operator as a Markov Kernel",
    "span": {
      "start_line": 5846,
      "end_line": 5876,
      "content_start": 5849,
      "content_end": 5875,
      "header_lines": [
        5847
      ]
    },
    "references": [
      "thm-cloning-operator-composition",
      "thm-complete-cloning-drift"
    ],
    "metadata": {
      "label": "def-cloning-operator-formal"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 10,
      "chapter_file": "chapter_10.json",
      "section_id": "## 9.2. The Cloning Operator as a Markov Kernel"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-measurement-operator",
    "type": "definition",
    "title": "The Measurement Operator",
    "term": "measurement operator",
    "object_type": "operator",
    "nl_definition": "A stochastic operator that takes a swarm configuration S and outputs an N-dimensional raw distance vector d by sampling a spatially-aware pairing of alive agents and computing algorithmic distances along the pairing, setting distances to zero for dead agents.",
    "content_markdown": ":label: def-measurement-operator\n\nFor input swarm $S$ with alive set $\\mathcal{A}(S)$ of size $k = |\\mathcal{A}(S)|$:\n\n**Input:** Swarm configuration $S$\n\n**Stochastic Process:**\n\n1. **Companion Pairing:** Sample a pairing $\\pi: \\mathcal{A}(S) \\to \\mathcal{A}(S)$ from the spatially-aware random pairing distribution ({prf:ref}`def-standardization-operator`):\n\n\n$$\n\\pi \\sim P_{\\text{pair}}(S, \\cdot)\n$$\n\n2. **Raw Distance Vector** (see {prf:ref}`def-raw-value-operators`): For each alive walker $i \\in \\mathcal{A}(S)$, compute:\n\n\n$$\nd_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})\n$$\n\n\n   For dead walkers $i \\notin \\mathcal{A}(S)$, set $d_i = 0$ deterministically.\n\n**Output:** The $N$-dimensional raw distance vector $\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Key Properties:**\n- The pairing $\\pi$ is sampled once per swarm, creating correlations between measurements",
    "raw_directive": "5895: The first stage (as discussed in Section 5.3) generates the stochastic diversity measurements that form the foundation of the fitness evaluation.\n5896: \n5897: :::{prf:definition} The Measurement Operator\n5898: :label: def-measurement-operator\n5899: \n5900: For input swarm $S$ with alive set $\\mathcal{A}(S)$ of size $k = |\\mathcal{A}(S)|$:\n5901: \n5902: **Input:** Swarm configuration $S$\n5903: \n5904: **Stochastic Process:**\n5905: \n5906: 1. **Companion Pairing:** Sample a pairing $\\pi: \\mathcal{A}(S) \\to \\mathcal{A}(S)$ from the spatially-aware random pairing distribution ({prf:ref}`def-standardization-operator`):\n5907: \n5908: \n5909: $$\n5910: \\pi \\sim P_{\\text{pair}}(S, \\cdot)\n5911: $$\n5912: \n5913: 2. **Raw Distance Vector** (see {prf:ref}`def-raw-value-operators`): For each alive walker $i \\in \\mathcal{A}(S)$, compute:\n5914: \n5915: \n5916: $$\n5917: d_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})\n5918: $$\n5919: \n5920: \n5921:    For dead walkers $i \\notin \\mathcal{A}(S)$, set $d_i = 0$ deterministically.\n5922: \n5923: **Output:** The $N$-dimensional raw distance vector $\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}$\n5924: \n5925: **Key Properties:**\n5926: - The pairing $\\pi$ is sampled once per swarm, creating correlations between measurements\n5927: - The distribution of $\\mathbf{d}$ depends only on $S$ and the algorithmic parameters $(\\epsilon_p, \\ell_p)$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input: Swarm configuration S with alive set A(S) of size k = |A(S)|.",
        "latex": null
      },
      {
        "type": null,
        "text": "Sample a pairing π: A(S) → A(S) from the spatially-aware random pairing distribution.",
        "latex": "\\pi \\sim P_{\\text{pair}}(S, \\cdot)"
      },
      {
        "type": null,
        "text": "For each alive walker i ∈ A(S), compute d_i = d_alg(x_i, x_π(i)).",
        "latex": "d_i = d_{\\text{alg}}(x_i, x_{\\pi(i)})"
      },
      {
        "type": null,
        "text": "For dead walkers i ∉ A(S), set d_i = 0 deterministically.",
        "latex": "d_i = 0"
      },
      {
        "type": null,
        "text": "Output: The N-dimensional raw distance vector d = (d_1, …, d_N) ∈ R^N_{≥0}.",
        "latex": "\\mathbf{d} = (d_1, \\ldots, d_N) \\in \\mathbb{R}^N_{\\geq 0}"
      }
    ],
    "properties": [
      {
        "name": "Correlated Measurements",
        "description": "The pairing π is sampled once per swarm, creating correlations between measurements."
      },
      {
        "name": "Distribution Dependency",
        "description": "The distribution of d depends only on S and the algorithmic parameters (ε_p, ℓ_p)."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm",
        "description": "Input swarm configuration with alive set A(S) of size k",
        "constraints": [],
        "tags": [
          "input"
        ]
      },
      {
        "symbol": "\\epsilon_p",
        "name": "epsilon_p",
        "description": "Algorithmic parameter for pairing distribution",
        "constraints": [],
        "tags": [
          "parameter"
        ]
      },
      {
        "symbol": "\\ell_p",
        "name": "ell_p",
        "description": "Algorithmic parameter for pairing distribution",
        "constraints": [],
        "tags": [
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [
      "def-standardization-operator"
    ],
    "tags": [
      "stochastic",
      "measurement",
      "operator",
      "pairing",
      "distance",
      "swarm",
      "diversity"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 5895,
      "end_line": 5927,
      "content_start": 5898,
      "content_end": 5926,
      "header_lines": [
        5896
      ]
    },
    "references": [
      "def-standardization-operator",
      "def-raw-value-operators"
    ],
    "metadata": {
      "label": "def-measurement-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-fitness-operator",
    "type": "definition",
    "title": "The Fitness Evaluation Operator",
    "term": "Fitness Evaluation Operator",
    "object_type": "operator",
    "nl_definition": "A deterministic operator that transforms a swarm configuration and raw distance vector into a fitness potential vector by computing boundary proximity rewards, applying rescaling and z-score normalization over alive walkers, and combining normalized components with dynamics weights.",
    "content_markdown": ":label: def-fitness-operator\n\n**Input:**\n- Swarm configuration $S$\n- Raw distance vector $\\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Deterministic Computation:**\n\n1. **Boundary Proximity:** For each walker $i$, compute:\n\n\n$$\nr_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i)\n$$\n\n   yielding the raw reward vector $\\mathbf{r} = (r_1, \\ldots, r_N)$.\n\n2. **Rescaling:** Apply the rescale function with floor $\\eta > 0$:\n\n\n$$\n\\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta\n$$\n\n3. **Z-Score Normalization:** Compute empirical means and standard deviations over **alive walkers only**:\n\n\n$$\n\\bar{d} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2}\n$$\n\n\n\n$$\n\\bar{r} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{r}_i, \\quad \\sigma_r = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{r}_i - \\bar{r})^2}\n$$\n\n\n   For alive walkers $i \\in \\mathcal{A}(S)$:\n\n\n$$\nz_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}}\n$$\n\n\n   For dead walkers, set $z_{d,i} = z_{r,i} = 0$.\n\n4. **Fitness Potential:** For each walker $i$, compute:\n\n   a. Apply the Rescale Function $g_A$ and add the floor $\\eta$ to create the rescaled components:\n      - $r'_i := g_A(z_{r,i}) + \\eta$\n      - $d'_i := g_A(z_{d,i}) + \\eta$\n\n   b. Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n\n\n$$\nV_{\\text{fit},i} = \\begin{cases}\n      (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & \\text{if } i \\in \\mathcal{A}(S) \\\\\n      0 & \\text{if } i \\notin \\mathcal{A}(S)\n      \\end{cases}\n$$\n\n**Output:** The fitness potential vector $\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}$\n\n**Key Properties:**\n- The operator is deterministic given $S$ and $\\mathbf{d}$",
    "raw_directive": "5942: This deterministic operator (implementing the pipeline from Chapter 5) transforms raw measurements into fitness potentials.\n5943: \n5944: :::{prf:definition} The Fitness Evaluation Operator\n5945: :label: def-fitness-operator\n5946: \n5947: **Input:**\n5948: - Swarm configuration $S$\n5949: - Raw distance vector $\\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}$\n5950: \n5951: **Deterministic Computation:**\n5952: \n5953: 1. **Boundary Proximity:** For each walker $i$, compute:\n5954: \n5955: \n5956: $$\n5957: r_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i)\n5958: $$\n5959: \n5960:    yielding the raw reward vector $\\mathbf{r} = (r_1, \\ldots, r_N)$.\n5961: \n5962: 2. **Rescaling:** Apply the rescale function with floor $\\eta > 0$:\n5963: \n5964: \n5965: $$\n5966: \\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta\n5967: $$\n5968: \n5969: 3. **Z-Score Normalization:** Compute empirical means and standard deviations over **alive walkers only**:\n5970: \n5971: \n5972: $$\n5973: \\bar{d} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2}\n5974: $$\n5975: \n5976: \n5977: \n5978: $$\n5979: \\bar{r} = \\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} \\tilde{r}_i, \\quad \\sigma_r = \\sqrt{\\frac{1}{k}\\sum_{i \\in \\mathcal{A}(S)} (\\tilde{r}_i - \\bar{r})^2}\n5980: $$\n5981: \n5982: \n5983:    For alive walkers $i \\in \\mathcal{A}(S)$:\n5984: \n5985: \n5986: $$\n5987: z_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}}\n5988: $$\n5989: \n5990: \n5991:    For dead walkers, set $z_{d,i} = z_{r,i} = 0$.\n5992: \n5993: 4. **Fitness Potential:** For each walker $i$, compute:\n5994: \n5995:    a. Apply the Rescale Function $g_A$ and add the floor $\\eta$ to create the rescaled components:\n5996:       - $r'_i := g_A(z_{r,i}) + \\eta$\n5997:       - $d'_i := g_A(z_{d,i}) + \\eta$\n5998: \n5999:    b. Combine the components using the dynamics weights $\\alpha$ and $\\beta$:\n6000: \n6001: \n6002: $$\n6003: V_{\\text{fit},i} = \\begin{cases}\n6004:       (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & \\text{if } i \\in \\mathcal{A}(S) \\\\\n6005:       0 & \\text{if } i \\notin \\mathcal{A}(S)\n6006:       \\end{cases}\n6007: $$\n6008: \n6009: **Output:** The fitness potential vector $\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}$\n6010: \n6011: **Key Properties:**\n6012: - The operator is deterministic given $S$ and $\\mathbf{d}$\n6013: - Bounded: $V_{\\text{fit},i} \\in [0, V_{\\text{pot,max}}]$ for alive walkers, where $V_{\\text{pot,max}} = (g_{A,\\max} + \\eta)^{\\alpha+\\beta}$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Input: Swarm configuration S and raw distance vector d ∈ ℝ^N_{≥0}",
        "latex": "S, \\mathbf{d} \\in \\mathbb{R}^N_{\\geq 0}"
      },
      {
        "type": null,
        "text": "Compute raw rewards r_i = g_A(x_i) = φ_barrier(x_i) for each walker i, yielding r = (r_1, …, r_N)",
        "latex": "r_i = g_A(x_i) = \\varphi_{\\text{barrier}}(x_i), \\quad \\mathbf{r} = (r_1, \\ldots, r_N)"
      },
      {
        "type": null,
        "text": "Rescale: \\tilde{d}_i = d_i + η, \\tilde{r}_i = r_i + η",
        "latex": "\\tilde{d}_i = d_i + \\eta, \\quad \\tilde{r}_i = r_i + \\eta"
      },
      {
        "type": null,
        "text": "Z-score over alive walkers i ∈ A(S): means \\bar{d}, \\bar{r} and std devs σ_d, σ_r with k = |A(S)|",
        "latex": "\\bar{d} = \\frac{1}{k} \\sum_{i \\in \\mathcal{A}(S)} \\tilde{d}_i, \\quad \\sigma_d = \\sqrt{\\frac{1}{k} \\sum_{i \\in \\mathcal{A}(S)} (\\tilde{d}_i - \\bar{d})^2} \\quad (similarly for r)"
      },
      {
        "type": null,
        "text": "Z-scores for alive: z_{d,i} = (\\tilde{d}_i - \\bar{d}) / (σ_d + σ_stab), similarly for z_{r,i}; zero for dead",
        "latex": "z_{d,i} = \\frac{\\tilde{d}_i - \\bar{d}}{\\sigma_d + \\sigma_{\\text{stab}}}, \\quad z_{r,i} = \\frac{\\tilde{r}_i - \\bar{r}}{\\sigma_r + \\sigma_{\\text{stab}}} \\quad (i \\in \\mathcal{A}(S)); \\ 0 \\ otherwise"
      },
      {
        "type": null,
        "text": "Rescaled components: r'_i = g_A(z_{r,i}) + η, d'_i = g_A(z_{d,i}) + η",
        "latex": "r'_i := g_A(z_{r,i}) + \\eta, \\quad d'_i := g_A(z_{d,i}) + \\eta"
      },
      {
        "type": null,
        "text": "Fitness: V_{fit,i} = (d'_i)^β · (r'_i)^α if alive, else 0",
        "latex": "V_{\\text{fit},i} = \\begin{cases} (d'_i)^{\\beta} \\cdot (r'_i)^{\\alpha} & i \\in \\mathcal{A}(S) \\\\ 0 & \\text{otherwise} \\end{cases}"
      },
      {
        "type": null,
        "text": "Output: V_{fit} = (V_{fit,1}, …, V_{fit,N}) ∈ ℝ^N_{≥0}",
        "latex": "\\mathbf{V}_{\\text{fit}} = (V_{\\text{fit},1}, \\ldots, V_{\\text{fit},N}) \\in \\mathbb{R}^N_{\\geq 0}"
      }
    ],
    "properties": [
      {
        "name": "Deterministic",
        "description": "The operator produces the same output given fixed inputs S and d"
      },
      {
        "name": "Bounded",
        "description": "For alive walkers, V_{fit,i} ∈ [0, V_{pot,max}] where V_{pot,max} = (g_{A,max} + η)^{α+β}"
      },
      {
        "name": "Alive-Only Normalization",
        "description": "Empirical statistics computed exclusively over alive walkers A(S)"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm Configuration",
        "description": "Current state of the swarm including walker positions and alive status",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "d",
        "name": "Raw Distance Vector",
        "description": "Vector of non-negative raw distances for N walkers",
        "constraints": [
          "d ∈ ℝ^N_{≥0}"
        ],
        "tags": [
          "input",
          "distance"
        ]
      },
      {
        "symbol": "η",
        "name": "Floor Parameter",
        "description": "Positive additive floor for rescaling to avoid zero or negative values",
        "constraints": [
          "η > 0"
        ],
        "tags": [
          "floor",
          "rescaling"
        ]
      },
      {
        "symbol": "σ_stab",
        "name": "Stability Constant",
        "description": "Small positive constant added to standard deviations for numerical stability",
        "constraints": [
          "σ_stab > 0"
        ],
        "tags": [
          "stability",
          "normalization"
        ]
      },
      {
        "symbol": "α",
        "name": "Reward Weight",
        "description": "Exponent weight for the rescaled reward component in fitness potential",
        "constraints": [],
        "tags": [
          "weight",
          "reward",
          "exponent"
        ]
      },
      {
        "symbol": "β",
        "name": "Distance Weight",
        "description": "Exponent weight for the rescaled distance component in fitness potential",
        "constraints": [],
        "tags": [
          "weight",
          "distance",
          "exponent"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "Dead walkers receive zero fitness potential, ensuring selection favors alive ones"
      },
      {
        "type": "dependency",
        "text": "Requires predefined functions g_A and φ_barrier, as well as system parameters η, σ_stab, α, β"
      }
    ],
    "related_refs": [],
    "tags": [
      "fitness-evaluation",
      "operator",
      "swarm",
      "deterministic",
      "z-score-normalization",
      "boundary-proximity",
      "rescaling"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 5942,
      "end_line": 6013,
      "content_start": 5945,
      "content_end": 6012,
      "header_lines": [
        5943
      ]
    },
    "references": [
      "lem-potential-bounds"
    ],
    "metadata": {
      "label": "def-fitness-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-decision-operator",
    "type": "definition",
    "title": "The Cloning Decision Operator",
    "term": "Cloning Decision Operator",
    "object_type": "stochastic operator",
    "nl_definition": "A stochastic process that assigns companions to walkers in a swarm based on their status and computes cloning scores from fitness differences, then decides cloning or persistence via threshold comparison, producing companion and action vectors.",
    "content_markdown": ":label: def-decision-operator\n\n**Input:**\n- Swarm configuration $S$\n- Fitness potential vector $\\mathbf{V}_{\\text{fit}}$\n\n**Stochastic Process:**\n\nFor each walker $i \\in \\{1, \\ldots, N\\}$:\n\n1. **Companion Selection** (see {prf:ref}`def-cloning-companion-operator`):\n\n   - If $i \\in \\mathcal{A}(S)$ (alive): Sample companion $c_i$ from the softmax distribution over other alive walkers:\n\n\n$$\nP(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}\n$$\n\n\n   - If $i \\in \\mathcal{D}(S)$ (dead): Sample companion uniformly from all alive walkers:\n\n\n$$\nP(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)\n$$\n\n2. **Cloning Score:** Compute the score based on fitness difference:\n\n\n$$\nS_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}\n$$\n\n3. **Stochastic Decision:** Sample threshold $T_i \\sim \\text{Uniform}(0, p_{\\max})$ independently.\n\n   Walker $i$ is marked for **cloning** if $S_i > T_i$, otherwise marked to **persist**.\n\n**Output:**\n- Companion assignment vector $\\mathbf{c} = (c_1, \\ldots, c_N)$\n- Binary action vector $\\mathbf{a} = (a_1, \\ldots, a_N)$ where $a_i \\in \\{\\text{clone}, \\text{persist}\\}$\n\n**Total Cloning Probability:**\n\nThe key quantity for drift analysis is the **total probability** that walker $i$ clones, averaging over all randomness in companion selection and threshold sampling:\n\n$$\np_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}})\n$$",
    "raw_directive": "6019: This stochastic operator (formalized from {prf:ref}`def-cloning-decision`) determines which walkers will clone and which will persist.\n6020: \n6021: :::{prf:definition} The Cloning Decision Operator\n6022: :label: def-decision-operator\n6023: \n6024: **Input:**\n6025: - Swarm configuration $S$\n6026: - Fitness potential vector $\\mathbf{V}_{\\text{fit}}$\n6027: \n6028: **Stochastic Process:**\n6029: \n6030: For each walker $i \\in \\{1, \\ldots, N\\}$:\n6031: \n6032: 1. **Companion Selection** (see {prf:ref}`def-cloning-companion-operator`):\n6033: \n6034:    - If $i \\in \\mathcal{A}(S)$ (alive): Sample companion $c_i$ from the softmax distribution over other alive walkers:\n6035: \n6036: \n6037: $$\n6038: P(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}\n6039: $$\n6040: \n6041: \n6042:    - If $i \\in \\mathcal{D}(S)$ (dead): Sample companion uniformly from all alive walkers:\n6043: \n6044: \n6045: $$\n6046: P(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)\n6047: $$\n6048: \n6049: 2. **Cloning Score:** Compute the score based on fitness difference:\n6050: \n6051: \n6052: $$\n6053: S_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}\n6054: $$\n6055: \n6056: 3. **Stochastic Decision:** Sample threshold $T_i \\sim \\text{Uniform}(0, p_{\\max})$ independently.\n6057: \n6058:    Walker $i$ is marked for **cloning** if $S_i > T_i$, otherwise marked to **persist**.\n6059: \n6060: **Output:**\n6061: - Companion assignment vector $\\mathbf{c} = (c_1, \\ldots, c_N)$\n6062: - Binary action vector $\\mathbf{a} = (a_1, \\ldots, a_N)$ where $a_i \\in \\{\\text{clone}, \\text{persist}\\}$\n6063: \n6064: **Total Cloning Probability:**\n6065: \n6066: The key quantity for drift analysis is the **total probability** that walker $i$ clones, averaging over all randomness in companion selection and threshold sampling:\n6067: \n6068: $$\n6069: p_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}})\n6070: $$\n6071: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "For alive walker i, companion c_i sampled from softmax over other alive walkers using algorithmic distances.",
        "latex": "P(c_i = j) = \\frac{\\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_j)^2}{2\\epsilon_c^2}\\right)}{\\sum_{\\ell \\in \\mathcal{A}(S) \\setminus \\{i\\}} \\exp\\left(-\\frac{d_{\\text{alg}}(x_i, x_\\ell)^2}{2\\epsilon_c^2}\\right)} \\quad \\text{for } j \\in \\mathcal{A}(S) \\setminus \\{i\\}"
      },
      {
        "type": null,
        "text": "For dead walker i, companion c_i sampled uniformly from alive walkers.",
        "latex": "P(c_i = j) = \\frac{1}{k} \\quad \\text{for all } j \\in \\mathcal{A}(S)"
      },
      {
        "type": null,
        "text": "Cloning score S_i computed as normalized fitness difference.",
        "latex": "S_i = \\frac{V_{\\text{fit},c_i} - V_{\\text{fit},i}}{V_{\\text{fit},i} + \\varepsilon_{\\text{clone}}}"
      },
      {
        "type": null,
        "text": "Decision: Sample T_i ~ Uniform(0, p_max); clone if S_i > T_i, else persist.",
        "latex": "a_i = \\text{clone if } S_i > T_i, \\text{ else persist}"
      },
      {
        "type": null,
        "text": "Total cloning probability p_i averages over companion and threshold randomness.",
        "latex": "p_i := P(\\text{walker } i \\text{ clones} \\mid S, \\mathbf{V}_{\\text{fit}} )"
      }
    ],
    "properties": [
      {
        "name": "Input",
        "description": "Swarm configuration S and fitness potential vector V_fit"
      },
      {
        "name": "Output",
        "description": "Companion assignment vector c and binary action vector a indicating clone or persist for each walker"
      },
      {
        "name": "Stochastic Elements",
        "description": "Companion selection via softmax or uniform, and independent uniform threshold sampling for decisions"
      },
      {
        "name": "Key Quantity",
        "description": "Total cloning probability p_i for each walker, used in drift analysis"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm configuration",
        "description": "Current state of the swarm including positions and statuses of walkers",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "\\mathbf{V}_{\\text{fit}}",
        "name": "Fitness potential vector",
        "description": "Vector of fitness potentials V_fit,i for each walker i",
        "constraints": [],
        "tags": [
          "input",
          "fitness",
          "vector"
        ]
      },
      {
        "symbol": "\\epsilon_c",
        "name": "Companion selection scale",
        "description": "Scale parameter for the softmax distribution in companion selection",
        "constraints": [
          "\\epsilon_c > 0"
        ],
        "tags": [
          "hyperparameter",
          "scale",
          "companion"
        ]
      },
      {
        "symbol": "\\varepsilon_{\\text{clone}}",
        "name": "Cloning epsilon",
        "description": "Small positive constant to avoid division by zero in cloning score",
        "constraints": [
          "\\varepsilon_{\\text{clone}} > 0"
        ],
        "tags": [
          "hyperparameter",
          "regularization"
        ]
      },
      {
        "symbol": "p_{\\max}",
        "name": "Maximum cloning probability",
        "description": "Upper bound for the uniform threshold sampling",
        "constraints": [
          "0 < p_{\\max} \\leq 1"
        ],
        "tags": [
          "hyperparameter",
          "probability"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "note",
        "text": "The operator processes each walker independently but with shared randomness in companion selection probabilities."
      },
      {
        "type": "note",
        "text": "The total probability p_i is the expected cloning rate conditional on current swarm state and fitnesses, essential for analyzing population drift."
      }
    ],
    "related_refs": [],
    "tags": [
      "stochastic operator",
      "cloning decision",
      "swarm",
      "walker",
      "fitness potential",
      "companion selection",
      "cloning score",
      "drift analysis"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 6019,
      "end_line": 6071,
      "content_start": 6022,
      "content_end": 6070,
      "header_lines": [
        6020
      ]
    },
    "references": [
      "def-cloning-companion-operator",
      "lem-quantitative-keystone"
    ],
    "metadata": {
      "label": "def-decision-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-update-operator",
    "type": "definition",
    "title": "The State Update Operator",
    "term": "State Update Operator",
    "object_type": "operator",
    "nl_definition": "An operator that updates a swarm's positions, velocities, and statuses based on cloning and persistence actions, involving deterministic grouping of cloners, stochastic position jittering with Gaussian noise, momentum-conserving inelastic collisions for velocities without jitter, and setting all output statuses to alive.",
    "content_markdown": ":label: def-update-operator\n\nThe state update operator implements the inelastic collision model (see {prf:ref}`def-inelastic-collision-update`) to update walker states after cloning decisions.\n\n**Input:**\n- Swarm configuration $S$\n- Companion vector $\\mathbf{c}$\n- Action vector $\\mathbf{a}$\n\n**Deterministic Grouping:**\n\nFor each unique companion $j \\in \\mathcal{A}(S)$, identify all walkers cloning from it:\n\n$$\nI_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}\n$$\n\nLet $M_j = |I_j|$ be the number of cloners for companion $j$.\n\n**Stochastic State Update:**\n\nFor each $(M_j + 1)$-particle system consisting of companion $j$ and its cloners $I_j$:\n\n1. **Position Updates:**\n\n   For each cloner $i \\in I_j$, the position is reset to the companion's position plus **Gaussian jitter**:\n\n\n$$\nx'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\text{where } \\zeta_i^x \\sim \\mathcal{N}(0, I_d)\n$$\n\n\n   Companion position is unchanged: $x'_j = x_j$\n\n2. **Velocity Updates (The Inelastic Collision):**\n\n   The velocities are updated through a momentum-conserving inelastic collision model. **There is NO Gaussian jitter added to velocities.**\n\n   **a. Center-of-Mass Velocity:**\n\n\n$$\nV_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)\n$$\n\n\n   **b. Update Relative Velocities:**\n\n   For each walker $k \\in I_j \\cup \\{j\\}$, compute the relative velocity:\n\n\n$$\nu_k = v_k - V_{\\text{COM},j}\n$$\n\n\n   Sample a random orthogonal transformation $R_k$ that isotropically rotates $u_k$ (uniformly random direction on the $(d-1)$-sphere, preserving magnitude). The new relative velocity is:\n\n\n$$\nu'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n$$\n\n\n   **c. Return to Lab Frame:**\n\n\n$$\nv'_k = V_{\\text{COM},j} + u'_k\n$$\n\n3. **Persisting Walkers:**\n\n   For walkers with $a_i = \\text{persist}$:\n\n\n$$\nx'_i = x_i, \\quad v'_i = v_i\n$$\n\n4. **Status Update:**\n\n   All walkers in the output are alive:\n\n\n$$\ns'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n$$",
    "raw_directive": "6106: The final stage executes the cloning actions, producing the output swarm configuration.\n6107: \n6108: :::{prf:definition} The State Update Operator\n6109: :label: def-update-operator\n6110: \n6111: The state update operator implements the inelastic collision model (see {prf:ref}`def-inelastic-collision-update`) to update walker states after cloning decisions.\n6112: \n6113: **Input:**\n6114: - Swarm configuration $S$\n6115: - Companion vector $\\mathbf{c}$\n6116: - Action vector $\\mathbf{a}$\n6117: \n6118: **Deterministic Grouping:**\n6119: \n6120: For each unique companion $j \\in \\mathcal{A}(S)$, identify all walkers cloning from it:\n6121: \n6122: $$\n6123: I_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}\n6124: $$\n6125: \n6126: Let $M_j = |I_j|$ be the number of cloners for companion $j$.\n6127: \n6128: **Stochastic State Update:**\n6129: \n6130: For each $(M_j + 1)$-particle system consisting of companion $j$ and its cloners $I_j$:\n6131: \n6132: 1. **Position Updates:**\n6133: \n6134:    For each cloner $i \\in I_j$, the position is reset to the companion's position plus **Gaussian jitter**:\n6135: \n6136: \n6137: $$\n6138: x'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\text{where } \\zeta_i^x \\sim \\mathcal{N}(0, I_d)\n6139: $$\n6140: \n6141: \n6142:    Companion position is unchanged: $x'_j = x_j$\n6143: \n6144: 2. **Velocity Updates (The Inelastic Collision):**\n6145: \n6146:    The velocities are updated through a momentum-conserving inelastic collision model. **There is NO Gaussian jitter added to velocities.**\n6147: \n6148:    **a. Center-of-Mass Velocity:**\n6149: \n6150: \n6151: $$\n6152: V_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)\n6153: $$\n6154: \n6155: \n6156:    **b. Update Relative Velocities:**\n6157: \n6158:    For each walker $k \\in I_j \\cup \\{j\\}$, compute the relative velocity:\n6159: \n6160: \n6161: $$\n6162: u_k = v_k - V_{\\text{COM},j}\n6163: $$\n6164: \n6165: \n6166:    Sample a random orthogonal transformation $R_k$ that isotropically rotates $u_k$ (uniformly random direction on the $(d-1)$-sphere, preserving magnitude). The new relative velocity is:\n6167: \n6168: \n6169: $$\n6170: u'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)\n6171: $$\n6172: \n6173: \n6174:    **c. Return to Lab Frame:**\n6175: \n6176: \n6177: $$\n6178: v'_k = V_{\\text{COM},j} + u'_k\n6179: $$\n6180: \n6181: 3. **Persisting Walkers:**\n6182: \n6183:    For walkers with $a_i = \\text{persist}$:\n6184: \n6185: \n6186: $$\n6187: x'_i = x_i, \\quad v'_i = v_i\n6188: $$\n6189: \n6190: 4. **Status Update:**\n6191: \n6192:    All walkers in the output are alive:\n6193: \n6194: \n6195: $$\n6196: s'_i = 1 \\quad \\text{for all } i \\in \\{1, \\ldots, N\\}\n6197: $$\n6198: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Deterministic Grouping: For each unique companion j in \\mathcal{A}(S), identify cloners I_j = {i : a_i = clone and c_i = j}, with M_j = |I_j|.",
        "latex": "I_j := \\{i \\in \\{1, \\ldots, N\\} : a_i = \\text{clone} \\text{ and } c_i = j\\}, \\quad M_j = |I_j|"
      },
      {
        "type": null,
        "text": "Position Updates for Cloners: For each i in I_j, x'_i = x_j + \\sigma_x \\zeta_i^x where \\zeta_i^x \\sim \\mathcal{N}(0, I_d); companion x'_j = x_j.",
        "latex": "x'_i = x_j + \\sigma_x \\zeta_i^x \\quad \\zeta_i^x \\sim \\mathcal{N}(0, I_d), \\quad x'_j = x_j"
      },
      {
        "type": null,
        "text": "Velocity Updates - Center-of-Mass: V_{COM,j} = 1/(M_j + 1) (v_j + \\sum_{i \\in I_j} v_i).",
        "latex": "V_{\\text{COM},j} = \\frac{1}{M_j + 1}\\left(v_j + \\sum_{i \\in I_j} v_i\\right)"
      },
      {
        "type": null,
        "text": "Velocity Updates - Relative Velocities: For k in I_j \\cup {j}, u_k = v_k - V_{COM,j}; u'_k = \\alpha_{restitution} \\cdot R_k(u_k) where R_k is random orthogonal transformation preserving magnitude.",
        "latex": "u_k = v_k - V_{\\text{COM},j}, \\quad u'_k = \\alpha_{\\text{restitution}} \\cdot R_k(u_k)"
      },
      {
        "type": null,
        "text": "Velocity Updates - Lab Frame: v'_k = V_{COM,j} + u'_k.",
        "latex": "v'_k = V_{\\text{COM},j} + u'_k"
      },
      {
        "type": null,
        "text": "Persisting Walkers: For a_i = persist, x'_i = x_i, v'_i = v_i.",
        "latex": "x'_i = x_i, \\quad v'_i = v_i"
      },
      {
        "type": null,
        "text": "Status Update: s'_i = 1 for all i in {1, ..., N}.",
        "latex": "s'_i = 1 \\quad \\forall i \\in \\{1, \\ldots, N\\}"
      }
    ],
    "properties": [
      {
        "name": "Deterministic Grouping",
        "description": "Groups cloners by unique companions before updates."
      },
      {
        "name": "Stochastic Position Jitter",
        "description": "Adds Gaussian noise to cloner positions relative to companion, with scale \\sigma_x."
      },
      {
        "name": "Inelastic Collision Model",
        "description": "Updates velocities via momentum conservation, restitution coefficient \\alpha_{restitution}, and random orthogonal rotations, without velocity jitter."
      },
      {
        "name": "Persistence",
        "description": "Unchanged positions and velocities for persisting walkers."
      },
      {
        "name": "Universal Alive Status",
        "description": "All output walkers are set to alive status."
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "Swarm configuration",
        "description": "Current state of the swarm including positions x, velocities v, and statuses s for N walkers.",
        "constraints": [],
        "tags": [
          "input",
          "swarm"
        ]
      },
      {
        "symbol": "\\mathbf{c}",
        "name": "Companion vector",
        "description": "Vector assigning each walker i a companion j in \\mathcal{A}(S) for cloning actions.",
        "constraints": [],
        "tags": [
          "input",
          "companion"
        ]
      },
      {
        "symbol": "\\mathbf{a}",
        "name": "Action vector",
        "description": "Vector specifying actions for each walker i, such as 'clone' or 'persist'.",
        "constraints": [],
        "tags": [
          "input",
          "action"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "clarification",
        "text": "No Gaussian jitter is added to velocities; only positions receive jitter during cloning."
      },
      {
        "type": "parameter",
        "text": "Parameters like \\sigma_x (jitter scale) and \\alpha_{restitution} (restitution coefficient) are assumed defined elsewhere."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "update",
      "operator",
      "cloning",
      "inelastic collision",
      "gaussian jitter",
      "velocity update",
      "position reset"
    ],
    "document_id": "03_cloning",
    "section": "## 9.3. Decomposition into Sub-Operators",
    "span": {
      "start_line": 6106,
      "end_line": 6198,
      "content_start": 6109,
      "content_end": 6197,
      "header_lines": [
        6107
      ]
    },
    "references": [
      "def-inelastic-collision-update"
    ],
    "metadata": {
      "label": "def-update-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 11,
      "chapter_file": "chapter_11.json",
      "section_id": "## 9.3. Decomposition into Sub-Operators"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-key-operator-outputs",
    "type": "definition",
    "title": "Key Operator Outputs",
    "term": "Key Operator Outputs",
    "object_type": "quantities",
    "nl_definition": "Central quantities in the drift analysis for a swarm S and its output S' under the cloning operator Ψ_clone, including cloning probabilities, position displacements, velocity perturbations, and centered displacements for coupled swarms.",
    "content_markdown": ":label: def-key-operator-outputs\n\nFor input swarm $S$ and output swarm $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$, the following quantities are central to the drift analysis:\n\n1. **Total Cloning Probability:** For each walker $i$:\n\n\n$$\np_i = P(\\text{walker } i \\text{ clones} \\mid S)\n$$\n\n2. **Position Displacement:** For each walker $i$:\n\n\n$$\n\\Delta x_i := x'_i - x_i\n$$\n\n   For cloners, $\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$.\n\n3. **Velocity Perturbation:** For each walker $i$ that participates in a cloning event:\n\n\n$$\n\\Delta v_i := v'_i - v_i\n$$\n\n   This arises from the inelastic collision model. The expected squared velocity change depends on:\n   - The center-of-mass shift: $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$\n   - The restitution coefficient: $\\alpha_{\\text{restitution}}$\n   - The random rotation: $R_i$\n\n4. **Centered Displacements:** For coupled swarms $(S_1, S_2)$:\n\n\n$$\n\\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}",
    "raw_directive": "6250: We conclude by highlighting the critical quantities (see {prf:ref}`def-key-operator-outputs`) that will be used in the subsequent drift analysis.\n6251: \n6252: :::{prf:definition} Key Operator Outputs\n6253: :label: def-key-operator-outputs\n6254: \n6255: For input swarm $S$ and output swarm $S' \\sim \\Psi_{\\text{clone}}(S, \\cdot)$, the following quantities are central to the drift analysis:\n6256: \n6257: 1. **Total Cloning Probability:** For each walker $i$:\n6258: \n6259: \n6260: $$\n6261: p_i = P(\\text{walker } i \\text{ clones} \\mid S)\n6262: $$\n6263: \n6264: 2. **Position Displacement:** For each walker $i$:\n6265: \n6266: \n6267: $$\n6268: \\Delta x_i := x'_i - x_i\n6269: $$\n6270: \n6271:    For cloners, $\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$.\n6272: \n6273: 3. **Velocity Perturbation:** For each walker $i$ that participates in a cloning event:\n6274: \n6275: \n6276: $$\n6277: \\Delta v_i := v'_i - v_i\n6278: $$\n6279: \n6280:    This arises from the inelastic collision model. The expected squared velocity change depends on:\n6281:    - The center-of-mass shift: $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$\n6282:    - The restitution coefficient: $\\alpha_{\\text{restitution}}$\n6283:    - The random rotation: $R_i$\n6284: \n6285: 4. **Centered Displacements:** For coupled swarms $(S_1, S_2)$:\n6286: \n6287: \n6288: $$\n6289: \\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}\n6290: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Total Cloning Probability for each walker i",
        "latex": "$$p_i = P(\\text{walker } i \\text{ clones} \\mid S)$$"
      },
      {
        "type": null,
        "text": "Position Displacement for each walker i",
        "latex": "$$\\Delta x_i := x'_i - x_i$$ For cloners, $$\\Delta x_i = x_{c_i} - x_i + \\sigma_x \\zeta_i^x$$ where $\\zeta_i^x \\sim \\mathcal{N}(0, I_d)$."
      },
      {
        "type": null,
        "text": "Velocity Perturbation for each walker i in cloning event",
        "latex": "$$\\Delta v_i := v'_i - v_i$$ Expected squared change depends on $\\mathbb{E}[\\|V_{\\text{COM},j} - v_i\\|^2]$, $\\alpha_{\\text{restitution}}$, and $R_i$."
      },
      {
        "type": null,
        "text": "Centered Displacements for coupled swarms (S_1, S_2)",
        "latex": "$$\\Delta\\delta_{x,i} := \\delta_{x,1,i} - \\delta_{x,2,i}$$"
      }
    ],
    "properties": [
      {
        "name": "Dependence on Swarm State",
        "description": "All quantities depend on the input swarm S and its walker positions/velocities."
      },
      {
        "name": "Stochastic Elements",
        "description": "Incorporate random variables like ζ_i^x ~ N(0, I_d) and random rotations R_i."
      },
      {
        "name": "Coupling Relevance",
        "description": "Centered displacements apply specifically to paired swarms for comparative analysis."
      }
    ],
    "parameters": [
      {
        "symbol": "p_i",
        "name": "Total Cloning Probability",
        "description": "Probability that walker i clones given the input swarm S",
        "constraints": [],
        "tags": [
          "probability",
          "cloning"
        ]
      },
      {
        "symbol": "Δx_i",
        "name": "Position Displacement",
        "description": "Change in position for walker i, specifically for cloners Δx_i = x_{c_i} - x_i + σ_x ζ_i^x where ζ_i^x ~ N(0, I_d)",
        "constraints": [
          "For cloners"
        ],
        "tags": [
          "displacement",
          "position"
        ]
      },
      {
        "symbol": "Δv_i",
        "name": "Velocity Perturbation",
        "description": "Change in velocity for walker i participating in cloning, from inelastic collision depending on center-of-mass shift, restitution coefficient α_restitution, and random rotation R_i",
        "constraints": [
          "For cloning participants"
        ],
        "tags": [
          "velocity",
          "perturbation",
          "collision"
        ]
      },
      {
        "symbol": "Δδ_{x,i}",
        "name": "Centered Displacements",
        "description": "Difference in position displacements for coupled swarms (S_1, S_2): δ_{x,1,i} - δ_{x,2,i}",
        "constraints": [],
        "tags": [
          "coupled",
          "displacement",
          "centered"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "These quantities are used in subsequent drift analysis for swarm evolution under cloning."
      }
    ],
    "related_refs": [],
    "tags": [
      "swarm",
      "cloning",
      "drift analysis",
      "probability",
      "displacement",
      "velocity perturbation",
      "coupled swarms"
    ],
    "document_id": "03_cloning",
    "section": "## 9.5. Key Quantities for Drift Analysis",
    "span": {
      "start_line": 6250,
      "end_line": 6290,
      "content_start": 6253,
      "content_end": 6289,
      "header_lines": [
        6251
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-key-operator-outputs"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 13,
      "chapter_file": "chapter_13.json",
      "section_id": "## 9.5. Key Quantities for Drift Analysis"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-coupled-cloning-expectation",
    "type": "definition",
    "title": "Coupled Cloning Expectation",
    "term": "Coupled Cloning Expectation",
    "object_type": "expectation operator",
    "nl_definition": "The expected value of a function f applied to the output swarms (S'_1, S'_2) obtained by independently applying the cloning operation Ψ_clone to input swarms (S_1, S_2), where all sources of randomness in the cloning processes are synchronously coupled.",
    "content_markdown": ":label: def-coupled-cloning-expectation\n\nConsider two swarms $(S_1, S_2)$ in the coupled state space (see {prf:ref}`def-coupled-state-space`). Let $(S'_1, S'_2)$ be the output swarms after applying $\\Psi_{\\text{clone}}$ to each independently, using **synchronous coupling** of all randomness:\n\n- Same PRNG seeds for companion selection\n- Same pairing algorithm random choices\n- Same threshold samples $T_i$ for each walker index $i$\n- Same Gaussian jitters $\\zeta_i^x$ for position updates (when both walkers clone)\n- Same rotation operators $R_i$ for velocity collisions (when both walkers participate in collisions)\n\nFor any function $f: \\Sigma_N \\times \\Sigma_N \\to \\mathbb{R}$, the **coupled cloning expectation** is:\n\n$$\n\\mathbb{E}_{\\text{clone}}[f(S'_1, S'_2) \\mid S_1, S_2] := \\mathbb{E}[f(S'_1, S'_2) \\mid S_1, S_2, \\text{coupling}]",
    "raw_directive": "6370: To analyze the drift of the Lyapunov function components, we work with two copies of the swarm evolving under synchronous coupling.\n6371: \n6372: :::{prf:definition} Coupled Cloning Expectation\n6373: :label: def-coupled-cloning-expectation\n6374: \n6375: Consider two swarms $(S_1, S_2)$ in the coupled state space (see {prf:ref}`def-coupled-state-space`). Let $(S'_1, S'_2)$ be the output swarms after applying $\\Psi_{\\text{clone}}$ to each independently, using **synchronous coupling** of all randomness:\n6376: \n6377: - Same PRNG seeds for companion selection\n6378: - Same pairing algorithm random choices\n6379: - Same threshold samples $T_i$ for each walker index $i$\n6380: - Same Gaussian jitters $\\zeta_i^x$ for position updates (when both walkers clone)\n6381: - Same rotation operators $R_i$ for velocity collisions (when both walkers participate in collisions)\n6382: \n6383: For any function $f: \\Sigma_N \\times \\Sigma_N \\to \\mathbb{R}$, the **coupled cloning expectation** is:\n6384: \n6385: $$\n6386: \\mathbb{E}_{\\text{clone}}[f(S'_1, S'_2) \\mid S_1, S_2] := \\mathbb{E}[f(S'_1, S'_2) \\mid S_1, S_2, \\text{coupling}]\n6387: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "Same PRNG seeds for companion selection",
        "latex": null
      },
      {
        "type": null,
        "text": "Same pairing algorithm random choices",
        "latex": null
      },
      {
        "type": null,
        "text": "Same threshold samples T_i for each walker index i",
        "latex": null
      },
      {
        "type": null,
        "text": "Same Gaussian jitters ζ_i^x for position updates (when both walkers clone)",
        "latex": null
      },
      {
        "type": null,
        "text": "Same rotation operators R_i for velocity collisions (when both walkers participate in collisions)",
        "latex": null
      }
    ],
    "properties": [],
    "parameters": [
      {
        "symbol": "S_1",
        "name": "first swarm",
        "description": "A swarm in the coupled state space.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "S_2",
        "name": "second swarm",
        "description": "A swarm in the coupled state space.",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "f",
        "name": "test function",
        "description": "A function f: Σ_N × Σ_N → ℝ.",
        "constraints": [],
        "tags": [
          "function",
          "test"
        ]
      }
    ],
    "examples": [],
    "notes": [],
    "related_refs": [],
    "tags": [
      "coupled",
      "cloning",
      "expectation",
      "synchronous",
      "swarm",
      "randomness",
      "PRNG"
    ],
    "document_id": "03_cloning",
    "section": "## 10.2. The Coupled Expectation Framework",
    "span": {
      "start_line": 6370,
      "end_line": 6387,
      "content_start": 6373,
      "content_end": 6386,
      "header_lines": [
        6371
      ]
    },
    "references": [
      "def-coupled-state-space"
    ],
    "metadata": {
      "label": "def-coupled-cloning-expectation"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 16,
      "chapter_file": "chapter_16.json",
      "section_id": "## 10.2. The Coupled Expectation Framework"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-boundary-potential-recall",
    "type": "definition",
    "title": "Boundary Potential Component (Recall)",
    "term": "boundary potential",
    "object_type": "function",
    "nl_definition": "The boundary potential is the average value of a smooth barrier function applied to the states of agents in two swarms, promoting safety by penalizing proximity to the boundary of the valid state space.",
    "content_markdown": ":label: def-boundary-potential-recall\n\nFrom {prf:ref}`def-full-synergistic-lyapunov-function`, the boundary potential is:\n\n$$\nW_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n$$\n\nwhere $\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}$ is the smooth barrier function satisfying:\n\n1. **Interior safety:** $\\varphi_{\\text{barrier}}(x) = 0$ for $x$ in the safe interior region (distance $> \\delta_{\\text{safe}}$ from boundary)\n\n2. **Boundary growth:** $\\varphi_{\\text{barrier}}(x) \\to \\infty$ as $x \\to \\partial \\mathcal{X}_{\\text{valid}}$\n\n3. **Smoothness:** $\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}})$ with bounded derivatives in the interior",
    "raw_directive": "7096: ### 11.2.1. The Barrier Function\n7097: \n7098: :::{prf:definition} Boundary Potential Component (Recall)\n7099: :label: def-boundary-potential-recall\n7100: \n7101: From {prf:ref}`def-full-synergistic-lyapunov-function`, the boundary potential is:\n7102: \n7103: $$\n7104: W_b(S_1, S_2) := \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_1)} \\varphi_{\\text{barrier}}(x_{1,i}) + \\frac{1}{N} \\sum_{i \\in \\mathcal{A}(S_2)} \\varphi_{\\text{barrier}}(x_{2,i})\n7105: $$\n7106: \n7107: where $\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}$ is the smooth barrier function satisfying:\n7108: \n7109: 1. **Interior safety:** $\\varphi_{\\text{barrier}}(x) = 0$ for $x$ in the safe interior region (distance $> \\delta_{\\text{safe}}$ from boundary)\n7110: \n7111: 2. **Boundary growth:** $\\varphi_{\\text{barrier}}(x) \\to \\infty$ as $x \\to \\partial \\mathcal{X}_{\\text{valid}}$\n7112: \n7113: 3. **Smoothness:** $\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}})$ with bounded derivatives in the interior\n7114: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "Interior safety: \\varphi_{\\text{barrier}}(x) = 0 for x in the safe interior region (distance > \\delta_{\\text{safe}} from boundary)",
        "latex": "\\varphi_{\\text{barrier}}(x) = 0 \\ \\forall x \\in \\text{interior (dist}(x, \\partial \\mathcal{X}_{\\text{valid}}) > \\delta_{\\text{safe}})"
      },
      {
        "type": null,
        "text": "Boundary growth: \\varphi_{\\text{barrier}}(x) \\to \\infty as x \\to \\partial \\mathcal{X}_{\\text{valid}}",
        "latex": "\\varphi_{\\text{barrier}}(x) \\to \\infty \\ \\text{as} \\ x \\to \\partial \\mathcal{X}_{\\text{valid}}"
      },
      {
        "type": null,
        "text": "Smoothness: \\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}}) with bounded derivatives in the interior",
        "latex": "\\varphi_{\\text{barrier}} \\in C^2(\\mathcal{X}_{\\text{valid}}), \\ \\text{bounded derivatives in interior}"
      }
    ],
    "properties": [
      {
        "name": "Non-negativity",
        "description": "W_b(S_1, S_2) \\geq 0 due to \\varphi_{\\text{barrier}} \\geq 0"
      },
      {
        "name": "Averaged sum",
        "description": "Computed as average over agents in each swarm"
      },
      {
        "name": "Recall definition",
        "description": "Component of the full synergistic Lyapunov function"
      }
    ],
    "parameters": [
      {
        "symbol": "S_1",
        "name": "S_1",
        "description": "State of the first swarm",
        "constraints": [],
        "tags": [
          "swarm-state"
        ]
      },
      {
        "symbol": "S_2",
        "name": "S_2",
        "description": "State of the second swarm",
        "constraints": [],
        "tags": [
          "swarm-state"
        ]
      },
      {
        "symbol": "N",
        "name": "N",
        "description": "Number of agents in each swarm",
        "constraints": [
          "N > 0",
          "integer"
        ],
        "tags": [
          "agent-count"
        ]
      },
      {
        "symbol": "\\varphi_{\\text{barrier}}",
        "name": "varphi_barrier",
        "description": "Smooth barrier function mapping valid states to non-negative reals",
        "constraints": [
          "\\varphi_{\\text{barrier}}: \\mathcal{X}_{\\text{valid}} \\to \\mathbb{R}_{\\geq 0}"
        ],
        "tags": [
          "barrier",
          "smooth"
        ]
      },
      {
        "symbol": "\\mathcal{A}(S_1)",
        "name": "A(S_1)",
        "description": "Set of agent indices in swarm S_1",
        "constraints": [],
        "tags": [
          "agent-set"
        ]
      },
      {
        "symbol": "x_{1,i}",
        "name": "x_{1,i}",
        "description": "State of the i-th agent in S_1",
        "constraints": [
          "i \\in \\mathcal{A}(S_1)"
        ],
        "tags": [
          "agent-state"
        ]
      },
      {
        "symbol": "x_{2,i}",
        "name": "x_{2,i}",
        "description": "State of the i-th agent in S_2",
        "constraints": [
          "i \\in \\mathcal{A}(S_2)"
        ],
        "tags": [
          "agent-state"
        ]
      },
      {
        "symbol": "\\delta_{\\text{safe}}",
        "name": "delta_safe",
        "description": "Safety distance threshold from boundary",
        "constraints": [
          "\\delta_{\\text{safe}} > 0"
        ],
        "tags": [
          "safety-threshold"
        ]
      },
      {
        "symbol": "\\mathcal{X}_{\\text{valid}}",
        "name": "X_valid",
        "description": "Valid state space",
        "constraints": [],
        "tags": [
          "state-space"
        ]
      },
      {
        "symbol": "\\partial \\mathcal{X}_{\\text{valid}}",
        "name": "partial X_valid",
        "description": "Boundary of the valid state space",
        "constraints": [],
        "tags": [
          "boundary"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "recall",
        "text": "This definition is recalled from the full synergistic Lyapunov function for context in the barrier analysis."
      }
    ],
    "related_refs": [
      "def-full-synergistic-lyapunov-function"
    ],
    "tags": [
      "boundary-potential",
      "barrier-function",
      "safety",
      "lyapunov-component",
      "multi-agent",
      "swarm",
      "smoothness"
    ],
    "document_id": "03_cloning",
    "section": "## 11.2. The Boundary Barrier and Fitness Gradient",
    "span": {
      "start_line": 7096,
      "end_line": 7114,
      "content_start": 7099,
      "content_end": 7113,
      "header_lines": [
        7097
      ]
    },
    "references": [
      "def-full-synergistic-lyapunov-function",
      "prop-barrier-existence"
    ],
    "metadata": {
      "label": "def-boundary-potential-recall"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 23,
      "chapter_file": "chapter_23.json",
      "section_id": "## 11.2. The Boundary Barrier and Fitness Gradient"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-boundary-exposed-set",
    "type": "definition",
    "title": "The Boundary-Exposed Set",
    "term": "boundary-exposed set",
    "object_type": "set",
    "nl_definition": "The boundary-exposed set of a swarm is the collection of its alive walkers whose barrier penalty exceeds a specified positive threshold, signaling dangerous proximity to the boundary; associated is the boundary-exposed mass, averaging these penalties normalized by the total number of walkers.",
    "content_markdown": ":label: def-boundary-exposed-set\n\nFor a swarm $S$ and a threshold $\\phi_{\\text{thresh}} > 0$, the **boundary-exposed set** is:\n\n$$\n\\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}\n$$\n\nThese are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary.\n\nThe **boundary-exposed mass** is:\n\n$$\nM_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)",
    "raw_directive": "7304: We now formalize the set of walkers (see {prf:ref}`def-boundary-exposed-set`) that are in danger due to boundary proximity.\n7305: \n7306: :::{prf:definition} The Boundary-Exposed Set\n7307: :label: def-boundary-exposed-set\n7308: \n7309: For a swarm $S$ and a threshold $\\phi_{\\text{thresh}} > 0$, the **boundary-exposed set** is:\n7310: \n7311: $$\n7312: \\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}\n7313: $$\n7314: \n7315: These are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary.\n7316: \n7317: The **boundary-exposed mass** is:\n7318: \n7319: $$\n7320: M_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)\n7321: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "The boundary-exposed set",
        "latex": "\\mathcal{E}_{\\text{boundary}}(S) := \\{i \\in \\mathcal{A}(S) : \\varphi_{\\text{barrier}}(x_i) > \\phi_{\\text{thresh}}\\}"
      },
      {
        "type": null,
        "text": "The boundary-exposed mass",
        "latex": "M_{\\text{boundary}}(S) := \\frac{1}{N} \\sum_{i \\in \\mathcal{E}_{\\text{boundary}}(S)} \\varphi_{\\text{barrier}}(x_i)"
      }
    ],
    "properties": [
      {
        "name": "membership condition",
        "description": "An index i belongs to the set if it is an alive walker and its barrier penalty φ_barrier(x_i) > φ_thresh"
      },
      {
        "name": "mass computation",
        "description": "Average barrier penalty over exposed walkers, normalized by total walker count N"
      }
    ],
    "parameters": [
      {
        "symbol": "S",
        "name": "swarm",
        "description": "The swarm of walkers",
        "constraints": [],
        "tags": [
          "swarm"
        ]
      },
      {
        "symbol": "\\phi_{\\text{thresh}}",
        "name": "threshold",
        "description": "Positive threshold for barrier penalty",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "threshold",
          "positive"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "These are alive walkers whose barrier penalty exceeds the threshold, indicating dangerous proximity to the boundary."
      }
    ],
    "related_refs": [],
    "tags": [
      "boundary",
      "exposed",
      "set",
      "swarm",
      "walkers",
      "proximity",
      "threshold",
      "barrier",
      "mass"
    ],
    "document_id": "03_cloning",
    "section": "## 11.2. The Boundary Barrier and Fitness Gradient",
    "span": {
      "start_line": 7304,
      "end_line": 7321,
      "content_start": 7307,
      "content_end": 7320,
      "header_lines": [
        7305
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-boundary-exposed-set"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "03_cloning",
      "chapter_index": 23,
      "chapter_file": "chapter_23.json",
      "section_id": "## 11.2. The Boundary Barrier and Fitness Gradient"
    },
    "generated_at": "2025-11-10T13:57:32.712710+00:00",
    "alt_labels": []
  },
  {
    "label": "def-mean-field-phase-space",
    "type": "definition",
    "title": "Phase Space",
    "term": "phase space",
    "object_type": "set",
    "nl_definition": "The single-particle phase space Ω is the Cartesian product of a bounded convex position domain with a C² boundary and a closed ball of allowed velocities, representing all possible kinematic states of a particle under the constraints of the Euclidean Gas algorithm.",
    "content_markdown": ":label: def-mean-field-phase-space\n\nLet $X_{\\text{valid}} \\subset \\mathbb{R}^d$ be the bounded, convex domain with a $C^2$ boundary, and let $V_{\\text{alg}} := \\{v \\in \\mathbb{R}^d : \\|v\\| \\le V_{\\text{alg}}\\}$ be the closed ball of allowed velocities, as defined in the Euclidean Gas specification (*Chapter 2, Sec. 1.1*).\n\nThe single-particle **phase space**, denoted $\\Omega$, is the Cartesian product of the valid position and velocity domains:\n\n$$\n\\Omega := X_{\\text{valid}} \\times V_{\\text{alg}}",
    "raw_directive": "37: The single-particle **phase space** defines the complete set of possible kinematic states—position and velocity—that a particle can occupy. Its properties are not arbitrary but are a direct, faithful translation of the constraints imposed on the walkers in the discrete Euclidean Gas algorithm.\n38: \n39: :::{prf:definition} Phase Space\n40: :label: def-mean-field-phase-space\n41: \n42: Let $X_{\\text{valid}} \\subset \\mathbb{R}^d$ be the bounded, convex domain with a $C^2$ boundary, and let $V_{\\text{alg}} := \\{v \\in \\mathbb{R}^d : \\|v\\| \\le V_{\\text{alg}}\\}$ be the closed ball of allowed velocities, as defined in the Euclidean Gas specification (*Chapter 2, Sec. 1.1*).\n43: \n44: The single-particle **phase space**, denoted $\\Omega$, is the Cartesian product of the valid position and velocity domains:\n45: \n46: $$\n47: \\Omega := X_{\\text{valid}} \\times V_{\\text{alg}}\n48: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "X_valid is a bounded, convex subset of R^d with a C^2 boundary.",
        "latex": "X_{\\text{valid}} \\subset \\mathbb{R}^d"
      },
      {
        "type": null,
        "text": "V_alg is the closed ball of allowed velocities with radius V_alg.",
        "latex": "V_{\\text{alg}} := \\{v \\in \\mathbb{R}^d : \\|v\\| \\le V_{\\text{alg}}\\}"
      },
      {
        "type": null,
        "text": "The phase space Ω is the Cartesian product.",
        "latex": "\\Omega := X_{\\text{valid}} \\times V_{\\text{alg}}"
      }
    ],
    "properties": [
      {
        "name": "complete kinematic states",
        "description": "encompasses all possible positions and velocities for a particle"
      },
      {
        "name": "algorithmic constraints",
        "description": "directly translates the position and velocity limits from the discrete Euclidean Gas algorithm"
      }
    ],
    "parameters": [
      {
        "symbol": "d",
        "name": "dimension",
        "description": "the dimension of the ambient Euclidean space",
        "constraints": [],
        "tags": [
          "dimension"
        ]
      },
      {
        "symbol": "V_{alg}",
        "name": "velocity bound",
        "description": "the maximum magnitude of allowed velocities in the algorithm",
        "constraints": [
          "V_{alg} > 0"
        ],
        "tags": [
          "velocity",
          "bound",
          "algorithm"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "introductory",
        "text": "The single-particle phase space defines the complete set of possible kinematic states—position and velocity—that a particle can occupy."
      },
      {
        "type": "reference",
        "text": "Properties are a direct, faithful translation of the constraints imposed on the walkers in the discrete Euclidean Gas algorithm, as defined in the Euclidean Gas specification (Chapter 2, Sec. 1.1)."
      }
    ],
    "related_refs": [],
    "tags": [
      "phase space",
      "single-particle",
      "kinematic states",
      "position domain",
      "velocity domain",
      "cartesian product",
      "euclidean gas",
      "mean field"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 37,
      "end_line": 48,
      "content_start": 40,
      "content_end": 47,
      "header_lines": [
        38
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-mean-field-phase-space"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-phase-space-density",
    "type": "definition",
    "title": "Phase-Space Density",
    "term": "phase-space sub-probability density",
    "object_type": "density function",
    "nl_definition": "A non-negative function f on time and phase space that represents the continuous density of probability mass for alive particles, where its integral over subsets gives the expected fraction of alive walkers in those regions, with total alive mass at most 1.",
    "content_markdown": ":label: def-phase-space-density\n\nThe state of the swarm's **alive population** at time $t \\ge 0$ is described by the **phase-space sub-probability density** $f: [0, \\infty) \\times \\Omega \\to [0, \\infty)$, where $\\Omega$ is the single-particle phase space (see {prf:ref}`def-mean-field-phase-space`). For any time $t$, $f(t, \\cdot, \\cdot)$ is a function on the phase space such that for any measurable subset $A \\subseteq \\Omega$, the mass of alive walkers in $A$ is given by the integral:\n\n$$\n\\text{Alive mass in } A = \\int_A f(t, z) dz.\n$$\n\nJust as integrating a city's population density over a neighborhood gives the number of people living there, integrating $f$ over a region of phase space gives the fraction of alive walkers expected to be in that region.\n\nThe integral of this density gives the total mass of alive walkers, $m_a(t)$:\n\n$$\nm_a(t) := \\int_{\\Omega} f(t,x,v)\\,\\mathrm{d}x\\,\\mathrm{d}v \\le 1\n$$\n\nThe mass of dead walkers is then given by $m_d(t) = 1 - m_a(t)$. The evolution of the system will be described by a coupled system for $f(t,z)$ and $m_d(t)$ that conserves the total mass $m_a(t) + m_d(t) = 1$.",
    "raw_directive": "59: With the arena defined, we can now introduce the central object of our analysis. Instead of tracking individual walkers, we track the continuous density of the probability cloud, $f(t,x,v)$. A high value of $f$ at a point $(t,x,v)$ signifies a high concentration of probability mass, meaning it is more likely to find a particle with that position and velocity at that time.\n60: \n61: :::{prf:definition} Phase-Space Density\n62: :label: def-phase-space-density\n63: \n64: The state of the swarm's **alive population** at time $t \\ge 0$ is described by the **phase-space sub-probability density** $f: [0, \\infty) \\times \\Omega \\to [0, \\infty)$, where $\\Omega$ is the single-particle phase space (see {prf:ref}`def-mean-field-phase-space`). For any time $t$, $f(t, \\cdot, \\cdot)$ is a function on the phase space such that for any measurable subset $A \\subseteq \\Omega$, the mass of alive walkers in $A$ is given by the integral:\n65: \n66: $$\n67: \\text{Alive mass in } A = \\int_A f(t, z) dz.\n68: $$\n69: \n70: Just as integrating a city's population density over a neighborhood gives the number of people living there, integrating $f$ over a region of phase space gives the fraction of alive walkers expected to be in that region.\n71: \n72: The integral of this density gives the total mass of alive walkers, $m_a(t)$:\n73: \n74: $$\n75: m_a(t) := \\int_{\\Omega} f(t,x,v)\\,\\mathrm{d}x\\,\\mathrm{d}v \\le 1\n76: $$\n77: \n78: The mass of dead walkers is then given by $m_d(t) = 1 - m_a(t)$. The evolution of the system will be described by a coupled system for $f(t,z)$ and $m_d(t)$ that conserves the total mass $m_a(t) + m_d(t) = 1$.\n79: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "f: [0, ∞) × Ω → [0, ∞)",
        "latex": "$f: [0, \\infty) \\times \\Omega \\to [0, \\infty)$"
      },
      {
        "type": null,
        "text": "For measurable A ⊆ Ω, alive mass in A is ∫_A f(t, z) dz ≥ 0",
        "latex": "$\\int_A f(t, z) \\, dz \\ge 0$"
      },
      {
        "type": null,
        "text": "Total alive mass m_a(t) = ∫_Ω f(t, x, v) dx dv ≤ 1",
        "latex": "$m_a(t) := \\int_\\Omega f(t,x,v) \\, \\mathrm{d}x \\, \\mathrm{d}v \\le 1$"
      },
      {
        "type": null,
        "text": "Dead mass m_d(t) = 1 - m_a(t)",
        "latex": "$m_d(t) = 1 - m_a(t)$"
      },
      {
        "type": null,
        "text": "Total mass conserved: m_a(t) + m_d(t) = 1",
        "latex": "$m_a(t) + m_d(t) = 1$"
      }
    ],
    "properties": [
      {
        "name": "Non-negativity",
        "description": "f(t, z) ≥ 0 for all t ≥ 0, z ∈ Ω, ensuring probabilities are non-negative."
      },
      {
        "name": "Sub-probability",
        "description": "The total integral over Ω is at most 1, accounting for possible mass loss to death."
      },
      {
        "name": "Mass Interpretation",
        "description": "Integrals over subsets A yield the expected fraction of alive walkers in A."
      },
      {
        "name": "Conservation",
        "description": "The sum of alive and dead masses remains 1 throughout evolution."
      }
    ],
    "parameters": [
      {
        "symbol": "f",
        "name": "phase-space sub-probability density",
        "description": "Non-negative function describing the density of alive walkers in phase space at time t",
        "constraints": [
          "f: [0, ∞) × Ω → [0, ∞)",
          "∫_A f(t, z) dz ≥ 0 for measurable A ⊆ Ω",
          "∫_Ω f(t, z) dz ≤ 1"
        ],
        "tags": [
          "density",
          "non-negative",
          "integrable"
        ]
      },
      {
        "symbol": "Ω",
        "name": "single-particle phase space",
        "description": "The phase space for individual particles",
        "constraints": [],
        "tags": [
          "phase-space"
        ]
      },
      {
        "symbol": "m_a(t)",
        "name": "total alive mass",
        "description": "Total probability mass of alive walkers at time t",
        "constraints": [
          "m_a(t) = ∫_Ω f(t, x, v) dx dv",
          "0 ≤ m_a(t) ≤ 1"
        ],
        "tags": [
          "mass",
          "alive"
        ]
      },
      {
        "symbol": "m_d(t)",
        "name": "dead mass",
        "description": "Probability mass of dead walkers at time t",
        "constraints": [
          "m_d(t) = 1 - m_a(t)"
        ],
        "tags": [
          "mass",
          "dead"
        ]
      }
    ],
    "examples": [
      {
        "text": "Just as integrating a city's population density over a neighborhood gives the number of people living there, integrating f over a region of phase space gives the fraction of alive walkers expected to be in that region.",
        "latex": null
      }
    ],
    "notes": [
      {
        "type": "evolution",
        "text": "The system's evolution is governed by a coupled PDE for f(t, z) and ODE for m_d(t), preserving total mass."
      },
      {
        "type": "context",
        "text": "This density tracks the alive population's probability cloud in phase space, rather than individual walkers."
      }
    ],
    "related_refs": [
      "def-mean-field-phase-space"
    ],
    "tags": [
      "phase-space",
      "density",
      "sub-probability",
      "alive population",
      "mass integral",
      "swarm dynamics"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 59,
      "end_line": 79,
      "content_start": 62,
      "content_end": 78,
      "header_lines": [
        60
      ]
    },
    "references": [
      "def-mean-field-phase-space"
    ],
    "metadata": {
      "label": "def-phase-space-density"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-mean-field-moments",
    "type": "definition",
    "title": "Mean-Field Statistical Moments",
    "term": "Mean-Field Statistical Moments",
    "object_type": "functionals",
    "nl_definition": "Functionals of the phase-space density f that compute the mean and variance of rewards and pairwise distances with respect to the normalized alive population density f / m_a(t).",
    "content_markdown": ":label: def-mean-field-moments\n\nLet $f(t, \\cdot)$ be the phase-space density (see {prf:ref}`def-phase-space-density`) at time $t$, with total alive mass $m_a(t) = \\int_\\Omega f(t,z)\\,\\mathrm{d}z$. The statistical moments required for the standardization pipeline are defined as the following **functionals** of $f$. The notation $\\mu[f]$ emphasizes that these are numbers that depend on the entire *shape* of the function $f$.\n\nThe moments are computed with respect to the **normalized density of the alive population**, which is $f(t,z) / m_a(t)$. This normalization is critical for ensuring the mean-field model is a faithful limit of the N-particle system, where statistics are computed by averaging over the $k$ alive walkers.\n\n*   **Reward Moments:** The mean reward, $\\mu_R[f]$, is computed as the expected value over the normalized alive population:\n\n    $$\n    \\mu_R[f](t) := \\int_{\\Omega} R(z) \\frac{f(t,z)}{m_a(t)}\\,\\mathrm dz\n    $$\n\n    $$\n    \\sigma_R^2[f](t) := \\int_{\\Omega} \\bigl(R(z) - \\mu_R[f](t)\\bigr)^2 \\frac{f(t,z)}{m_a(t)}\\,\\mathrm dz\n    $$\n\n*   **Distance Moments:** The mean distance is the expectation of the distance between two particles drawn independently from the normalized alive population:\n\n    $$\n    \\mu_D[f](t) := \\iint_{\\Omega \\times \\Omega} d_{\\mathcal{Y}}(\\varphi(z), \\varphi(z')) \\frac{f(t,z)}{m_a(t)} \\frac{f(t,z')}{m_a(t)}\\,\\mathrm dz\\,\\mathrm dz'\n    $$\n\n    $$",
    "raw_directive": "114: In the N-particle system, measurements are aggregated by computing empirical statistics over the finite set of alive walkers. In the mean-field limit, these discrete sums are replaced by integrals over the phase-space density $f$.\n115: \n116: :::{prf:definition} Mean-Field Statistical Moments\n117: :label: def-mean-field-moments\n118: \n119: Let $f(t, \\cdot)$ be the phase-space density (see {prf:ref}`def-phase-space-density`) at time $t$, with total alive mass $m_a(t) = \\int_\\Omega f(t,z)\\,\\mathrm{d}z$. The statistical moments required for the standardization pipeline are defined as the following **functionals** of $f$. The notation $\\mu[f]$ emphasizes that these are numbers that depend on the entire *shape* of the function $f$.\n120: \n121: The moments are computed with respect to the **normalized density of the alive population**, which is $f(t,z) / m_a(t)$. This normalization is critical for ensuring the mean-field model is a faithful limit of the N-particle system, where statistics are computed by averaging over the $k$ alive walkers.\n122: \n123: *   **Reward Moments:** The mean reward, $\\mu_R[f]$, is computed as the expected value over the normalized alive population:\n124: \n125:     $$\n126:     \\mu_R[f](t) := \\int_{\\Omega} R(z) \\frac{f(t,z)}{m_a(t)}\\,\\mathrm dz\n127:     $$\n128: \n129:     $$\n130:     \\sigma_R^2[f](t) := \\int_{\\Omega} \\bigl(R(z) - \\mu_R[f](t)\\bigr)^2 \\frac{f(t,z)}{m_a(t)}\\,\\mathrm dz\n131:     $$\n132: \n133: *   **Distance Moments:** The mean distance is the expectation of the distance between two particles drawn independently from the normalized alive population:\n134: \n135:     $$\n136:     \\mu_D[f](t) := \\iint_{\\Omega \\times \\Omega} d_{\\mathcal{Y}}(\\varphi(z), \\varphi(z')) \\frac{f(t,z)}{m_a(t)} \\frac{f(t,z')}{m_a(t)}\\,\\mathrm dz\\,\\mathrm dz'\n137:     $$\n138: \n139:     $$\n140:     \\sigma_D^2[f](t) := \\iint_{\\Omega \\times \\Omega} \\bigl(d_{\\mathcal{Y}}(\\varphi(z), \\varphi(z')) - \\mu_D[f](t)\\bigr)^2 \\frac{f(t,z)}{m_a(t)} \\frac{f(t,z')}{m_a(t)}\\,\\mathrm dz\\,\\mathrm dz'",
    "formal_conditions": [
      {
        "type": null,
        "text": "f(t, ·) is the phase-space density with total alive mass m_a(t) = ∫_Ω f(t,z) dz > 0",
        "latex": null
      },
      {
        "type": null,
        "text": "Normalization uses the density f(t,z) / m_a(t) to mimic averaging over alive walkers in the N-particle system",
        "latex": null
      }
    ],
    "properties": [
      {
        "name": "Reward Moments",
        "description": "Mean μ_R[f](t) and variance σ_R²[f](t) of the reward function R(z) under the normalized density f(t,z) / m_a(t)."
      },
      {
        "name": "Distance Moments",
        "description": "Mean μ_D[f](t) and variance σ_D²[f](t) of the distance d_Y(φ(z), φ(z')) between two independent draws from the normalized density f(t,z) / m_a(t)."
      }
    ],
    "parameters": [
      {
        "symbol": "f",
        "name": "phase-space density",
        "description": "The phase-space density f(t, ·) at time t, with total alive mass m_a(t) = ∫_Ω f(t,z) dz",
        "constraints": [
          "f(t, ·) is the phase-space density"
        ],
        "tags": [
          "density",
          "mean-field"
        ]
      },
      {
        "symbol": "t",
        "name": "time",
        "description": "The time parameter at which the density is evaluated",
        "constraints": [],
        "tags": [
          "time",
          "dynamics"
        ]
      },
      {
        "symbol": "m_a(t)",
        "name": "total alive mass",
        "description": "The integral of f over the phase space Ω",
        "constraints": [
          "m_a(t) = ∫_Ω f(t,z) dz > 0"
        ],
        "tags": [
          "mass",
          "normalization"
        ]
      }
    ],
    "examples": [
      {
        "text": "Mean reward μ_R[f](t)",
        "latex": "\\mu_R[f](t) := \\int_{\\Omega} R(z) \\frac{f(t,z)}{m_a(t)}\\,\\mathrm{d}z"
      },
      {
        "text": "Reward variance σ_R²[f](t)",
        "latex": "\\sigma_R^2[f](t) := \\int_{\\Omega} \\bigl(R(z) - \\mu_R[f](t)\\bigr)^2 \\frac{f(t,z)}{m_a(t)}\\,\\mathrm{d}z"
      },
      {
        "text": "Mean distance μ_D[f](t)",
        "latex": "\\mu_D[f](t) := \\iint_{\\Omega \\times \\Omega} d_{\\mathcal{Y}}(\\varphi(z), \\varphi(z')) \\frac{f(t,z)}{m_a(t)} \\frac{f(t,z')}{m_a(t)}\\,\\mathrm{d}z\\,\\mathrm{d}z'"
      },
      {
        "text": "Distance variance σ_D²[f](t)",
        "latex": "\\sigma_D^2[f](t) := \\iint_{\\Omega \\times \\Omega} \\bigl(d_{\\mathcal{Y}}(\\varphi(z), \\varphi(z')) - \\mu_D[f](t)\\bigr)^2 \\frac{f(t,z)}{m_a(t)} \\frac{f(t,z')}{m_a(t)}\\,\\mathrm{d}z\\,\\mathrm{d}z'"
      }
    ],
    "notes": [
      {
        "type": "explanation",
        "text": "These moments emphasize dependence on the shape of f via the notation μ[f], and replace discrete sums over alive walkers in the N-particle system with integrals in the mean-field limit."
      },
      {
        "type": "importance",
        "text": "Normalization by m_a(t) ensures the mean-field model faithfully limits the empirical statistics of the finite N-particle system averaged over k alive walkers."
      }
    ],
    "related_refs": [
      "def-phase-space-density"
    ],
    "tags": [
      "mean-field",
      "statistical-moments",
      "reward-moments",
      "distance-moments",
      "phase-space-density",
      "normalization",
      "alive-mass"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 114,
      "end_line": 140,
      "content_start": 117,
      "content_end": 139,
      "header_lines": [
        115
      ]
    },
    "references": [
      "def-phase-space-density"
    ],
    "metadata": {
      "label": "def-mean-field-moments"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-mean-field-patched-std",
    "type": "definition",
    "title": "Mean-Field Regularized Standard Deviation",
    "term": "Mean-Field Regularized Standard Deviation",
    "object_type": "functional",
    "nl_definition": "Functionals of the density f that apply a regularization to the mean-field variance functionals to produce regularized standard deviations, ensuring numerical stability when variances approach zero.",
    "content_markdown": ":label: def-mean-field-patched-std\n\nThe **Mean-Field Regularized Standard Deviations** are functionals of the density $f$, obtained by applying the `Regularized Standard Deviation` function from the abstract framework (*Chapter 1, Def. 11.1.2*) to the mean-field variance functionals (see {prf:ref}`def-mean-field-moments`):\n\n$$\n\\widehat{\\sigma}_R[f](t) := \\sigma\\'_{\\text{reg}}(\\sigma_R^2[f](t)), \\qquad \\widehat{\\sigma}_D[f](t) := \\sigma\\'_{\\text{reg}}(\\sigma_D^2[f](t))",
    "raw_directive": "174: To ensure the numerical stability and continuity guarantees of the N-particle algorithm are preserved, we must prevent the denominators in the standardization from approaching zero, especially when the swarm is highly converged (i.e., when the true variance $\\sigma^2[f]$ is close to zero). We achieve this by translating the exact same regularized standard deviation mechanism from `Chapter 1` to the mean-field level.\n175: \n176: :::{prf:definition} Mean-Field Regularized Standard Deviation\n177: :label: def-mean-field-patched-std\n178: \n179: The **Mean-Field Regularized Standard Deviations** are functionals of the density $f$, obtained by applying the `Regularized Standard Deviation` function from the abstract framework (*Chapter 1, Def. 11.1.2*) to the mean-field variance functionals (see {prf:ref}`def-mean-field-moments`):\n180: \n181: $$\n182: \\widehat{\\sigma}_R[f](t) := \\sigma\\'_{\\text{reg}}(\\sigma_R^2[f](t)), \\qquad \\widehat{\\sigma}_D[f](t) := \\sigma\\'_{\\text{reg}}(\\sigma_D^2[f](t))\n183: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\widehat{\\sigma}_R[f](t) := \\sigma'_{\\text{reg}}(\\sigma_R^2[f](t)), \\qquad \\widehat{\\sigma}_D[f](t) := \\sigma'_{\\text{reg}}(\\sigma_D^2[f](t))"
      }
    ],
    "properties": [
      {
        "name": "Preserves Stability",
        "description": "Prevents denominators in standardization from approaching zero, especially in highly converged swarms where true variance is near zero."
      },
      {
        "name": "Continuity Guarantee",
        "description": "Translates regularization mechanism from N-particle to mean-field level for consistent continuity properties."
      }
    ],
    "parameters": [
      {
        "symbol": "f",
        "name": "density",
        "description": "Probability density function on which the functionals are defined.",
        "constraints": [
          "f is a density"
        ],
        "tags": [
          "density",
          "mean-field"
        ]
      },
      {
        "symbol": "t",
        "name": "time",
        "description": "Time parameter for the time-dependent functionals.",
        "constraints": [
          "t ≥ 0"
        ],
        "tags": [
          "time",
          "dynamics"
        ]
      },
      {
        "symbol": "\\sigma'_{\\text{reg}}",
        "name": "regularized std function",
        "description": "Regularization function applied to variances to ensure stability.",
        "constraints": [],
        "tags": [
          "regularization",
          "stability"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "motivation",
        "text": "To ensure the numerical stability and continuity guarantees of the N-particle algorithm are preserved when the swarm is highly converged (i.e., when the true variance $\\sigma^2[f]$ is close to zero), this mechanism translates the regularized standard deviation from Chapter 1 to the mean-field level."
      }
    ],
    "related_refs": [
      "def-mean-field-moments"
    ],
    "tags": [
      "mean-field",
      "regularized",
      "standard deviation",
      "variance",
      "numerical stability",
      "continuity",
      "functional"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 174,
      "end_line": 183,
      "content_start": 177,
      "content_end": 182,
      "header_lines": [
        175
      ]
    },
    "references": [
      "def-mean-field-moments"
    ],
    "metadata": {
      "label": "def-mean-field-patched-std"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-mean-field-z-scores",
    "type": "definition",
    "title": "Mean-Field Z-Scores",
    "term": "Mean-Field Z-Scores",
    "object_type": "functions",
    "nl_definition": "The mean-field Z-scores standardize the raw measurements using global, density-dependent moments for a particle at state z and a potential companion at state z_c at time t.",
    "content_markdown": ":label: def-mean-field-z-scores\n\nFor a particle at state $z$ and a potential companion at state $z_c$, the mean-field Z-scores at time $t$ are defined using the density-dependent functionals derived in Section 1.2. The means $\\mu_R[f]$ and $\\mu_D[f]$ are from {prf:ref}`def-mean-field-moments`, and the regularized standard deviations $\\widehat{\\sigma}_R[f]$ and $\\widehat{\\sigma}_D[f]$ are from {prf:ref}`def-mean-field-patched-std`:\n\n$$\n\\widetilde{r}[f](z,t) := \\frac{R(z) - \\mu_R[f](t)}{\\widehat{\\sigma}_R[f](t)}, \\qquad \\widetilde{d}[f](z,z_c,t) := \\frac{d_{\\mathcal{Y}}(\\varphi(z),\\varphi(z_c)) - \\mu_D[f](t)}{\\widehat{\\sigma}_D[f](t)}",
    "raw_directive": "191: We construct this potential in two steps, mirroring the discrete algorithm. First, we define the mean-field Z-scores, which standardize the raw measurements using the global, density-dependent moments. Second, we combine these scores to form the final, non-linear fitness potential.\n192: \n193: :::{prf:definition} Mean-Field Z-Scores\n194: :label: def-mean-field-z-scores\n195: \n196: For a particle at state $z$ and a potential companion at state $z_c$, the mean-field Z-scores at time $t$ are defined using the density-dependent functionals derived in Section 1.2. The means $\\mu_R[f]$ and $\\mu_D[f]$ are from {prf:ref}`def-mean-field-moments`, and the regularized standard deviations $\\widehat{\\sigma}_R[f]$ and $\\widehat{\\sigma}_D[f]$ are from {prf:ref}`def-mean-field-patched-std`:\n197: \n198: $$\n199: \\widetilde{r}[f](z,t) := \\frac{R(z) - \\mu_R[f](t)}{\\widehat{\\sigma}_R[f](t)}, \\qquad \\widetilde{d}[f](z,z_c,t) := \\frac{d_{\\mathcal{Y}}(\\varphi(z),\\varphi(z_c)) - \\mu_D[f](t)}{\\widehat{\\sigma}_D[f](t)}\n200: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "\\widetilde{r}[f](z,t) := \\frac{R(z) - \\mu_R[f](t)}{\\widehat{\\sigma}_R[f](t)}, \\qquad \\widetilde{d}[f](z,z_c,t) := \\frac{d_{\\mathcal{Y}}(\\varphi(z),\\varphi(z_c)) - \\mu_D[f](t)}{\\widehat{\\sigma}_D[f](t)}"
      }
    ],
    "properties": [],
    "parameters": [],
    "examples": [],
    "notes": [],
    "related_refs": [
      "def-mean-field-moments",
      "def-mean-field-patched-std"
    ],
    "tags": [
      "mean-field",
      "z-scores",
      "standardization",
      "density-dependent",
      "fitness-potential",
      "particle-states"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 191,
      "end_line": 200,
      "content_start": 194,
      "content_end": 199,
      "header_lines": [
        192
      ]
    },
    "references": [
      "def-mean-field-moments",
      "def-mean-field-patched-std"
    ],
    "metadata": {
      "label": "def-mean-field-z-scores"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-mean-field-fitness-potential",
    "type": "definition",
    "title": "Mean-Field Fitness Potential",
    "term": "Mean-Field Fitness Potential",
    "object_type": "functional",
    "nl_definition": "A functional of the density f that determines the fitness of a particle at state z relative to a companion at z_c by multiplicatively combining rescaled mean-field Z-scores for diversity and reward, balancing exploitation and exploration.",
    "content_markdown": ":label: def-mean-field-fitness-potential\n\nThe **Mean-Field Fitness Potential**, denoted $V[f](z, z_c, t)$, is a functional of the density $f$ that determines the fitness of a particle at state $z$ relative to a companion at $z_c$. It is constructed by applying the canonical `Rescale Transformation` $g_A$ (*Chapter 1, Sec. 8*) to the mean-field Z-scores (see {prf:ref}`def-mean-field-z-scores`):\n\n$$\nV[f](z,z_c,t) := \\left(g_A(\\widetilde{d}[f](z,z_c,t)) + \\eta\\right)^{\\beta} \\cdot \\left(g_A(\\widetilde{r}[f](z,t)) + \\eta\\right)^{\\alpha}",
    "raw_directive": "204: The final fitness potential combines the contributions from the reward and diversity channels multiplicatively. This structure allows the algorithm to balance the drive for high rewards (exploitation) with the need to maintain diversity (exploration). The potential is a **functional** of the density $f$, denoted $V[f]$, to emphasize that its value at a single point $(z,z_c)$ depends on the global shape of the entire probability distribution.\n205: \n206: :::{prf:definition} Mean-Field Fitness Potential\n207: :label: def-mean-field-fitness-potential\n208: \n209: The **Mean-Field Fitness Potential**, denoted $V[f](z, z_c, t)$, is a functional of the density $f$ that determines the fitness of a particle at state $z$ relative to a companion at $z_c$. It is constructed by applying the canonical `Rescale Transformation` $g_A$ (*Chapter 1, Sec. 8*) to the mean-field Z-scores (see {prf:ref}`def-mean-field-z-scores`):\n210: \n211: $$\n212: V[f](z,z_c,t) := \\left(g_A(\\widetilde{d}[f](z,z_c,t)) + \\eta\\right)^{\\beta} \\cdot \\left(g_A(\\widetilde{r}[f](z,t)) + \\eta\\right)^{\\alpha}\n213: $$",
    "formal_conditions": [
      {
        "type": null,
        "text": "V[f](z,z_c,t) := (g_A(\\widetilde{d}[f](z,z_c,t)) + \\eta)^\\beta \\cdot (g_A(\\widetilde{r}[f](z,t)) + \\eta)^\\alpha",
        "latex": "V[f](z,z_c,t) := \\left(g_A(\\widetilde{d}[f](z,z_c,t)) + \\eta\\right)^{\\beta} \\cdot \\left(g_A(\\widetilde{r}[f](z,t)) + \\eta\\right)^{\\alpha}"
      }
    ],
    "properties": [
      {
        "name": "Multiplicative Combination",
        "description": "Combines contributions from reward and diversity channels multiplicatively to balance exploitation and exploration."
      },
      {
        "name": "Global Dependence",
        "description": "Value at a point (z, z_c) depends on the global shape of the density f."
      },
      {
        "name": "Rescaling",
        "description": "Applies the canonical Rescale Transformation g_A to mean-field Z-scores."
      }
    ],
    "parameters": [
      {
        "symbol": "\\alpha",
        "name": "reward exponent",
        "description": "Exponent applied to the rescaled reward Z-score component.",
        "constraints": [],
        "tags": [
          "exponent",
          "reward"
        ]
      },
      {
        "symbol": "\\beta",
        "name": "diversity exponent",
        "description": "Exponent applied to the rescaled diversity Z-score component.",
        "constraints": [],
        "tags": [
          "exponent",
          "diversity"
        ]
      },
      {
        "symbol": "\\eta",
        "name": "shift parameter",
        "description": "Additive shift to ensure non-negativity in rescaled values.",
        "constraints": [],
        "tags": [
          "shift",
          "non-negativity"
        ]
      },
      {
        "symbol": "f",
        "name": "density",
        "description": "Probability density function over states.",
        "constraints": [],
        "tags": [
          "density",
          "functional"
        ]
      },
      {
        "symbol": "z",
        "name": "particle state",
        "description": "State of the particle.",
        "constraints": [],
        "tags": [
          "state",
          "particle"
        ]
      },
      {
        "symbol": "z_c",
        "name": "companion state",
        "description": "State of the companion particle.",
        "constraints": [],
        "tags": [
          "state",
          "companion"
        ]
      },
      {
        "symbol": "t",
        "name": "time",
        "description": "Time parameter.",
        "constraints": [],
        "tags": [
          "time"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "The final fitness potential combines the contributions from the reward and diversity channels multiplicatively. This structure allows the algorithm to balance the drive for high rewards (exploitation) with the need to maintain diversity (exploration). The potential is a functional of the density f, denoted V[f], to emphasize that its value at a single point (z,z_c) depends on the global shape of the entire probability distribution."
      }
    ],
    "related_refs": [
      "def-mean-field-z-scores"
    ],
    "tags": [
      "mean-field",
      "fitness",
      "potential",
      "functional",
      "density",
      "z-score",
      "exploration",
      "exploitation",
      "multiplicative"
    ],
    "document_id": "07_mean_field",
    "section": "## 1. Foundations of the Mean-Field Model",
    "span": {
      "start_line": 204,
      "end_line": 213,
      "content_start": 207,
      "content_end": 212,
      "header_lines": [
        205
      ]
    },
    "references": [
      "def-mean-field-z-scores"
    ],
    "metadata": {
      "label": "def-mean-field-fitness-potential"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 1,
      "chapter_file": "chapter_1.json",
      "section_id": "## 1. Foundations of the Mean-Field Model"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-baoab-update-rule",
    "type": "definition",
    "title": "The BAOAB Update Rule",
    "term": "BAOAB Update Rule",
    "object_type": "update rule",
    "nl_definition": "A symmetric five-step splitting scheme for updating the position and velocity of a particle in underdamped Langevin dynamics over a time step τ, combining deterministic force kicks, position drifts, and an exact Ornstein-Uhlenbeck solve for friction and noise.",
    "content_markdown": ":label: def-baoab-update-rule\n\nFor a single particle with state $(x_n, v_n)$ at time $t_n$, the state $(x_{n+1}, v_{n+1})$ at time $t_{n+1} = t_n + \\tau$ is computed via the following five steps:\n\n1.  **B-Step (Force Kick):** The velocity is updated with a half-step kick from the conservative force $F(x)$.\n\n    $$\n    v_{n+1/2}^{(1)} = v_n + \\frac{\\tau}{2m} F(x_n)\n    $$\n\n2.  **A-Step (Position Drift):** The position is updated with a half-step drift using the new velocity.\n\n    $$\n    x_{n+1/2} = x_n + \\frac{\\tau}{2} v_{n+1/2}^{(1)}\n    $$\n\n3.  **O-Step (Ornstein-Uhlenbeck):** The velocity is updated for a full timestep by exactly solving the Ornstein-Uhlenbeck process that combines friction and thermal noise. Let $u_{n+1/2} = u(x_{n+1/2})$ be the flow field evaluated at the midpoint.\n\n    $$\n    v_{n+1/2}^{(2)} = u_{n+1/2} + e^{-\\gamma_{\\mathrm{fric}}\\tau}\\left(v_{n+1/2}^{(1)} - u_{n+1/2}\\right) + \\sqrt{\\frac{\\Theta}{m}(1 - e^{-2\\gamma_{\\mathrm{fric}}\\tau})} \\cdot \\xi\n    $$\n    where $\\xi \\sim \\mathcal{N}(0, I_d)$ is a standard Gaussian random vector.\n\n4.  **A-Step (Position Drift):** The position is updated with a final half-step drift.\n\n    $$\n    x_{n+1} = x_{n+1/2} + \\frac{\\tau}{2} v_{n+1/2}^{(2)}\n    $$\n\n5.  **B-Step (Force Kick):** The velocity is updated with a final half-step kick using the force evaluated at the new position, $F(x_{n+1})$.\n\n    $$\n    v_{n+1} = v_{n+1/2}^{(2)} + \\frac{\\tau}{2m} F(x_{n+1})\n    $$",
    "raw_directive": "253: where $W_t$ is a standard Wiener process and all parameters are as defined in the Euclidean Gas specification. The BAOAB method splits this SDE into analytically solvable parts and composes them symmetrically.\n254: \n255: :::{prf:definition} The BAOAB Update Rule\n256: :label: def-baoab-update-rule\n257: \n258: For a single particle with state $(x_n, v_n)$ at time $t_n$, the state $(x_{n+1}, v_{n+1})$ at time $t_{n+1} = t_n + \\tau$ is computed via the following five steps:\n259: \n260: 1.  **B-Step (Force Kick):** The velocity is updated with a half-step kick from the conservative force $F(x)$.\n261: \n262:     $$\n263:     v_{n+1/2}^{(1)} = v_n + \\frac{\\tau}{2m} F(x_n)\n264:     $$\n265: \n266: 2.  **A-Step (Position Drift):** The position is updated with a half-step drift using the new velocity.\n267: \n268:     $$\n269:     x_{n+1/2} = x_n + \\frac{\\tau}{2} v_{n+1/2}^{(1)}\n270:     $$\n271: \n272: 3.  **O-Step (Ornstein-Uhlenbeck):** The velocity is updated for a full timestep by exactly solving the Ornstein-Uhlenbeck process that combines friction and thermal noise. Let $u_{n+1/2} = u(x_{n+1/2})$ be the flow field evaluated at the midpoint.\n273: \n274:     $$\n275:     v_{n+1/2}^{(2)} = u_{n+1/2} + e^{-\\gamma_{\\mathrm{fric}}\\tau}\\left(v_{n+1/2}^{(1)} - u_{n+1/2}\\right) + \\sqrt{\\frac{\\Theta}{m}(1 - e^{-2\\gamma_{\\mathrm{fric}}\\tau})} \\cdot \\xi\n276:     $$\n277:     where $\\xi \\sim \\mathcal{N}(0, I_d)$ is a standard Gaussian random vector.\n278: \n279: 4.  **A-Step (Position Drift):** The position is updated with a final half-step drift.\n280: \n281:     $$\n282:     x_{n+1} = x_{n+1/2} + \\frac{\\tau}{2} v_{n+1/2}^{(2)}\n283:     $$\n284: \n285: 5.  **B-Step (Force Kick):** The velocity is updated with a final half-step kick using the force evaluated at the new position, $F(x_{n+1})$.\n286: \n287:     $$\n288:     v_{n+1} = v_{n+1/2}^{(2)} + \\frac{\\tau}{2m} F(x_{n+1})\n289:     $$\n290: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "B-Step (Force Kick): Velocity updated with half-step kick from conservative force.",
        "latex": "v_{n+1/2}^{(1)} = v_n + \\frac{\\tau}{2m} F(x_n)"
      },
      {
        "type": null,
        "text": "A-Step (Position Drift): Position updated with half-step drift using new velocity.",
        "latex": "x_{n+1/2} = x_n + \\frac{\\tau}{2} v_{n+1/2}^{(1)}"
      },
      {
        "type": null,
        "text": "O-Step (Ornstein-Uhlenbeck): Velocity updated for full timestep solving OU process with flow field u at midpoint, friction, and Gaussian noise.",
        "latex": "v_{n+1/2}^{(2)} = u_{n+1/2} + e^{-\\gamma_{\\mathrm{fric}}\\tau}\\left(v_{n+1/2}^{(1)} - u_{n+1/2}\\right) + \\sqrt{\\frac{\\Theta}{m}(1 - e^{-2\\gamma_{\\mathrm{fric}}\\tau})} \\cdot \\xi \\quad \\xi \\sim \\mathcal{N}(0, I_d)"
      },
      {
        "type": null,
        "text": "A-Step (Position Drift): Position updated with final half-step drift.",
        "latex": "x_{n+1} = x_{n+1/2} + \\frac{\\tau}{2} v_{n+1/2}^{(2)}"
      },
      {
        "type": null,
        "text": "B-Step (Force Kick): Velocity updated with final half-step kick using force at new position.",
        "latex": "v_{n+1} = v_{n+1/2}^{(2)} + \\frac{\\tau}{2m} F(x_{n+1})"
      }
    ],
    "properties": [
      {
        "name": "symmetric-composition",
        "description": "Splits SDE into analytically solvable parts (B, A, O) and composes them symmetrically for improved accuracy and stability."
      },
      {
        "name": "exact-O-step",
        "description": "Exactly solves the Ornstein-Uhlenbeck process for friction and thermal noise over the full timestep."
      }
    ],
    "parameters": [
      {
        "symbol": "\\tau",
        "name": "timestep",
        "description": "Time step size for the update.",
        "constraints": [],
        "tags": [
          "time",
          "step"
        ]
      },
      {
        "symbol": "m",
        "name": "mass",
        "description": "Particle mass.",
        "constraints": [
          "m > 0"
        ],
        "tags": [
          "mass",
          "physical"
        ]
      },
      {
        "symbol": "F",
        "name": "force",
        "description": "Conservative force function F(x).",
        "constraints": [],
        "tags": [
          "force",
          "conservative"
        ]
      },
      {
        "symbol": "\\gamma_{\\mathrm{fric}}",
        "name": "friction-coefficient",
        "description": "Friction coefficient in the Ornstein-Uhlenbeck process.",
        "constraints": [
          "γ_fric ≥ 0"
        ],
        "tags": [
          "friction",
          "damping"
        ]
      },
      {
        "symbol": "\\Theta",
        "name": "thermal-energy",
        "description": "Thermal energy parameter related to temperature.",
        "constraints": [
          "Θ > 0"
        ],
        "tags": [
          "temperature",
          "thermal"
        ]
      },
      {
        "symbol": "\\xi",
        "name": "noise",
        "description": "Standard Gaussian random vector ξ ~ N(0, I_d).",
        "constraints": [],
        "tags": [
          "gaussian",
          "random"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "reference",
        "text": "Applies to the underdamped Langevin SDE driven by a standard Wiener process, with parameters from the Euclidean Gas specification."
      },
      {
        "type": "context",
        "text": "u(x) is the flow field, typically the equilibrium velocity or mean field in the gas model."
      }
    ],
    "related_refs": [],
    "tags": [
      "BAOAB",
      "update-rule",
      "Langevin-dynamics",
      "stochastic",
      "integration",
      "splitting-scheme",
      "underdamped"
    ],
    "document_id": "07_mean_field",
    "section": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)",
    "span": {
      "start_line": 253,
      "end_line": 290,
      "content_start": 256,
      "content_end": 289,
      "header_lines": [
        254
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-baoab-update-rule"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-kinetic-generator",
    "type": "definition",
    "title": "Kinetic Transport Operator",
    "term": "Kinetic Transport Operator",
    "object_type": "Fokker-Planck operator",
    "nl_definition": "The kinetic transport operator is the infinitesimal generator for the underdamped Langevin stochastic differential equations describing the continuous-time evolution of alive walkers in the phase space, approximated discretely by the BAOAB integrator, with reflecting boundary conditions on position and velocity.",
    "content_markdown": ":label: def-kinetic-generator\n\nThe kinetic evolution of a single alive walker $i$ is governed by the underdamped Langevin SDE on the phase space $\\Omega$ (see {prf:ref}`def-mean-field-phase-space`), which is the continuous-time limit of the BAOAB integrator (see {prf:ref}`def-baoab-update-rule`):\n\n$$\n\\mathrm d x_i = v_i\\,\\mathrm dt,\\qquad\n\\mathrm d v_i = \\left(\\frac{1}{m}F(x_i)-\\gamma_{\\mathrm{fric}}(v_i-u(x_i))\\right)\\,\\mathrm dt \\;+\\; \\sigma_v\\,\\mathrm dW_t\n$$\n\nwhere $W_t$ is a standard $d$-dimensional Wiener process and the parameters are those of the Euclidean Gas. This SDE is subject to **reflecting boundary conditions** on both position and velocity:\n\n1.  **Reflecting Position Boundary:** Trajectories reflect at the boundary $\\partial X_{\\text{valid}}$, ensuring no mass leaves the domain through kinetic transport. This models the pure kinetic portion of the dynamics with a simple, local boundary condition.\n2.  **Reflecting Velocity Boundary:** The dynamics are constrained to the velocity ball $V_{\\text{alg}}$. This is modeled by a reflecting or squash boundary condition at $\\|v\\|=V_{\\text{alg}}$ that mirrors the action of the velocity cap $\\psi_v$.\n\nThe infinitesimal generator for the N-particle system under this collection of independent SDEs is the **Fokker-Planck operator**, which acts on a test function $f$ on the swarm state space. For the set of alive walkers $\\mathcal{A}$, it is given by:\n\n$$\n\\boxed{\n\\mathcal{L}_{\\text{kin}} f = \\sum_{i\\in\\mathcal A}\\left[ v_i\\cdot\\nabla_{x_i} f + \\left(m^{-1}F(x_i)-\\gamma_{\\mathrm{fric}}(v_i-u(x_i))\\right)\\cdot\\nabla_{v_i} f + \\tfrac{\\sigma_v^2}{2}\\,\\Delta_{v_i} f\\right]\n}\n$$",
    "raw_directive": "309: Between cloning events and death/revival transitions, the state of each alive walker evolves according to a continuous stochastic process. The kinetic stage of the Euclidean Gas algorithm, as defined by the BAOAB integrator, is a discrete-time approximation of a specific underdamped Langevin stochastic differential equation (SDE). This SDE governs the diffusive part of the generator.\n310: \n311: :::{prf:definition} Kinetic Transport Operator\n312: :label: def-kinetic-generator\n313: \n314: The kinetic evolution of a single alive walker $i$ is governed by the underdamped Langevin SDE on the phase space $\\Omega$ (see {prf:ref}`def-mean-field-phase-space`), which is the continuous-time limit of the BAOAB integrator (see {prf:ref}`def-baoab-update-rule`):\n315: \n316: $$\n317: \\mathrm d x_i = v_i\\,\\mathrm dt,\\qquad\n318: \\mathrm d v_i = \\left(\\frac{1}{m}F(x_i)-\\gamma_{\\mathrm{fric}}(v_i-u(x_i))\\right)\\,\\mathrm dt \\;+\\; \\sigma_v\\,\\mathrm dW_t\n319: $$\n320: \n321: where $W_t$ is a standard $d$-dimensional Wiener process and the parameters are those of the Euclidean Gas. This SDE is subject to **reflecting boundary conditions** on both position and velocity:\n322: \n323: 1.  **Reflecting Position Boundary:** Trajectories reflect at the boundary $\\partial X_{\\text{valid}}$, ensuring no mass leaves the domain through kinetic transport. This models the pure kinetic portion of the dynamics with a simple, local boundary condition.\n324: 2.  **Reflecting Velocity Boundary:** The dynamics are constrained to the velocity ball $V_{\\text{alg}}$. This is modeled by a reflecting or squash boundary condition at $\\|v\\|=V_{\\text{alg}}$ that mirrors the action of the velocity cap $\\psi_v$.\n325: \n326: The infinitesimal generator for the N-particle system under this collection of independent SDEs is the **Fokker-Planck operator**, which acts on a test function $f$ on the swarm state space. For the set of alive walkers $\\mathcal{A}$, it is given by:\n327: \n328: $$\n329: \\boxed{\n330: \\mathcal{L}_{\\text{kin}} f = \\sum_{i\\in\\mathcal A}\\left[ v_i\\cdot\\nabla_{x_i} f + \\left(m^{-1}F(x_i)-\\gamma_{\\mathrm{fric}}(v_i-u(x_i))\\right)\\cdot\\nabla_{v_i} f + \\tfrac{\\sigma_v^2}{2}\\,\\Delta_{v_i} f\\right]\n331: }\n332: $$\n333: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "The SDE for position and velocity: dx_i = v_i dt, dv_i = (1/m F(x_i) - γ_fric (v_i - u(x_i))) dt + σ_v dW_t, where W_t is a standard d-dimensional Wiener process.",
        "latex": "\\mathrm d x_i = v_i\\,\\mathrm dt,\\qquad \\mathrm d v_i = \\left(\\frac{1}{m}F(x_i)-\\gamma_{\\mathrm{fric}}(v_i-u(x_i))\\right)\\,\\mathrm dt \\;+\\; \\sigma_v\\,\\mathrm dW_t"
      },
      {
        "type": null,
        "text": "Reflecting Position Boundary: Trajectories reflect at the boundary ∂X_valid, ensuring no mass leaves the domain through kinetic transport.",
        "latex": null
      },
      {
        "type": null,
        "text": "Reflecting Velocity Boundary: The dynamics are constrained to the velocity ball V_alg, modeled by a reflecting or squash boundary condition at ||v|| = V_alg mirroring the velocity cap ψ_v.",
        "latex": null
      }
    ],
    "properties": [
      {
        "name": "Infinitesimal generator",
        "description": "Acts on test functions f on the swarm state space as the Fokker-Planck operator for the N-particle system of independent SDEs over alive walkers A."
      },
      {
        "name": "Domain",
        "description": "Phase space Ω with reflecting boundaries on position (∂X_valid) and velocity (V_alg)."
      },
      {
        "name": "Form",
        "description": "Sum over i in A of [v_i · ∇_{x_i} f + (m^{-1} F(x_i) - γ_fric (v_i - u(x_i))) · ∇_{v_i} f + (σ_v^2 / 2) Δ_{v_i} f]."
      }
    ],
    "parameters": [
      {
        "symbol": "m",
        "name": "mass",
        "description": "Particle mass",
        "constraints": [],
        "tags": [
          "physical"
        ]
      },
      {
        "symbol": "\\gamma_{\\mathrm{fric}}",
        "name": "friction coefficient",
        "description": "Friction coefficient in the velocity update",
        "constraints": [],
        "tags": [
          "physical"
        ]
      },
      {
        "symbol": "u",
        "name": "target velocity",
        "description": "Target velocity function u(x_i)",
        "constraints": [],
        "tags": [
          "function"
        ]
      },
      {
        "symbol": "\\sigma_v",
        "name": "velocity noise",
        "description": "Standard deviation of the velocity noise",
        "constraints": [],
        "tags": [
          "stochastic"
        ]
      },
      {
        "symbol": "V_{\\text{alg}}",
        "name": "algorithmic velocity cap",
        "description": "Maximum velocity norm for the velocity ball",
        "constraints": [],
        "tags": [
          "boundary"
        ]
      },
      {
        "symbol": "F",
        "name": "force",
        "description": "Force function F(x_i)",
        "constraints": [],
        "tags": [
          "function"
        ]
      },
      {
        "symbol": "W_t",
        "name": "Wiener process",
        "description": "Standard d-dimensional Wiener process",
        "constraints": [],
        "tags": [
          "stochastic"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "continuous limit",
        "text": "This SDE is the continuous-time limit of the BAOAB integrator."
      },
      {
        "type": "applicability",
        "text": "Applies between cloning events and death/revival transitions for alive walkers."
      },
      {
        "type": "boundary modeling",
        "text": "Position reflection ensures mass conservation; velocity reflection mimics the cap ψ_v."
      }
    ],
    "related_refs": [
      "def-mean-field-phase-space",
      "def-baoab-update-rule"
    ],
    "tags": [
      "kinetic",
      "transport",
      "operator",
      "Langevin",
      "SDE",
      "Fokker-Planck",
      "underdamped",
      "boundary conditions"
    ],
    "document_id": "07_mean_field",
    "section": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)",
    "span": {
      "start_line": 309,
      "end_line": 333,
      "content_start": 312,
      "content_end": 332,
      "header_lines": [
        310
      ]
    },
    "references": [
      "def-mean-field-phase-space",
      "def-baoab-update-rule"
    ],
    "metadata": {
      "label": "def-kinetic-generator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-killing-operator",
    "type": "definition",
    "title": "Interior Killing Operator",
    "term": "Interior Killing Operator",
    "object_type": "operator",
    "nl_definition": "The interior killing operator models death by removing mass from the alive density f at a position- and velocity-dependent rate c(z) f(z), where c is a smooth non-negative function that vanishes in safe interior regions and is positive near invalid boundaries, ensuring PDE regularity.",
    "content_markdown": ":label: def-killing-operator\n\nDeath is modeled by an **interior killing rate** $c: \\Omega \\to [0, \\infty)$, a smooth, non-negative function with the following properties:\n\n1.  **Safety in the interior**: $c(z) = 0$ for all $z$ in a safe subset of $\\Omega$ away from the position boundary.\n2.  **Activity near the boundary**: $c(z) > 0$ in a smooth transition layer near $\\partial X_{\\text{valid}} \\times V_{\\text{alg}}$.\n3.  **Smoothness**: $c \\in C^\\infty(\\Omega)$ to ensure regularity of the PDE solutions.\n\nThe killing operator removes mass from the alive density $f$ at a rate $c(z)f(z)$. The **total mass killed per unit time** is a functional of $f$:\n\n$$\nk_{\\text{killed}}[f](t) := \\int_{\\Omega} c(z) f(t,z) \\, \\mathrm{d}z\n$$",
    "raw_directive": "358: :::\n359: \n360: :::{prf:definition} Interior Killing Operator\n361: :label: def-killing-operator\n362: \n363: Death is modeled by an **interior killing rate** $c: \\Omega \\to [0, \\infty)$, a smooth, non-negative function with the following properties:\n364: \n365: 1.  **Safety in the interior**: $c(z) = 0$ for all $z$ in a safe subset of $\\Omega$ away from the position boundary.\n366: 2.  **Activity near the boundary**: $c(z) > 0$ in a smooth transition layer near $\\partial X_{\\text{valid}} \\times V_{\\text{alg}}$.\n367: 3.  **Smoothness**: $c \\in C^\\infty(\\Omega)$ to ensure regularity of the PDE solutions.\n368: \n369: The killing operator removes mass from the alive density $f$ at a rate $c(z)f(z)$. The **total mass killed per unit time** is a functional of $f$:\n370: \n371: $$\n372: k_{\\text{killed}}[f](t) := \\int_{\\Omega} c(z) f(t,z) \\, \\mathrm{d}z\n373: $$\n374: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "c: Ω → [0, ∞), smooth and non-negative.",
        "latex": "c: \\Omega \\to [0, \\infty), \\text{smooth, non-negative}"
      },
      {
        "type": null,
        "text": "Safety in the interior: c(z) = 0 for all z in a safe subset of Ω away from the position boundary.",
        "latex": "c(z) = 0 \\, \\forall z \\in \\text{safe subset of } \\Omega \\text{ away from position boundary}"
      },
      {
        "type": null,
        "text": "Activity near the boundary: c(z) > 0 in a smooth transition layer near ∂X_valid × V_alg.",
        "latex": "c(z) > 0 \\text{ in smooth transition layer near } \\partial X_{\\text{valid}} \\times V_{\\text{alg}}"
      },
      {
        "type": null,
        "text": "Smoothness: c ∈ C^∞(Ω) to ensure regularity of the PDE solutions.",
        "latex": "c \\in C^\\infty(\\Omega) \\text{ to ensure PDE regularity}"
      }
    ],
    "properties": [
      {
        "name": "Killing Mechanism",
        "description": "Removes mass from the alive density f at the rate c(z) f(z)."
      },
      {
        "name": "Total Mass Killed Functional",
        "description": "k_killed[f](t) := ∫_Ω c(z) f(t,z) dz, representing the total mass killed per unit time."
      },
      {
        "name": "Boundary Behavior",
        "description": "c is zero in safe interiors and positive near invalid boundaries to model risk."
      }
    ],
    "parameters": [
      {
        "symbol": "c",
        "name": "interior killing rate",
        "description": "A smooth, non-negative function mapping the domain to non-negative reals, modeling the killing rate.",
        "constraints": [
          "c: Ω → [0, ∞)",
          "c(z) = 0 for all z in a safe subset of Ω away from the position boundary",
          "c(z) > 0 in a smooth transition layer near ∂X_valid × V_alg",
          "c ∈ C^∞(Ω)"
        ],
        "tags": [
          "killing-rate",
          "smooth",
          "non-negative"
        ]
      },
      {
        "symbol": "f",
        "name": "alive density",
        "description": "The density function of alive agents at time t and state z.",
        "constraints": [],
        "tags": [
          "density",
          "alive",
          "functional-input"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "note",
        "text": "The smoothness of c ensures the regularity of solutions to the associated partial differential equations (PDEs) modeling the system."
      },
      {
        "type": "note",
        "text": "This operator is used to enforce safety by penalizing states near invalid boundaries without abrupt killing."
      }
    ],
    "related_refs": [],
    "tags": [
      "killing-operator",
      "interior-rate",
      "smooth-function",
      "boundary-layer",
      "pde-regularity",
      "mass-removal",
      "death-modeling"
    ],
    "document_id": "07_mean_field",
    "section": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)",
    "span": {
      "start_line": 358,
      "end_line": 374,
      "content_start": 361,
      "content_end": 373,
      "header_lines": [
        359
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-killing-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-revival-operator",
    "type": "definition",
    "title": "Revival Operator",
    "term": "Revival Operator",
    "object_type": "operator",
    "nl_definition": "A source term that re-injects mass from the dead population back into the alive population, with the spatial profile proportional to the current alive density, at a rate proportional to the dead mass.",
    "content_markdown": ":label: def-revival-operator\n\nRevival is modeled as a source term that re-injects mass from the dead population back into the alive population. The dead population acts as a reservoir from which revival occurs at a constant rate. The mass killed by the killing operator (see {prf:ref}`def-killing-operator`) flows into this dead reservoir. Dead walkers are instantly revived by cloning from alive companions, so the spatial profile of the re-injected mass is simply **proportional to the current alive density**, mirroring the discrete algorithm's revival mechanism.\n\nThe **Revival Operator** is defined as:\n\n$$\nB[f, m_d](t, z) := \\lambda_{\\text{revive}} \\cdot m_d(t) \\cdot \\frac{f(t,z)}{m_a(t)}\n$$\n\nwhere:\n*   $\\lambda_{\\text{revive}} > 0$ is the **revival rate**, a free parameter independent of the timestep (typical values: 0.1-5)\n*   $m_d(t) = 1 - m_a(t)$ is the current dead mass\n*   $f(t,z)/m_a(t)$ is the **normalized alive density** (the probability distribution over the alive population)\n\nThis form directly translates the discrete algorithm: dead walkers select companions uniformly from the alive set and clone to their positions.\n\n**Key property**: The total mass revived per unit time is:\n\n$$\n\\int_{\\Omega} B[f, m_d](t,z)\\,\\mathrm{d}z = \\lambda_{\\text{revive}} \\cdot m_d(t)\n$$",
    "raw_directive": "376: :::\n377: \n378: :::{prf:definition} Revival Operator\n379: :label: def-revival-operator\n380: \n381: Revival is modeled as a source term that re-injects mass from the dead population back into the alive population. The dead population acts as a reservoir from which revival occurs at a constant rate. The mass killed by the killing operator (see {prf:ref}`def-killing-operator`) flows into this dead reservoir. Dead walkers are instantly revived by cloning from alive companions, so the spatial profile of the re-injected mass is simply **proportional to the current alive density**, mirroring the discrete algorithm's revival mechanism.\n382: \n383: The **Revival Operator** is defined as:\n384: \n385: $$\n386: B[f, m_d](t, z) := \\lambda_{\\text{revive}} \\cdot m_d(t) \\cdot \\frac{f(t,z)}{m_a(t)}\n387: $$\n388: \n389: where:\n390: *   $\\lambda_{\\text{revive}} > 0$ is the **revival rate**, a free parameter independent of the timestep (typical values: 0.1-5)\n391: *   $m_d(t) = 1 - m_a(t)$ is the current dead mass\n392: *   $f(t,z)/m_a(t)$ is the **normalized alive density** (the probability distribution over the alive population)\n393: \n394: This form directly translates the discrete algorithm: dead walkers select companions uniformly from the alive set and clone to their positions.\n395: \n396: **Key property**: The total mass revived per unit time is:\n397: \n398: $$\n399: \\int_{\\Omega} B[f, m_d](t,z)\\,\\mathrm{d}z = \\lambda_{\\text{revive}} \\cdot m_d(t)\n400: $$\n401: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "B[f, m_d](t, z) := λ_revive · m_d(t) · f(t,z)/m_a(t)",
        "latex": "B[f, m_d](t, z) := \\lambda_{\\text{revive}} \\cdot m_d(t) \\cdot \\frac{f(t,z)}{m_a(t)}"
      },
      {
        "type": null,
        "text": "where m_d(t) = 1 - m_a(t)",
        "latex": "m_d(t) = 1 - m_a(t)"
      },
      {
        "type": null,
        "text": "and f(t,z)/m_a(t) is the normalized alive density",
        "latex": "\\frac{f(t,z)}{m_a(t)} is the normalized alive density"
      }
    ],
    "properties": [
      {
        "name": "Total mass revived per unit time",
        "description": "The integral over the domain Ω of B[f, m_d](t,z) dz equals λ_revive · m_d(t)"
      }
    ],
    "parameters": [
      {
        "symbol": "λ_revive",
        "name": "revival rate",
        "description": "a free parameter independent of the timestep (typical values: 0.1-5)",
        "constraints": [
          "> 0"
        ],
        "tags": [
          "rate",
          "revival",
          "parameter"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "explanation",
        "text": "Models revival by cloning dead walkers from alive companions, mirroring the discrete algorithm where dead walkers select companions uniformly from the alive set and clone to their positions."
      },
      {
        "type": "context",
        "text": "The mass killed by the killing operator flows into the dead reservoir, which acts as a source for revival."
      }
    ],
    "related_refs": [
      "def-killing-operator"
    ],
    "tags": [
      "revival",
      "operator",
      "source term",
      "mass injection",
      "dead reservoir",
      "alive density",
      "cloning mechanism"
    ],
    "document_id": "07_mean_field",
    "section": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)",
    "span": {
      "start_line": 376,
      "end_line": 401,
      "content_start": 379,
      "content_end": 400,
      "header_lines": [
        377
      ]
    },
    "references": [
      "def-killing-operator"
    ],
    "metadata": {
      "label": "def-revival-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-cloning-generator",
    "type": "definition",
    "title": "Internal Cloning Operator (Derived Form)",
    "term": "Internal Cloning Operator",
    "object_type": "operator",
    "nl_definition": "The Internal Cloning Operator S[f] is the mean-field limit of a discrete cloning mechanism in population dynamics, acting as a mass-neutral, non-local operator that decomposes into sink and source terms to redistribute mass within the alive population, distinct from revival processes.",
    "content_markdown": ":label: def-cloning-generator\n\nThe **Internal Cloning Operator**, $S[f]$, is the mean-field limit of the discrete cloning mechanism. It is distinct from the revival operator (see {prf:ref}`def-revival-operator`), which handles dead-to-alive transitions, while this operator redistributes mass within the alive population. It is a mass-neutral, non-local operator that decomposes into sink and source terms:\n\n$$\nS[f](t, z) = S_{\\text{src}}[f](t, z) - S_{\\text{sink}}[f](t, z)\n$$\n\nwhere:\n\n*   **Sink** (mass removed when walkers at $z$ clone away):\n\n    $$\n    S_{\\text{sink}}[f](t,z) = \\frac{1}{\\tau} f(t,z) \\int_{\\Omega} P_{\\text{clone}}[f/m_a](z, z_c) \\frac{f(t,z_c)}{m_a(t)} \\,\\mathrm{d}z_c\n    $$\n\n*   **Source** (mass gained when walkers from other states clone to $z$):\n\n    $$\n    S_{\\text{src}}[f](t,z) = \\frac{1}{\\tau m_a(t)} \\int_{\\Omega} \\int_{\\Omega} f(t,z_d) f(t,z_c) P_{\\text{clone}}[f/m_a](z_d, z_c) Q_{\\delta}(z \\mid z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c\n    $$\n\nHere:\n- $P_{\\text{clone}}[f/m_a](z_d, z_c)$ is the cloning probability depending on fitness values (see {prf:ref}`def-mean-field-fitness-potential`) computed from the normalized alive density $f/m_a$\n- $Q_\\delta(z \\mid z_c)$ is the jitter kernel (Gaussian in position, delta in velocity)\n- $\\tau$ is the discrete timestep, and $1/\\tau$ converts per-step probabilities to continuous rates\n\n**Key property**: The operator is mass-neutral by construction. To verify, integrate over $\\Omega$:\n\n$$\n\\begin{aligned}\n\\int_{\\Omega} S[f](t,z)\\,\\mathrm{d}z &= \\int_{\\Omega} S_{\\text{src}}[f](t,z)\\,\\mathrm{d}z - \\int_{\\Omega} S_{\\text{sink}}[f](t,z)\\,\\mathrm{d}z \\\\\n&= \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) Q_\\delta(z \\mid z_c) \\,\\mathrm{d}z\\,\\mathrm{d}z_d\\,\\mathrm{d}z_c \\\\\n&\\quad - \\frac{1}{\\tau} \\int_{\\Omega} f(z) \\int_{\\Omega} P(z, z_c) \\frac{f(z_c)}{m_a} \\,\\mathrm{d}z_c\\,\\mathrm{d}z\n\\end{aligned}\n$$\n\nUsing $\\int_\\Omega Q_\\delta(z \\mid z_c)\\,\\mathrm{d}z = 1$:\n\n$$\n= \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c - \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c = 0\n$$",
    "raw_directive": "495: This is exactly the form of the cloning operator stated below.\n496: \n497: :::{prf:definition} Internal Cloning Operator (Derived Form)\n498: :label: def-cloning-generator\n499: \n500: The **Internal Cloning Operator**, $S[f]$, is the mean-field limit of the discrete cloning mechanism. It is distinct from the revival operator (see {prf:ref}`def-revival-operator`), which handles dead-to-alive transitions, while this operator redistributes mass within the alive population. It is a mass-neutral, non-local operator that decomposes into sink and source terms:\n501: \n502: $$\n503: S[f](t, z) = S_{\\text{src}}[f](t, z) - S_{\\text{sink}}[f](t, z)\n504: $$\n505: \n506: where:\n507: \n508: *   **Sink** (mass removed when walkers at $z$ clone away):\n509: \n510:     $$\n511:     S_{\\text{sink}}[f](t,z) = \\frac{1}{\\tau} f(t,z) \\int_{\\Omega} P_{\\text{clone}}[f/m_a](z, z_c) \\frac{f(t,z_c)}{m_a(t)} \\,\\mathrm{d}z_c\n512:     $$\n513: \n514: *   **Source** (mass gained when walkers from other states clone to $z$):\n515: \n516:     $$\n517:     S_{\\text{src}}[f](t,z) = \\frac{1}{\\tau m_a(t)} \\int_{\\Omega} \\int_{\\Omega} f(t,z_d) f(t,z_c) P_{\\text{clone}}[f/m_a](z_d, z_c) Q_{\\delta}(z \\mid z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c\n518:     $$\n519: \n520: Here:\n521: - $P_{\\text{clone}}[f/m_a](z_d, z_c)$ is the cloning probability depending on fitness values (see {prf:ref}`def-mean-field-fitness-potential`) computed from the normalized alive density $f/m_a$\n522: - $Q_\\delta(z \\mid z_c)$ is the jitter kernel (Gaussian in position, delta in velocity)\n523: - $\\tau$ is the discrete timestep, and $1/\\tau$ converts per-step probabilities to continuous rates\n524: \n525: **Key property**: The operator is mass-neutral by construction. To verify, integrate over $\\Omega$:\n526: \n527: $$\n528: \\begin{aligned}\n529: \\int_{\\Omega} S[f](t,z)\\,\\mathrm{d}z &= \\int_{\\Omega} S_{\\text{src}}[f](t,z)\\,\\mathrm{d}z - \\int_{\\Omega} S_{\\text{sink}}[f](t,z)\\,\\mathrm{d}z \\\\\n530: &= \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) Q_\\delta(z \\mid z_c) \\,\\mathrm{d}z\\,\\mathrm{d}z_d\\,\\mathrm{d}z_c \\\\\n531: &\\quad - \\frac{1}{\\tau} \\int_{\\Omega} f(z) \\int_{\\Omega} P(z, z_c) \\frac{f(z_c)}{m_a} \\,\\mathrm{d}z_c\\,\\mathrm{d}z\n532: \\end{aligned}\n533: $$\n534: \n535: Using $\\int_\\Omega Q_\\delta(z \\mid z_c)\\,\\mathrm{d}z = 1$:\n536: \n537: $$\n538: = \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c - \\frac{1}{\\tau m_a} \\int_{\\Omega} \\int_{\\Omega} f(z_d) f(z_c) P(z_d, z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c = 0\n539: $$\n540: ",
    "formal_conditions": [
      {
        "type": null,
        "text": null,
        "latex": "S[f](t, z) = S_{\\text{src}}[f](t, z) - S_{\\text{sink}}[f](t, z)"
      },
      {
        "type": null,
        "text": null,
        "latex": "S_{\\text{sink}}[f](t,z) = \\frac{1}{\\tau} f(t,z) \\int_{\\Omega} P_{\\text{clone}}[f/m_a](z, z_c) \\frac{f(t,z_c)}{m_a(t)} \\,\\mathrm{d}z_c"
      },
      {
        "type": null,
        "text": null,
        "latex": "S_{\\text{src}}[f](t,z) = \\frac{1}{\\tau m_a(t)} \\int_{\\Omega} \\int_{\\Omega} f(t,z_d) f(t,z_c) P_{\\text{clone}}[f/m_a](z_d, z_c) Q_{\\delta}(z \\mid z_c) \\,\\mathrm{d}z_d\\,\\mathrm{d}z_c"
      }
    ],
    "properties": [
      {
        "name": "mass-neutral",
        "description": "\\int_\\Omega S[f](t,z) \\,dz = 0 by construction, as source and sink integrals cancel."
      },
      {
        "name": "non-local",
        "description": "Involves integrals over the entire domain \\Omega, coupling distant states via cloning probabilities."
      },
      {
        "name": "distinct from revival",
        "description": "Redistributes mass only within the alive population, unlike revival operators that transition from dead to alive states."
      }
    ],
    "parameters": [
      {
        "symbol": "f",
        "name": "density",
        "description": "Alive population density function f(t,z)",
        "constraints": [
          "f \\geq 0"
        ],
        "tags": [
          "density"
        ]
      },
      {
        "symbol": "\\tau",
        "name": "timestep",
        "description": "Discrete timestep for rate conversion",
        "constraints": [
          "\\tau > 0"
        ],
        "tags": [
          "time"
        ]
      },
      {
        "symbol": "m_a",
        "name": "alive mass",
        "description": "Total mass of alive population m_a(t) = \\int_\\Omega f(t,z) \\,dz",
        "constraints": [
          "m_a > 0"
        ],
        "tags": [
          "mass"
        ]
      },
      {
        "symbol": "P_{\\text{clone}}",
        "name": "cloning probability",
        "description": "Cloning probability depending on normalized density fitness P_{\\text{clone}}[f/m_a](z_d, z_c)",
        "constraints": [
          "0 \\leq P \\leq 1"
        ],
        "tags": [
          "probability",
          "fitness"
        ]
      },
      {
        "symbol": "Q_\\delta",
        "name": "jitter kernel",
        "description": "Displacement kernel for cloning, Gaussian in position and delta in velocity",
        "constraints": [
          "\\int_\\Omega Q_\\delta(z | z_c) \\,dz = 1"
        ],
        "tags": [
          "kernel"
        ]
      },
      {
        "symbol": "\\Omega",
        "name": "domain",
        "description": "Spatial domain of the system",
        "constraints": [],
        "tags": [
          "domain"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "background",
        "text": "Derived as the continuous-time rate limit (1/\\tau) of discrete per-step cloning probabilities."
      },
      {
        "type": "verification",
        "text": "Mass neutrality proven by substituting the integral of Q_\\delta = 1 and relabeling variables in the source-sink balance, yielding identical double integrals that subtract to zero."
      }
    ],
    "related_refs": [
      "def-revival-operator",
      "def-mean-field-fitness-potential"
    ],
    "tags": [
      "cloning",
      "operator",
      "mean-field",
      "mass-neutral",
      "non-local",
      "source-sink",
      "fitness"
    ],
    "document_id": "07_mean_field",
    "section": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)",
    "span": {
      "start_line": 495,
      "end_line": 540,
      "content_start": 498,
      "content_end": 539,
      "header_lines": [
        496
      ]
    },
    "references": [
      "def-revival-operator",
      "def-mean-field-fitness-potential"
    ],
    "metadata": {
      "label": "def-cloning-generator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 2,
      "chapter_file": "chapter_2.json",
      "section_id": "## 2. The Continuous Forward Generator ($\\mathcal{L}_{\\text{FG}}$)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  },
  {
    "label": "def-transport-operator",
    "type": "definition",
    "title": "Transport Operator and Probability Flux",
    "term": "Transport Operator",
    "object_type": "operator",
    "nl_definition": "The transport operator \\(L^\\dagger\\) is the formal \\(L^2\\)-adjoint of the backward kinetic generator \\(L\\), acting on a probability density \\(f\\) in conservative form as the negative divergence of a probability flux vector \\(J[f] = (J_x[f], J_v[f])\\), where the flux components incorporate advection/drift and Fickian diffusion terms.",
    "content_markdown": ":label: def-transport-operator\n\nLet $L$ be the backward kinetic generator from Section 2.2. The **Transport Operator**, denoted $L^\\dagger$, is its formal $L^2$-adjoint, which acts on the density $f$. It can be written in conservative form as the negative divergence of a **probability flux vector** $J = (J_x, J_v)$:\n\n$$\nL^\\dagger f = -\\nabla \\cdot J[f] = -\\nabla_x \\cdot J_x[f] - \\nabla_v \\cdot J_v[f]\n$$\n\nwhere the components of the flux are:\n*   **Positional Flux ($J_x$):** $J_x[f] := v f - D_x \\nabla_x f$ (Advection + Fickian Diffusion)\n*   **Velocity Flux ($J_v$):** $J_v[f] := A_v f - D_v \\nabla_v f$ (Drift + Fickian Diffusion)",
    "raw_directive": "552: The kinetic part of the evolution, described by the generator $\\mathcal{L}_{\\text{kin}}$ (see {prf:ref}`def-kinetic-generator`), corresponds to a local transport of probability density via drift and diffusion. Its representation in the forward equation is given by the formal adjoint of $\\mathcal{L}_{\\text{kin}}$, which is the Fokker-Planck operator.\n553: \n554: :::{prf:definition} Transport Operator and Probability Flux\n555: :label: def-transport-operator\n556: \n557: Let $L$ be the backward kinetic generator from Section 2.2. The **Transport Operator**, denoted $L^\\dagger$, is its formal $L^2$-adjoint, which acts on the density $f$. It can be written in conservative form as the negative divergence of a **probability flux vector** $J = (J_x, J_v)$:\n558: \n559: $$\n560: L^\\dagger f = -\\nabla \\cdot J[f] = -\\nabla_x \\cdot J_x[f] - \\nabla_v \\cdot J_v[f]\n561: $$\n562: \n563: where the components of the flux are:\n564: *   **Positional Flux ($J_x$):** $J_x[f] := v f - D_x \\nabla_x f$ (Advection + Fickian Diffusion)\n565: *   **Velocity Flux ($J_v$):** $J_v[f] := A_v f - D_v \\nabla_v f$ (Drift + Fickian Diffusion)\n566: ",
    "formal_conditions": [
      {
        "type": null,
        "text": "L^\\dagger is the formal L^2-adjoint of L",
        "latex": "L^\\dagger \\text{ is the formal } L^2 \\text{-adjoint of } L"
      },
      {
        "type": null,
        "text": "L^\\dagger f = -\\nabla \\cdot J[f] = -\\nabla_x \\cdot J_x[f] - \\nabla_v \\cdot J_v[f]",
        "latex": "L^\\dagger f = -\\nabla \\cdot J[f] = -\\nabla_x \\cdot J_x[f] - \\nabla_v \\cdot J_v[f]"
      },
      {
        "type": null,
        "text": "J_x[f] := v f - D_x \\nabla_x f (Advection + Fickian Diffusion)",
        "latex": "J_x[f] := v f - D_x \\nabla_x f"
      },
      {
        "type": null,
        "text": "J_v[f] := A_v f - D_v \\nabla_v f (Drift + Fickian Diffusion)",
        "latex": "J_v[f] := A_v f - D_v \\nabla_v f"
      }
    ],
    "properties": [
      {
        "name": "Adjoint Property",
        "description": "L^\\dagger is the formal L^2-adjoint of the backward kinetic generator L"
      },
      {
        "name": "Conservative Form",
        "description": "Expressed as the negative divergence of the probability flux vector J[f]"
      },
      {
        "name": "Positional Flux Component",
        "description": "J_x[f] combines velocity-driven advection v f with positional Fickian diffusion -D_x \\nabla_x f"
      },
      {
        "name": "Velocity Flux Component",
        "description": "J_v[f] combines velocity drift A_v f with velocity Fickian diffusion -D_v \\nabla_v f"
      }
    ],
    "parameters": [
      {
        "symbol": "L",
        "name": "backward kinetic generator",
        "description": "The infinitesimal generator of the kinetic process acting on test functions, as defined in Section 2.2.",
        "constraints": [],
        "tags": [
          "kinetic",
          "backward"
        ]
      },
      {
        "symbol": "f",
        "name": "probability density",
        "description": "The density function on which the transport operator acts.",
        "constraints": [],
        "tags": [
          "density",
          "probability"
        ]
      },
      {
        "symbol": "v",
        "name": "velocity",
        "description": "The velocity variable or field contributing to advection in position.",
        "constraints": [],
        "tags": [
          "velocity",
          "advection"
        ]
      },
      {
        "symbol": "D_x",
        "name": "positional diffusion coefficient",
        "description": "The diffusion operator or tensor in the position variable.",
        "constraints": [],
        "tags": [
          "diffusion",
          "position"
        ]
      },
      {
        "symbol": "A_v",
        "name": "velocity drift",
        "description": "The drift term acting in the velocity variable.",
        "constraints": [],
        "tags": [
          "drift",
          "velocity"
        ]
      },
      {
        "symbol": "D_v",
        "name": "velocity diffusion coefficient",
        "description": "The diffusion operator or tensor in the velocity variable.",
        "constraints": [],
        "tags": [
          "diffusion",
          "velocity"
        ]
      }
    ],
    "examples": [],
    "notes": [
      {
        "type": "context",
        "text": "This operator corresponds to the kinetic part of the evolution via the generator L_{kin}, representing local transport of probability density through drift and diffusion in the forward (Fokker-Planck) equation."
      },
      {
        "type": "reference",
        "text": "The backward kinetic generator L is defined in Section 2.2 (see def-kinetic-generator)."
      }
    ],
    "related_refs": [
      "def-kinetic-generator"
    ],
    "tags": [
      "transport-operator",
      "probability-flux",
      "adjoint-operator",
      "fokker-planck",
      "drift-diffusion",
      "kinetic-theory",
      "advection",
      "conservative-form"
    ],
    "document_id": "07_mean_field",
    "section": "## 3. The Mass-Conserving Forward Equation (PDE)",
    "span": {
      "start_line": 552,
      "end_line": 566,
      "content_start": 555,
      "content_end": 565,
      "header_lines": [
        553
      ]
    },
    "references": [],
    "metadata": {
      "label": "def-transport-operator"
    },
    "registry_context": {
      "stage": "directives",
      "document_id": "07_mean_field",
      "chapter_index": 3,
      "chapter_file": "chapter_3.json",
      "section_id": "## 3. The Mass-Conserving Forward Equation (PDE)"
    },
    "generated_at": "2025-11-10T13:57:32.748452+00:00",
    "alt_labels": []
  }
]